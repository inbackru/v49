import os
import json
import logging
import requests

# Configure logging for debugging PDF generation
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

from flask import Flask, render_template, request, jsonify, redirect, url_for, flash, session, abort, Blueprint, send_from_directory, send_file, make_response
from sqlalchemy import text
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from werkzeug.utils import secure_filename
from flask_wtf.csrf import CSRFProtect, validate_csrf
from werkzeug.exceptions import BadRequest

# Configure CSRF protection - ENABLED for security

# Import smart search
from smart_search import smart_search
from urllib.parse import unquote, quote
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase
from werkzeug.middleware.proxy_fix import ProxyFix
import secrets
import re
from email_service import send_notification, send_email
from flask_caching import Cache
import qrcode
import io
import base64
from PIL import Image

# Models will be imported after db initialization to avoid circular imports

def parse_address_components(address_display_name):
    """
    –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–∞—Ä—Å–∏—Ç –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –†–æ—Å—Å–∏—è, –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, –°–æ—á–∏, –ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω, –ò—Å–∫—Ä—ã, 88 –ª–∏—Ç7
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ –∞–¥—Ä–µ—Å–∞
    """
    # –ü–û–õ–ù–ê–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –†–ï–ó–£–õ–¨–¢–ê–¢–ê
    result = {
        'country': None,
        'region': None, 
        'city': None,
        'district': None,
        'street': None,
        'house_number': None
    }
    
    if not address_display_name:
        return result
    
    # –†–ê–ó–ë–ò–í–ê–ï–ú –ê–î–†–ï–° –ü–û –ó–ê–ü–Ø–¢–´–ú
    parts = [part.strip() for part in address_display_name.split(',')]
    
    # –ü–†–Ø–ú–û–ï –ó–ê–ü–û–õ–ù–ï–ù–ò–ï –û–°–ù–û–í–ù–´–• –ß–ê–°–¢–ï–ô
    if len(parts) >= 1:
        result['country'] = parts[0]  # –†–æ—Å—Å–∏—è
        
    if len(parts) >= 2:
        result['region'] = parts[1]   # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π
        
    if len(parts) >= 3:
        result['city'] = parts[2]     # –°–æ—á–∏
        
    # –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –û–°–¢–ê–í–®–ò–ï–°–Ø –ß–ê–°–¢–ò (—Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º)
    if len(parts) >= 4:
        remaining_parts = parts[3:]  # ['–î–∞–≥–æ–º—ã—Å', '–†–æ—Å—Å–∏–π—Å–∫–∞—è', '26–≥ —Å—Ç—Ä']
        
        if len(remaining_parts) == 1:
            # –û–¥–Ω–∞ —á–∞—Å—Ç—å: –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–π–æ–Ω –∏–ª–∏ —É–ª–∏—Ü–∞
            part = remaining_parts[0]
            if any(marker in part for marker in ['–º-–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω', '–ñ–ö', '–∂–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å']):
                result['district'] = part
            else:
                result['street'] = part
                
        elif len(remaining_parts) == 2:
            # –î–≤–µ —á–∞—Å—Ç–∏: —Ä–∞–π–æ–Ω+—É–ª–∏—Ü–∞ –∏–ª–∏ —É–ª–∏—Ü–∞+–¥–æ–º
            first_part, second_part = remaining_parts[0], remaining_parts[1]
            
            if any(marker in first_part for marker in ['–º-–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω']):
                result['district'] = first_part
                result['street'] = second_part
            else:
                result['street'] = first_part
                result['house_number'] = second_part
                
        elif len(remaining_parts) == 3:
            # –¢—Ä–∏ —á–∞—Å—Ç–∏: —Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = remaining_parts[2]
            
        elif len(remaining_parts) >= 4:
            # –ë–æ–ª—å—à–µ —Ç—Ä–µ—Ö —á–∞—Å—Ç–µ–π: —Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º (–æ—Å—Ç–∞–ª—å–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤ –¥–æ–º)
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = ', '.join(remaining_parts[2:])
    
    return result

def update_parsed_addresses():
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –í–°–ï –ø–æ–ª—è parsed_* –¥–ª—è –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    –Ω–∞ –æ—Å–Ω–æ–≤–µ address_display_name
    """
    print("Starting COMPLETE address parsing update...")
    
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ —Å –∞–¥—Ä–µ—Å–∞–º–∏
    result = db.session.execute(text("""
        SELECT inner_id, address_display_name
        FROM excel_properties 
        WHERE address_display_name IS NOT NULL
    """))
    
    records = result.fetchall()
    updated_count = 0
    
    for record in records:
        property_id, address = record
        
        # –ü–∞—Ä—Å–∏–º –∞–¥—Ä–µ—Å –ü–û–õ–ù–û–°–¢–¨–Æ
        parsed = parse_address_components(address)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –í–°–ï –ø–æ–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
        db.session.execute(text("""
            UPDATE excel_properties 
            SET 
                parsed_country = :country,
                parsed_region = :region,
                parsed_city = :city,
                parsed_district = :district,
                parsed_street = :street,
                parsed_house_number = :house_number
            WHERE inner_id = :property_id
        """), {
            'property_id': property_id,
            'country': parsed.get('country'),
            'region': parsed.get('region'),
            'city': parsed.get('city'),
            'district': parsed.get('district'),
            'street': parsed.get('street'),
            'house_number': parsed.get('house_number')
        })
        
        updated_count += 1
        
        # –ö–æ–º–º–∏—Ç–∏–º –ø–∞—á–∫–∞–º–∏
        if updated_count % 50 == 0:
            db.session.commit()
            print(f"Updated {updated_count} records...")
    
    # –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–º–∏—Ç
    db.session.commit()
    print(f"Address parsing complete! Updated {updated_count} records.")
    return updated_count

class Base(DeclarativeBase):
    pass

db = SQLAlchemy(model_class=Base)

# Create the app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET")
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# Initialize CSRF protection after app creation - ENABLED FOR SECURITY
csrf = CSRFProtect(app)

# CSRF configuration (object defined at top of file)
app.config['WTF_CSRF_TIME_LIMIT'] = 3600  # 1 hour
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow non-HTTPS for development

# Add CSRF token to template context - ENABLED
@app.context_processor
def inject_csrf_token():
    from flask_wtf.csrf import generate_csrf
    return dict(csrf_token=generate_csrf)

def validate_json_csrf():
    """Validate CSRF token for JSON requests"""
    try:
        # For JSON requests, expect CSRF token in X-CSRFToken header
        token = request.headers.get('X-CSRFToken')
        print(f"üîê CSRF validation: Token from header: {token[:20] if token else 'NONE'}...")
        if not token:
            print("‚ùå CSRF validation FAILED: No token in X-CSRFToken header")
            return False
        validate_csrf(token)
        print("‚úÖ CSRF validation SUCCESS")
        return True
    except Exception as e:
        print(f"‚ùå CSRF validation FAILED with exception: {e}")
        return False

def require_json_csrf(f):
    """Decorator to require CSRF protection for JSON endpoints"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Check CSRF for all dangerous HTTP methods with JSON content
        if request.method in ['POST', 'PUT', 'PATCH', 'DELETE'] and request.content_type == 'application/json':
            if not validate_json_csrf():
                return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        return f(*args, **kwargs)
    return decorated_function

# –†—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤ –¥–ª—è –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏
RUSSIAN_MONTHS = {
    1: '—è–Ω–≤–∞—Ä—è', 2: '—Ñ–µ–≤—Ä–∞–ª—è', 3: '–º–∞—Ä—Ç–∞', 4: '–∞–ø—Ä–µ–ª—è',
    5: '–º–∞—è', 6: '–∏—é–Ω—è', 7: '–∏—é–ª—è', 8: '–∞–≤–≥—É—Å—Ç–∞',
    9: '—Å–µ–Ω—Ç—è–±—Ä—è', 10: '–æ–∫—Ç—è–±—Ä—è', 11: '–Ω–æ—è–±—Ä—è', 12: '–¥–µ–∫–∞–±—Ä—è'
}

@app.template_filter('russian_date')
def russian_date_filter(date_value):
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ"""
    if not date_value:
        return '–ù–µ–¥–∞–≤–Ω–æ'
    
    if isinstance(date_value, str):
        return date_value
    
    day = date_value.day
    month = RUSSIAN_MONTHS.get(date_value.month, date_value.strftime('%B'))
    year = date_value.year
    
    return f"{day} {month} {year}"

@app.template_filter('msk_time')
def msk_time_filter(utc_datetime, format='%d.%m.%Y –≤ %H:%M'):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç UTC –≤—Ä–µ–º—è –≤ –º–æ—Å–∫–æ–≤—Å–∫–æ–µ (MSK = UTC+3) –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç"""
    if not utc_datetime:
        return '–ù–µ–¥–∞–≤–Ω–æ'
    
    if isinstance(utc_datetime, str):
        return utc_datetime
    
    from datetime import timedelta
    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º UTC –≤ MSK (UTC+3)
    msk_datetime = utc_datetime + timedelta(hours=3)
    return msk_datetime.strftime(format)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—É–ø–µ—Ä-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
app.config['CACHE_TYPE'] = 'simple'
app.config['CACHE_DEFAULT_TIMEOUT'] = 300  # 5 –º–∏–Ω—É—Ç
cache = Cache(app)

# Session configuration for Replit iframe environment
app.config['SESSION_COOKIE_HTTPONLY'] = True
# Session configuration for development
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # Changed from None for better compatibility
app.config['SESSION_COOKIE_SECURE'] = False  # Changed to False for HTTP development
app.config['PERMANENT_SESSION_LIFETIME'] = 60 * 60 * 24  # 24 hours
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Security: prevent JS access to cookies
app.config['WTF_CSRF_TIME_LIMIT'] = 3600  # 1 hour CSRF token timeout
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow development over HTTP

# Enable permanent sessions by default
from datetime import timedelta
app.permanent_session_lifetime = timedelta(hours=24)

# Configure the database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL", "sqlite:///properties.db")
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
}

# Configure file uploads
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['UPLOAD_FOLDER'] = os.path.join('static', 'uploads')

# Ensure upload directory exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Add route for uploaded files
@app.route('/uploads/<path:filename>')
def uploaded_file(filename):
    """Serve uploaded files"""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Initialize the app with the extension
db.init_app(app)

# Import and register all models with SQLAlchemy after db initialization
with app.app_context():
    # Import all models explicitly to ensure they are registered with SQLAlchemy
    from models import (User, Manager, SavedSearch, SentSearch, BlogPost, BlogArticle, Category, 
                       ExcelProperty, Developer, ResidentialComplex, CashbackRecord, 
                       Application, Favorite, Notification, District, Street, RoomType, 
                       Admin, City, Region)
    db.create_all()
    print("Database tables created successfully!")

# Add Jinja2 helper for creating slugs
@app.template_filter('slug')
def create_slug_filter(name):
    """Jinja2 filter for creating SEO-friendly slug from complex name"""
    return create_slug(name)

# Create API blueprint without login requirement
api_bp = Blueprint('api', __name__, url_prefix='/api')

# Debug endpoint removed for security - exposed session data

@api_bp.route('/properties/filter')
def api_properties_filter():
    """
    Unified API endpoint for filtering properties.
    Supports pagination, sorting, and returns properties with coordinates for map.
    
    Query parameters:
        - All filter parameters from build_property_filters()
        - page (int): Page number (default: 1)
        - per_page (int): Results per page (default: 20, max: 100)
        - sort (str): Sort type (price_asc, price_desc, area_asc, area_desc, date_desc)
    
    Returns:
        JSON with:
        - success (bool)
        - properties (list): Filtered properties with coordinates
        - total (int): Total count of filtered properties
        - page (int): Current page
        - per_page (int): Results per page
        - total_pages (int): Total pages
    """
    try:
        # Use unified filter function
        where_conditions, params, filters = build_property_filters(request.args)
        
        # Pagination parameters
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = request.args.get('per_page', default=20, type=int)
        per_page = min(max(1, per_page), 10000)  # Limit to 10000 max (for map view)
        offset = (page - 1) * per_page
        
        # Sorting (with ep. prefix for excel_properties columns)
        sort_type = request.args.get('sort', 'price_asc').replace('_', '-').replace('-', '_')
        sort_clause = 'ep.price ASC'
        if sort_type == 'price_desc':
            sort_clause = 'ep.price DESC'
        elif sort_type == 'price_asc':
            sort_clause = 'ep.price ASC'
        elif sort_type == 'area_asc':
            sort_clause = 'ep.object_area ASC'
        elif sort_type == 'area_desc':
            sort_clause = 'ep.object_area DESC'
        elif sort_type == 'date_desc':
            sort_clause = 'ep.complex_building_end_build_year DESC, ep.complex_building_end_build_quarter DESC'
        
        # Build complete WHERE clause with ep. prefix for excel_properties columns
        where_clause = ' AND '.join(where_conditions) if where_conditions else '1=1'
        # Add ep. prefix to all column references in WHERE clause
        where_clause_with_prefix = where_clause.replace('price ', 'ep.price ').replace('object_area ', 'ep.object_area ').replace('object_rooms ', 'ep.object_rooms ').replace('object_min_floor ', 'ep.object_min_floor ').replace('object_max_floor ', 'ep.object_max_floor ').replace('address_locality_name ', 'ep.address_locality_name ').replace('developer_name ', 'ep.developer_name ').replace('complex_name ', 'ep.complex_name ').replace('complex_building_name ', 'ep.complex_building_name ').replace('complex_building_end_build_year ', 'ep.complex_building_end_build_year ').replace('complex_building_end_build_quarter ', 'ep.complex_building_end_build_quarter ').replace('complex_end_build_year ', 'ep.complex_end_build_year ').replace('complex_end_build_quarter ', 'ep.complex_end_build_quarter ').replace('complex_object_class_display_name ', 'ep.complex_object_class_display_name ').replace('renovation_display_name ', 'ep.renovation_display_name ').replace('description ', 'ep.description ').replace('address_display_name ', 'ep.address_display_name ')
        
        # Count query - no JOIN needed, using excel_properties.complex_min_rate directly
        count_query = f"""
            SELECT COUNT(*)
            FROM excel_properties ep
            WHERE {where_clause_with_prefix}
        """
        
        count_result = db.session.execute(text(count_query), params)
        total = count_result.scalar()
        
        # Main query with coordinates for map - use excel_properties.complex_min_rate as authoritative source
        query = f"""
            SELECT 
                ep.inner_id,
                ep.price,
                ep.object_area,
                ep.object_rooms,
                ep.object_min_floor,
                ep.object_max_floor,
                ep.address_display_name,
                ep.address_position_lat,
                ep.address_position_lon,
                ep.complex_name,
                ep.developer_name,
                ep.address_locality_display_name as district,
                ep.photos,
                ep.complex_building_end_build_year,
                ep.complex_building_end_build_quarter,
                ep.complex_object_class_display_name,
                ep.renovation_display_name,
                ep.complex_min_rate as cashback_rate
            FROM excel_properties ep
            WHERE {where_clause_with_prefix}
            ORDER BY {sort_clause}
            LIMIT :limit OFFSET :offset
        """
        
        params['limit'] = per_page
        params['offset'] = offset
        
        result = db.session.execute(text(query), params)
        rows = result.fetchall()
        
        # Format properties for JSON response
        properties = []
        for row in rows:
            # Parse photos
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            gallery = [main_image]
            if row.photos:
                try:
                    photos_raw = json.loads(row.photos)
                    if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                        main_image = photos_raw[0]
                        gallery = photos_raw[:5]
                except:
                    pass
            
            # Format room type
            rooms = int(row.object_rooms or 0)
            room_type = "–°—Ç—É–¥–∏—è" if rooms == 0 else f"{rooms}-–∫–æ–º–Ω"
            
            # Format floor info
            floor_min = int(row.object_min_floor or 1)
            floor_max = int(row.object_max_floor or floor_min)
            floor_text = f"{floor_min}/{floor_max}" if floor_min == floor_max else f"{floor_min}-{floor_max}/{floor_max}"
            
            # Cashback rate (from residential_complexes via JOIN)
            cashback_rate = float(row.cashback_rate) if row.cashback_rate else None
            
            # Build property object
            prop = {
                'id': row.inner_id,
                'price': int(row.price or 0),
                'area': float(row.object_area or 0),
                'rooms': rooms,
                'room_type': room_type,
                'floor': floor_text,
                'floor_min': floor_min,
                'floor_max': floor_max,
                'title': f"{room_type}, {row.object_area} –º¬≤, {floor_text} —ç—Ç.",
                'address': row.address_display_name or '',
                'complex_name': row.complex_name or '',
                'residential_complex': row.complex_name or '',
                'developer': row.developer_name or '',
                'district': row.district or '',
                'image': main_image,
                'gallery': gallery,
                'object_class': row.complex_object_class_display_name or '',
                'renovation': row.renovation_display_name or '',
                'cashback_rate': cashback_rate,
                'cashback_available': bool(cashback_rate and cashback_rate > 0),
                'url': f'/object/{row.inner_id}',
                # Coordinates for map
                'lat': float(row.address_position_lat) if row.address_position_lat else None,
                'lon': float(row.address_position_lon) if row.address_position_lon else None,
                'coordinates': {
                    'lat': float(row.address_position_lat) if row.address_position_lat else None,
                    'lng': float(row.address_position_lon) if row.address_position_lon else None
                } if row.address_position_lat and row.address_position_lon else None
            }
            
            properties.append(prop)
        
        total_pages = (total + per_page - 1) // per_page  # Ceiling division
        
        return jsonify({
            'success': True,
            'properties': properties,
            'total': total,
            'page': page,
            'per_page': per_page,
            'total_pages': total_pages,
            'filters_applied': filters
        })
        
    except Exception as e:
        print(f"‚ùå Error in /api/properties/filter: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e),
            'properties': [],
            'total': 0
        }), 500

@api_bp.route('/property/<int:property_id>/cashback')
def api_property_cashback(property_id):
    """Get cashback information for a property - reads from database complex_min_rate field"""
    try:
        # Query database directly for property data with complex_min_rate
        query = text("""
            SELECT 
                ep.inner_id,
                ep.price,
                ep.object_rooms,
                ep.complex_name,
                ep.complex_min_rate
            FROM excel_properties ep
            WHERE ep.inner_id = :property_id
        """)
        
        result = db.session.execute(query, {'property_id': property_id})
        row = result.fetchone()
        
        if not row:
            return jsonify({'success': False, 'error': 'Property not found'})
        
        # Extract data from database
        price = int(row.price or 0)
        rooms = int(row.object_rooms or 0)
        complex_name = row.complex_name or "–ù–µ —É–∫–∞–∑–∞–Ω"
        
        # Use complex_min_rate from database as authoritative source, fallback to 0 if null
        cashback_percent = float(row.complex_min_rate) if row.complex_min_rate else 0
        
        # Calculate cashback amount
        cashback_amount = price * (cashback_percent / 100)
        
        # Format property name
        room_text = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞" if rooms > 0 else "–°—Ç—É–¥–∏—è"
        property_name = f"{room_text} –≤ –ñ–ö ¬´{complex_name}¬ª"
        
        return jsonify({
            'success': True,
            'property_id': property_id,
            'property_name': property_name,
            'property_price': price,
            'cashback_percent': cashback_percent,
            'cashback_amount': int(cashback_amount),
            'complex_name': complex_name,
            'rooms': rooms
        })
        
    except Exception as e:
        print(f"Error getting property cashback: {e}")
        return jsonify({'success': False, 'error': 'Server error'})

# Custom Jinja2 filters
def street_slug(street_name):
    """Convert street name to URL slug with transliteration"""
    import re
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
    }
    
    # Clean the name
    name = str(street_name).strip().lower()
    # Remove extra characters
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)
    
    # Transliterate
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    result = result.strip('-')
    
    return result

def number_format(value):
    """Format number with space separators"""
    try:
        if isinstance(value, str):
            value = int(value)
        return f"{value:,}".replace(',', ' ')
    except (ValueError, TypeError):
        return str(value)

@app.template_filter('developer_slug')
def developer_slug(developer_name):
    """Convert developer name to URL slug with transliteration"""
    import re
    if not developer_name:
        return ""
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
        '–ê': 'A', '–ë': 'B', '–í': 'V', '–ì': 'G', '–î': 'D', '–ï': 'E', '–Å': 'YO',
        '–ñ': 'ZH', '–ó': 'Z', '–ò': 'I', '–ô': 'Y', '–ö': 'K', '–õ': 'L', '–ú': 'M',
        '–ù': 'N', '–û': 'O', '–ü': 'P', '–†': 'R', '–°': 'S', '–¢': 'T', '–£': 'U',
        '–§': 'F', '–•': 'KH', '–¶': 'TS', '–ß': 'CH', '–®': 'SH', '–©': 'SCH',
        '–™': '', '–´': 'Y', '–¨': '', '–≠': 'E', '–Æ': 'YU', '–Ø': 'YA'
    }
    
    # Remove extra spaces and clean
    name = str(developer_name).strip()
    # Remove quotes, parentheses, dots, commas
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)  
    
    # Transliterate cyrillic to latin
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)  # Replace spaces with hyphens
    result = re.sub(r'-+', '-', result)   # Replace multiple hyphens with single
    result = result.strip('-')  # Remove leading/trailing hyphens
    return result.lower()

@app.template_filter('from_json')
def from_json_filter(json_string):
    """–ü–∞—Ä—Å–∏—Ç JSON —Å—Ç—Ä–æ–∫—É –≤ –æ–±—ä–µ–∫—Ç Python"""
    if not json_string:
        return []
    try:
        if isinstance(json_string, str):
            return json.loads(json_string)
        return json_string
    except (json.JSONDecodeError, TypeError):
        return []

@app.template_filter('crop_watermark')
def crop_watermark_filter(image_url, crop_percent=8):
    """
    Convert image URL to proxied URL with watermark cropped
    Usage in template: {{ image_url | crop_watermark(10) }}
    """
    if not image_url:
        return image_url
    
    from urllib.parse import quote
    encoded_url = quote(image_url, safe='')
    return f"/api/image-proxy?url={encoded_url}&crop={crop_percent}"

def format_room_display(rooms):
    """Format room count for display"""
    if rooms == 0:
        return "–°—Ç—É–¥–∏—è"
    else:
        return f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"

app.jinja_env.filters['street_slug'] = street_slug
app.jinja_env.filters['number_format'] = number_format
app.jinja_env.filters['developer_slug'] = developer_slug

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # type: ignore
login_manager.login_message = '–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ.'
login_manager.login_message_category = 'info'



# Property data loading functions with cache
_properties_cache = None
_cache_timestamp = None
CACHE_TIMEOUT = 300  # 5 minutes

def load_properties():
    """Load properties from database with fallback to JSON files"""
    global _properties_cache, _cache_timestamp
    import time
    
    # Check if we have valid cached data
    if (_properties_cache is not None and _cache_timestamp is not None and 
        time.time() - _cache_timestamp < CACHE_TIMEOUT):
        # Cache hit - fast path
        return _properties_cache
    
    # Ensure we have app context
    from flask import has_app_context
    if not has_app_context():
        with app.app_context():
            return load_properties()
    
    try:
        # Load from excel_properties table using raw SQL - EXPANDED FIELDS
        # ‚úÖ FIX: Added parsed_district and parsed_city for proper district display
        sql_query = """
            SELECT inner_id, complex_name, developer_name, object_rooms, object_area, 
                   price, object_min_floor, object_max_floor, address_display_name, 
                   address_position_lat, address_position_lon, address_locality_display_name,
                   photos, complex_object_class_display_name,
                   renovation_type, renovation_display_name, complex_with_renovation,
                   complex_building_end_build_year, complex_building_end_build_quarter,
                   complex_building_name, address_subways, trade_in, deal_type,
                   square_price, mortgage_price, object_is_apartment, max_price, min_price,
                   complex_has_green_mortgage, placement_type, description, 
                   parsed_district, parsed_city, complex_id, complex_min_rate
            FROM excel_properties 
            WHERE price > 0 AND address_position_lat IS NOT NULL
        """
        
        result = db.session.execute(text(sql_query))
        excel_properties = result.fetchall()
        
        if excel_properties and len(excel_properties) > 0:
            # Pre-load max floors for all complexes with ONE query (prevents N+1 problem)
            max_floors_result = db.session.execute(text("""
                SELECT complex_name, MAX(object_max_floor) as max_floors
                FROM excel_properties
                WHERE object_max_floor > 1
                GROUP BY complex_name
            """))
            complex_max_floors = {row[0]: row[1] for row in max_floors_result.fetchall()}
            
            # Convert excel_properties to dictionary format
            db_properties = []
            for prop in excel_properties:
                prop_dict = dict(prop._mapping)
                
                # Parse photos field (JSON array format)
                photos_raw = prop_dict.get('photos', '')
                main_image = '/static/images/no-photo.jpg'
                
                if photos_raw and photos_raw.strip():
                    try:
                        # Try to parse as JSON array first (current database format)
                        if photos_raw.startswith('[') and photos_raw.endswith(']'):
                            images = json.loads(photos_raw)
                            if images and isinstance(images, list) and len(images) > 0:
                                main_image = images[0].strip() if images[0] else '/static/images/no-photo.jpg'
                        # Fallback: PostgreSQL array format {url1,url2,url3}
                        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
                            images_str = photos_raw[1:-1]  # Remove braces
                            if images_str:
                                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                                main_image = images[0] if images else '/static/images/no-photo.jpg'
                        # Single image URL
                        else:
                            main_image = photos_raw.strip()
                    except (json.JSONDecodeError, ValueError, IndexError) as e:
                        print(f"Error parsing photos for property {prop_dict.get('inner_id')}: {e}")
                        main_image = '/static/images/no-photo.jpg'
                
                # Get correct total floors for the complex
                complex_total_floors = prop_dict.get('object_max_floor', 1)
                # If floor data seems wrong (1/1), get real max floors from pre-loaded dictionary
                if complex_total_floors == 1:
                    complex_total_floors = complex_max_floors.get(prop_dict.get('complex_name', ''), 1)
                
                # Format property data  
                rooms = prop_dict.get('object_rooms', 0)
                area = prop_dict.get('object_area', 0) 
                floor = prop_dict.get('object_min_floor', 1)
                
                # Create title with proper format: "–°—Ç—É–¥–∏—è, 23.40 –º¬≤, 1/12 —ç—Ç."
                if rooms == 0:
                    title = f"–°—Ç—É–¥–∏—è, {area} –º¬≤, {floor}/{complex_total_floors} —ç—Ç."
                else:
                    title = f"{rooms}-–∫–æ–º–Ω, {area} –º¬≤, {floor}/{complex_total_floors} —ç—Ç."
                
                # Enhanced completion date from building data
                completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
                if prop_dict.get('complex_building_end_build_year') and prop_dict.get('complex_building_end_build_quarter'):
                    year = prop_dict.get('complex_building_end_build_year')
                    quarter = prop_dict.get('complex_building_end_build_quarter')
                    completion_date = f"{quarter} –∫–≤. {year} –≥."
                elif prop_dict.get('complex_building_end_build_year'):
                    year = prop_dict.get('complex_building_end_build_year')  
                    completion_date = f"{year} –≥."
                
                # Enhanced finishing information
                finishing = prop_dict.get('renovation_display_name') or prop_dict.get('renovation_type', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
                if prop_dict.get('complex_with_renovation'):
                    finishing = finishing if finishing != '–ù–µ —É–∫–∞–∑–∞–Ω–∞' else '–° –æ—Ç–¥–µ–ª–∫–æ–π'
                
                formatted_prop = {
                    'id': prop_dict.get('inner_id'),
                    'title': title,
                    'rooms': prop_dict.get('object_rooms', 0),
                    'area': prop_dict.get('object_area', 0),
                    'price': prop_dict.get('price', 0),
                    # Use database square_price if available, fallback to calculation
                    'price_per_sqm': prop_dict.get('square_price') or (int(prop_dict.get('price', 0) / prop_dict.get('object_area', 1)) if prop_dict.get('object_area', 0) > 0 else 0),
                    'floor': prop_dict.get('object_min_floor', 1),
                    'total_floors': complex_total_floors,
                    'address': prop_dict.get('address_display_name', ''),
                    'coordinates': {
                        'lat': float(prop_dict.get('address_position_lat', 45.0448)),
                        'lng': float(prop_dict.get('address_position_lon', 38.9728))
                    },
                    'cashback': calculate_cashback(
                        prop_dict.get('price', 0),
                        complex_id=prop_dict.get('complex_id'),
                        complex_name=prop_dict.get('complex_name')
                    ),
                    'cashback_rate': float(prop_dict.get('complex_min_rate', 0)) if prop_dict.get('complex_min_rate') else 0,
                    'cashback_available': True,
                    'status': 'available',
                    'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞' if prop_dict.get('object_is_apartment', True) else '–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å',
                    'developer': prop_dict.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                    'residential_complex': prop_dict.get('complex_name', '–ñ–ö –ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                    'district': prop_dict.get('parsed_district') or prop_dict.get('parsed_city') or prop_dict.get('address_locality_display_name', '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'),
                    'main_image': main_image,
                    'url': f"/object/{prop_dict.get('inner_id')}",
                    'complex_name': prop_dict.get('complex_name', '–ñ–ö –ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                    'type': 'property',
                    # NEW ENHANCED FIELDS FROM DATABASE:
                    'finishing': finishing,
                    'renovation_type': prop_dict.get('renovation_type'),
                    'completion_date': completion_date,
                    'complex_class': prop_dict.get('complex_object_class_display_name', ''),
                    'building_name': prop_dict.get('complex_building_name', ''),
                    'nearest_metro': prop_dict.get('address_subways', ''),
                    'trade_in_available': bool(prop_dict.get('trade_in', False)),
                    'deal_type': prop_dict.get('deal_type', ''),
                    'mortgage_price': prop_dict.get('mortgage_price'),
                    'max_price': prop_dict.get('max_price'),
                    'min_price': prop_dict.get('min_price'),
                    'green_mortgage_available': bool(prop_dict.get('complex_has_green_mortgage', False)),
                    'placement_type': prop_dict.get('placement_type', ''),
                    'description': prop_dict.get('description', ''),
                    'complex_with_renovation': bool(prop_dict.get('complex_with_renovation', False))
                }
                db_properties.append(formatted_prop)
            
            # Successfully loaded properties from database
            # Cache the data
            _properties_cache = db_properties  
            _cache_timestamp = time.time()
            return db_properties
            
    except Exception as e:
        # Database error logged  
        print(f"CRITICAL: load_properties() database error: {e}")
        import traceback
        traceback.print_exc()
        pass
        
    # No fallback - only database data from now on
    # No properties found
    return []

def load_residential_complexes():
    """Load residential complexes from database enriched with statistics from excel_properties"""
    try:
        # First try to load from database
        from models import ResidentialComplex, Developer, District
        
        complexes = ResidentialComplex.query.all()
        
        if complexes and len(complexes) > 0:
            # Convert database complexes to dictionary format
            db_complexes = []
            for complex in complexes:
                # Enrich with statistics from excel_properties
                try:
                    stats_result = db.session.execute(text("""
                        SELECT 
                            MIN(price) as min_price,
                            MAX(price) as max_price,
                            COUNT(DISTINCT inner_id) as apartments_count
                        FROM excel_properties 
                        WHERE complex_name = :complex_name
                    """), {'complex_name': complex.name}).fetchone()
                    
                    min_price = stats_result[0] if stats_result and stats_result[0] else None
                    max_price = stats_result[1] if stats_result and stats_result[1] else None
                    apartments_count = int(stats_result[2]) if stats_result and stats_result[2] else 0
                except Exception as e:
                    print(f"Warning: Could not load stats for complex {complex.id}: {e}")
                    db.session.rollback()  # Rollback failed transaction
                    min_price = None
                    max_price = None
                    apartments_count = 0
                
                complex_dict = {
                    'id': complex.id,
                    'name': complex.name,
                    'slug': complex.slug,
                    'district': complex.district.name if complex.district else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'developer': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'cashback_rate': complex.cashback_rate or 5.0,
                    'cashback_percent': complex.cashback_rate or 5.0,
                    'class': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                    'description': f'–ñ–ö –æ—Ç –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ {complex.developer.name if complex.developer else "–ù–µ —É–∫–∞–∑–∞–Ω"}',
                    'start_year': complex.start_build_year,
                    'completion_year': complex.end_build_year,
                    'quarter': complex.end_build_quarter,
                    'features': {
                        'accreditation': complex.has_accreditation,
                        'green_mortgage': complex.has_green_mortgage,
                        'big_check': complex.has_big_check,
                        'with_renovation': complex.with_renovation,
                        'financing_sber': complex.financing_sber,
                    },
                    'phones': {
                        'complex': complex.complex_phone,
                        'sales': complex.sales_phone,
                    },
                    'sales_address': complex.sales_address,
                    'image': 'https://via.placeholder.com/800x600/0088CC/FFFFFF?text=' + complex.name.replace(' ', '+'),  # Placeholder for now
                    'address': complex.sales_address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                    'location': complex.sales_address or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',  # Add missing location field
                    # Add statistics from excel_properties
                    'min_price': min_price,
                    'price_from': min_price,
                    'max_price': max_price,
                    'price_to': max_price,
                    'apartments_count': apartments_count,
                    'properties_count': apartments_count,
                }
                db_complexes.append(complex_dict)
            
            # Complexes loaded successfully
            return db_complexes
            
    except Exception as e:
        # Error loading complexes
        print(f"Error in load_residential_complexes: {e}")
        import traceback
        traceback.print_exc()
    
    # No fallback - only database data from now on
    # No complexes found
    return []

def load_blog_articles():
    """Load blog articles from JSON file"""
    try:
        with open('data/blog_articles.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_blog_categories():
    """Load blog categories from JSON file"""
    try:
        with open('data/blog_categories.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_search_data():
    """Load search data from JSON file"""
    try:
        with open('data/search_data.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def load_streets():
    """Load streets from JSON file"""
    try:
        with open('data/streets.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_developers():
    """Load developers from residential complexes data"""
    try:
        complexes = load_residential_complexes()
        developers = {}
        
        for complex in complexes:
            dev_name = complex.get('developer', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫')
            if dev_name not in developers:
                developers[dev_name] = {
                    'name': dev_name,
                    'projects_count': 0,
                    'complexes': []
                }
            developers[dev_name]['projects_count'] += 1
            developers[dev_name]['complexes'].append(complex['name'])
        
        return list(developers.values())
    except Exception:
        return []

def search_global(query):
    """Global search across all types: –ñ–ö, districts, developers, streets"""
    if not query or len(query.strip()) < 2:
        return []
    
    search_data = load_search_data()
    results = []
    query_lower = query.lower().strip()
    
    # Search through all categories
    for category in ['residential_complexes', 'districts', 'developers', 'streets']:
        items = search_data.get(category, [])
        for item in items:
            # Search in name and keywords
            name_match = query_lower in item['name'].lower()
            keyword_match = any(query_lower in keyword.lower() for keyword in item.get('keywords', []))
            
            if name_match or keyword_match:
                # Calculate relevance score
                score = 0
                if query_lower in item['name'].lower():
                    score += 10  # Higher score for name matches
                if query_lower == item['name'].lower():
                    score += 20  # Even higher for exact matches
                    
                result = {
                    'id': item['id'],
                    'name': item['name'],
                    'type': item['type'],
                    'url': item['url'],
                    'score': score
                }
                
                # Add additional context based on type
                if item['type'] == 'residential_complex':
                    result['district'] = item.get('district', '')
                    result['developer'] = item.get('developer', '')
                elif item['type'] == 'street':
                    result['district'] = item.get('district', '')
                    
                results.append(result)
    
    # Sort by relevance score (highest first)
    results.sort(key=lambda x: x['score'], reverse=True)
    return results[:10]  # Return top 10 results

def get_article_by_slug(slug):
    """Get a single article by slug"""
    articles = load_blog_articles()
    for article in articles:
        if article['slug'] == slug:
            return article
    return None

def search_articles(query, category=None):
    """Search articles by title, excerpt, content, and tags"""
    articles = load_blog_articles()
    if not query and not category:
        return articles
    
    filtered_articles = []
    for article in articles:
        # Filter by category if specified
        if category and article['category'].lower() != category.lower():
            continue
        
        # If no search query, return all articles in category
        if not query:
            filtered_articles.append(article)
            continue
        
        # Search in title, excerpt, content, and tags
        query_lower = query.lower()
        if (query_lower in article['title'].lower() or 
            query_lower in article['excerpt'].lower() or 
            query_lower in article['content'].lower() or 
            any(query_lower in tag.lower() for tag in article['tags'])):
            filtered_articles.append(article)
    
    return filtered_articles

def _extract_first_photo(photos_json):
    """Extract first photo from photos JSON string"""
    if not photos_json:
        return None
    
    try:
        import json
        if isinstance(photos_json, str):
            photos_list = json.loads(photos_json)
        else:
            photos_list = photos_json
            
        return photos_list[0] if photos_list and len(photos_list) > 0 else None
    except:
        return None

def calculate_cashback(price, complex_id=None, complex_name=None):
    """Calculate cashback amount based on property price and complex cashback rate"""
    if not price or price == 0:
        return 0
    
    try:
        from models import ResidentialComplex
        
        # If complex_id provided, use its cashback rate from database (backwards compatibility)
        if complex_id:
            complex_obj = ResidentialComplex.query.filter_by(id=str(complex_id)).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
        
        # If complex_name provided, look up by name
        if complex_name:
            complex_obj = ResidentialComplex.query.filter_by(name=complex_name).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
    except Exception as e:
        print(f"Error getting complex cashback rate: {e}")
    
    # Fallback to default 5% calculation if no complex found or error
    return int(price * 0.05)  # 5% default cashback

def get_property_by_id(property_id):
    """Get a single property by ID from Excel database with all photos"""
    try:
        # ‚úÖ FIX: JOIN with residential_complexes to get correct cashback_rate from admin panel
        result = db.session.execute(text("""
        SELECT 
            ep.inner_id, ep.price, ep.object_area, ep.object_rooms, ep.object_min_floor, ep.object_max_floor, 
            ep.address_display_name, ep.renovation_display_name, 
            COALESCE(rc.cashback_rate, ep.complex_min_rate, 0) as cashback_rate,
            ep.square_price, ep.mortgage_price, 
            ep.complex_object_class_display_name, ep.photos, ep.developer_name, ep.complex_name, 
            ep.complex_end_build_year, ep.complex_end_build_quarter, 
            ep.complex_building_end_build_year, ep.complex_building_end_build_quarter,
            ep.address_position_lat, ep.address_position_lon, ep.description, ep.address_locality_name
        FROM excel_properties ep
        LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
        WHERE ep.inner_id = :property_id
        """), {'property_id': property_id})
        
        row = result.fetchone()
        
        if not row:
            return None
            
        # Parse the row data into property format
        inner_id, price, area, rooms, min_floor, max_floor, address, renovation, cashback_rate, square_price, mortgage_price, class_type, photos, developer_name, complex_name, complex_end_year, complex_end_quarter, building_end_year, building_end_quarter, lat, lon, description, district_name = row
        
        # Parse photos JSON
        images = []
        floor_plan = None
        complex_photos = []
        
        try:
            if photos:
                photos_data = json.loads(photos)
                if isinstance(photos_data, list):
                    # If it's a simple list of photo URLs (like in this case)
                    images = photos_data
                    # First photo is always the floor plan
                    if len(images) > 0:
                        floor_plan = images[0]  # First image is floor plan
                elif isinstance(photos_data, dict):
                    # Get apartment gallery photos from dict structure
                    images = photos_data.get('apartment_gallery', [])
                    # Get floor plan 
                    floor_plans = photos_data.get('floor_plans', [])
                    if floor_plans and len(floor_plans) > 0:
                        floor_plan = floor_plans[0]  # Take first floor plan
                    # Get complex photos
                    complex_photos = photos_data.get('complex_gallery', [])
        except Exception as e:
            print(f"Error parsing photos for property {property_id}: {e}")
            pass
        
        # Build completion date
        completion_date = '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
        if building_end_year and building_end_quarter:
            completion_date = f"{building_end_year} –≥., {building_end_quarter} –∫–≤."
        elif building_end_year:
            completion_date = f"{building_end_year} –≥."
        elif complex_end_year:
            completion_date = f"{complex_end_year} –≥."
        
        # Create property data structure matching PDF template expectations
        property_data = {
            'id': inner_id,
            'title': f"{'–°—Ç—É–¥–∏—è' if rooms == 0 else f'{rooms}-–∫. –∫–≤–∞—Ä—Ç–∏—Ä–∞'}, {area} –º¬≤",
            'price': price or 0,
            'area': area or 0,
            'rooms': rooms or 0,
            'floor': min_floor or 1,
            'total_floors': max_floor or min_floor or 1,
            'address': address or f"{district_name}, –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä" if district_name else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
            'developer': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'residential_complex': complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'district': district_name or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
            'status': '–°–≤–æ–±–æ–¥–Ω–∞',
            'property_type': '–°—Ç—É–¥–∏—è' if rooms == 0 else '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
            'renovation_type': renovation or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'finishing': renovation or '–ü—Ä–µ–¥—á–∏—Å—Ç–æ–≤–∞—è',
            'completion_date': completion_date,
            'cashback_rate': cashback_rate or 0,
            'mortgage_rate': f"{cashback_rate}%" if cashback_rate else '3.5%',
            'square_price': square_price,
            'mortgage_payment': mortgage_price,
            'class_type': class_type or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'description': description or '',
            'residential_complex_description': f"–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∂–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å –æ—Ç –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ {developer_name}" if developer_name else None,
            'mortgage_available': True,
            'installment_available': False,
            'cashback_available': True,
            # Photos for PDF
            'image': images[0] if images else None,  # Main photo
            'gallery': images,  # All apartment photos
            'floor_plan': floor_plan,  # Floor plan photo
            'complex_photos': complex_photos,  # Complex photos
            # Additional fields expected by PDF template
            'bathroom_type': '–°–æ–≤–º–µ—â–µ–Ω–Ω—ã–π',
            'has_balcony': True,
            'windows_type': '–ü–ª–∞—Å—Ç–∏–∫–æ–≤—ã–µ', 
            'elevators': '2 –ø–∞—Å—Å–∞–∂–∏—Ä—Å–∫–∏—Ö',
            'parking_type': '–ù–∞–∑–µ–º–Ω–∞—è',
            'developer_inn': '–ò–ù–ù –Ω–µ —É–∫–∞–∑–∞–Ω',
            'complex_name': complex_name  # Add complex_name for cashback calculation
        }
        
        return property_data
        
    except Exception as e:
        print(f"Error getting property {property_id}: {e}")
        return None

def get_filtered_properties(filters):
    """Filter properties based on criteria including regional filters"""
    properties = load_properties()
    filtered = []
    
    for prop in properties:
        # Keywords filter (–¥–ª—è —Ç–∏–ø–æ–≤ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏, –∫–ª–∞—Å—Å–æ–≤, –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤)
        if filters.get('keywords') and len(filters['keywords']) > 0:
            keywords_matched = False
            for keyword in filters['keywords']:
                keyword_lower = keyword.lower()
                
                # Check property type
                prop_type_lower = prop.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞').lower()
                if keyword_lower == '–¥–æ–º' and prop_type_lower == '–¥–æ–º':
                    keywords_matched = True
                    break
                elif keyword_lower == '—Ç–∞—É–Ω—Ö–∞—É—Å' and prop_type_lower == '—Ç–∞—É–Ω—Ö–∞—É—Å':
                    keywords_matched = True
                    break
                elif keyword_lower == '–ø–µ–Ω—Ç—Ö–∞—É—Å' and prop_type_lower == '–ø–µ–Ω—Ç—Ö–∞—É—Å':
                    keywords_matched = True
                    break
                elif keyword_lower == '–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã' and prop_type_lower == '–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã':
                    keywords_matched = True
                    break
                elif keyword_lower == '—Å—Ç—É–¥–∏—è' and (prop_type_lower == '—Å—Ç—É–¥–∏—è' or prop.get('rooms') == 0):
                    keywords_matched = True
                    break
                elif keyword_lower == '–∫–≤–∞—Ä—Ç–∏—Ä–∞' and prop_type_lower == '–∫–≤–∞—Ä—Ç–∏—Ä–∞':
                    keywords_matched = True
                    break
                
                # Check property class
                elif keyword_lower == prop.get('property_class', '').lower():
                    keywords_matched = True
                    break
                
                # Check wall material
                elif keyword_lower in prop.get('wall_material', '').lower():
                    keywords_matched = True
                    break
                
                # Check features
                elif any(keyword_lower in feature.lower() for feature in prop.get('features', [])):
                    keywords_matched = True
                    break
                
                # Check in property type as fallback  
                elif keyword_lower in (f"{prop.get('rooms', 0)}-–∫–æ–º–Ω" if prop.get('rooms', 0) > 0 else "—Å—Ç—É–¥–∏—è").lower():
                    keywords_matched = True
                    break
                    
            if not keywords_matched:
                continue
        
        # Text search with improved room number matching and word-based search
        if filters.get('search'):
            search_term = filters['search'].lower()
            
            # Create multiple variations for room descriptions
            rooms = prop.get('rooms', 0)
            if rooms == 0:
                room_variations = ["—Å—Ç—É–¥–∏—è", "studio"]
            else:
                room_variations = [
                    f"{rooms}-–∫–æ–º–Ω",
                    f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è",
                    f"{rooms} –∫–æ–º–Ω",
                    f"{rooms} –∫–æ–º–Ω–∞—Ç–Ω–∞—è"
                ]
                
                # Add spelled out numbers for 1-3 rooms
                if rooms == 1:
                    room_variations.extend(["–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "–æ–¥–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞"])
                elif rooms == 2:
                    room_variations.extend(["–¥–≤—É—Ö–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "–¥–≤–µ –∫–æ–º–Ω–∞—Ç—ã"])
                elif rooms == 3:
                    room_variations.extend(["—Ç—Ä–µ—Ö–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã"])
            
            # Create searchable text with all variations
            property_title = f"{prop.get('rooms', 0)}-–∫–æ–º–Ω" if prop.get('rooms', 0) > 0 else "—Å—Ç—É–¥–∏—è"
            searchable_text = f"{property_title} {' '.join(room_variations)} {prop.get('developer_name', prop.get('developer', ''))} {prop.get('address_locality_name', prop.get('district', ''))} {prop.get('complex_name', prop.get('residential_complex', ''))} {prop.get('location', '')} –∫–≤–∞—Ä—Ç–∏—Ä–∞".lower()
            
            # Split search term into words and check if all words are found
            search_words = search_term.split()
            match_found = True
            
            for word in search_words:
                if word not in searchable_text:
                    match_found = False
                    break
            
            if not match_found:
                continue
        
        # Rooms filter - handle both single value and array
        if filters.get('rooms'):
            rooms_filter = filters['rooms']
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º object_rooms –≤–º–µ—Å—Ç–æ rooms
            property_rooms = prop.get('object_rooms', prop.get('rooms', 0))
            
            # Helper function to parse room filter value
            def parse_room_filter(room_value):
                """Convert room filter to integer: '2-–∫–æ–º–Ω' -> 2, '—Å—Ç—É–¥–∏—è' -> 0, '2' -> 2"""
                if not room_value:
                    return None
                room_str = str(room_value).lower().strip()
                
                # Handle special cases
                if room_str in ['—Å—Ç—É–¥–∏—è', 'studio']:
                    return 0
                if room_str in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                    return 4  # Will be handled as >= 4
                
                # Handle "X-–∫–æ–º–Ω" format
                if '-–∫–æ–º–Ω' in room_str:
                    try:
                        return int(room_str.split('-')[0])
                    except (ValueError, IndexError):
                        return None
                
                # Handle numeric string
                try:
                    return int(room_str)
                except (ValueError, TypeError):
                    return None
            
            # Handle array of rooms from saved searches
            if isinstance(rooms_filter, list):
                rooms_match = False
                for room_filter in rooms_filter:
                    room_num = parse_room_filter(room_filter)
                    if room_num is None:
                        continue
                    
                    # Special case for 4+ rooms
                    if str(room_filter).lower() in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                        if property_rooms >= 4:
                            rooms_match = True
                            break
                    # Exact match
                    elif property_rooms == room_num:
                        rooms_match = True
                        break
                
                if not rooms_match:
                    continue
            else:
                # Handle single room value
                room_num = parse_room_filter(rooms_filter)
                if room_num is None:
                    continue
                    
                # Special case for 4+ rooms
                if str(rooms_filter).lower() in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                    if property_rooms < 4:
                        continue
                # Exact match
                elif property_rooms != room_num:
                    continue
        
        # Price filter - handle both raw rubles and millions
        if filters.get('price_min') and filters['price_min']:
            try:
                min_price = int(filters['price_min'])
                # If value is small, assume it's in millions
                if min_price < 1000:
                    min_price = min_price * 1000000
                if prop['price'] < min_price:
                    continue
            except (ValueError, TypeError):
                pass
        if filters.get('price_max') and filters['price_max']:
            try:
                max_price = int(filters['price_max'])
                # If value is small, assume it's in millions
                if max_price < 1000:
                    max_price = max_price * 1000000
                if prop['price'] > max_price:
                    continue
            except (ValueError, TypeError):
                pass
        
        # District filter
        if filters.get('district') and prop['district'] != filters['district']:
            continue
        
        # Developer filter
        if filters.get('developer') and prop['developer'] != filters['developer']:
            continue
        
        # Residential complex filter
        if filters.get('residential_complex'):
            residential_complex = filters['residential_complex'].lower()
            prop_complex = prop.get('complex_name', '').lower()
            if residential_complex not in prop_complex:
                continue
        
        # Street filter
        if filters.get('street'):
            street = filters['street'].lower()
            prop_location = prop.get('location', '').lower()
            prop_address = prop.get('full_address', '').lower()
            if street not in prop_location and street not in prop_address:
                continue
        
        # Mortgage filter
        if filters.get('mortgage') and not prop.get('mortgage_available', False):
            continue
        
        filtered.append(prop)
    
    return filtered

def build_property_filters(request_args):
    """
    Unified property filtering function for /properties and /map routes.
    
    Args:
        request_args: Flask request.args object
        
    Returns:
        tuple: (where_conditions, params, filters_dict)
            - where_conditions: list of SQL WHERE clause strings
            - params: dict of parameterized values for SQL query
            - filters_dict: dict of parsed filter values for template/debugging
    """
    from datetime import datetime
    
    # Parse all filter parameters (—É–Ω–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è)
    filters = {}
    
    # Price filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤: price_min, priceFrom, price_from)
    filters['price_min'] = request_args.get('price_min', request_args.get('priceFrom', request_args.get('price_from', '')))
    filters['price_max'] = request_args.get('price_max', request_args.get('priceTo', request_args.get('price_to', '')))
    
    # Area filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
    filters['area_min'] = request_args.get('area_min', request_args.get('areaFrom', request_args.get('area_from', '')))
    filters['area_max'] = request_args.get('area_max', request_args.get('areaTo', request_args.get('area_to', '')))
    
    # Floor filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
    filters['floor_min'] = request_args.get('floor_min', request_args.get('floorFrom', request_args.get('floor_from', '')))
    filters['floor_max'] = request_args.get('floor_max', request_args.get('floorTo', request_args.get('floor_to', '')))
    
    # Rooms filter (–º–æ–∂–µ—Ç –ø—Ä–∏–π—Ç–∏ –∫–∞–∫ "1,2,3" –∏–ª–∏ –∫–∞–∫ —Å–ø–∏—Å–æ–∫)
    rooms_param = request_args.get('rooms', '')
    if rooms_param:
        filters['rooms'] = rooms_param.split(',') if ',' in rooms_param else [rooms_param]
    else:
        filters['rooms'] = request_args.getlist('rooms') or []
    
    # Multi-select filters
    filters['districts'] = request_args.getlist('districts') or []
    filters['developers'] = request_args.getlist('developers') or []
    filters['completion'] = request_args.getlist('completion') or []
    filters['building_types'] = request_args.getlist('building_types') or []
    filters['delivery_years'] = request_args.getlist('delivery_years') or []
    filters['features'] = request_args.getlist('features') or []
    filters['object_classes'] = request_args.getlist('object_classes') or request_args.getlist('object_class') or []
    filters['renovation'] = request_args.getlist('renovation') or []
    filters['building_released'] = request_args.getlist('building_released') or []
    filters['floor_options'] = request_args.getlist('floor_options') or []  # not_first, not_last
    
    # Boolean filters
    filters['cashback_only'] = request_args.get('cashback_only', '').lower() in ['true', '1', 'yes']
    
    # Single value filters
    filters['developer'] = request_args.get('developer', '')
    filters['district'] = request_args.get('district', '')
    filters['residential_complex'] = request_args.get('residential_complex', '')
    filters['building'] = request_args.get('building', '')
    
    # Building floors filters
    filters['building_floors_min'] = request_args.get('building_floors_min', request_args.get('maxFloorFrom', ''))
    filters['building_floors_max'] = request_args.get('building_floors_max', request_args.get('maxFloorTo', ''))
    
    # Build year filters
    filters['build_year_min'] = request_args.get('build_year_min', request_args.get('buildYearFrom', ''))
    filters['build_year_max'] = request_args.get('build_year_max', request_args.get('buildYearTo', ''))
    
    # Regional filters
    filters['regions'] = request_args.getlist('regions') or []
    filters['cities'] = request_args.getlist('cities') or []
    filters['region'] = request_args.get('region', '')
    filters['city'] = request_args.get('city', '')
    
    # Search query
    filters['search'] = request_args.get('search', '')
    
    # Build SQL WHERE conditions and parameters
    where_conditions = []
    params = {}
    
    # Price filters (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç –≤ –º–∏–ª–ª–∏–æ–Ω–∞—Ö)
    if filters.get('price_min'):
        try:
            params['price_min'] = float(filters['price_min']) * 1000000
            where_conditions.append('price >= :price_min')
        except:
            pass
    
    if filters.get('price_max'):
        try:
            params['price_max'] = float(filters['price_max']) * 1000000
            where_conditions.append('price <= :price_max')
        except:
            pass
    
    # Area filters
    if filters.get('area_min'):
        try:
            params['area_min'] = float(filters['area_min'])
            where_conditions.append('object_area >= :area_min')
        except:
            pass
    
    if filters.get('area_max'):
        try:
            params['area_max'] = float(filters['area_max'])
            where_conditions.append('object_area <= :area_max')
        except:
            pass
    
    # Floor filters
    if filters.get('floor_min'):
        try:
            params['floor_min'] = int(filters['floor_min'])
            where_conditions.append('object_min_floor >= :floor_min')
        except:
            pass
    
    if filters.get('floor_max'):
        try:
            params['floor_max'] = int(filters['floor_max'])
            where_conditions.append('object_min_floor <= :floor_max')
        except:
            pass
    
    # Floor options (–Ω–µ –ø–µ—Ä–≤—ã–π/–Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç—Ç–∞–∂)
    if filters.get('floor_options'):
        floor_option_conditions = []
        for option in filters['floor_options']:
            if option == 'not_first':
                floor_option_conditions.append('object_min_floor > 1')
            elif option == 'not_last':
                # –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ: –∫–≤–∞—Ä—Ç–∏—Ä–∞ –Ω–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º —ç—Ç–∞–∂–µ, –µ—Å–ª–∏ —ç—Ç–∞–∂ ‚â§ 15
                # –†–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –¥–æ–º–æ–≤ (–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± —ç—Ç–∞–∂–Ω–æ—Å—Ç–∏ –∑–¥–∞–Ω–∏—è)
                floor_option_conditions.append('object_min_floor <= 15')
        
        if floor_option_conditions:
            where_conditions.append(f"({' AND '.join(floor_option_conditions)})")
    
    # Cashback only filter (—Ç–æ–ª—å–∫–æ –æ–±—ä–µ–∫—Ç—ã —Å –∫–µ—à–±–µ–∫–æ–º)
    if filters.get('cashback_only'):
        where_conditions.append('(min_rate > 0 AND min_rate IS NOT NULL)')
    
    # Rooms filter - support various formats
    if filters.get('rooms'):
        room_conditions = []
        for room_filter in filters['rooms']:
            if isinstance(room_filter, str):
                normalized = room_filter.lower().strip()
                if normalized in ['—Å—Ç—É–¥–∏—è', '0', 'studio']:
                    room_conditions.append('object_rooms = 0')
                elif normalized.endswith('-–∫–æ–º–Ω'):
                    try:
                        room_num = int(normalized.split('-')[0])
                        room_conditions.append(f'object_rooms = {room_num}')
                    except:
                        pass
                elif normalized in ['4+', '4+-–∫–æ–º–Ω']:
                    room_conditions.append('object_rooms >= 4')
                elif normalized.isdigit():
                    room_conditions.append(f'object_rooms = {int(normalized)}')
        
        if room_conditions:
            where_conditions.append(f"({' OR '.join(room_conditions)})")
    
    # Building types filter (—ç—Ç–∞–∂–Ω–æ—Å—Ç—å –¥–æ–º–∞)
    if filters.get('building_types'):
        building_conditions = []
        for building_type in filters['building_types']:
            if building_type == '–º–∞–ª–æ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('object_max_floor <= 5')
            elif building_type == '—Å—Ä–µ–¥–Ω–µ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('(object_max_floor >= 6 AND object_max_floor <= 12)')
            elif building_type == '–º–Ω–æ–≥–æ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('object_max_floor >= 13')
        
        if building_conditions:
            where_conditions.append(f"({' OR '.join(building_conditions)})")
    
    # Districts filter (array)
    if filters.get('districts'):
        district_conditions = []
        for idx, district in enumerate(filters['districts']):
            param_name = f'district_{idx}'
            params[param_name] = f'%{district.lower()}%'
            district_conditions.append(f'LOWER(address_locality_name) LIKE :{param_name}')
        
        if district_conditions:
            where_conditions.append(f"({' OR '.join(district_conditions)})")
    
    # Single district filter
    if filters.get('district'):
        params['district'] = f'%{filters["district"].lower()}%'
        where_conditions.append('LOWER(address_locality_name) LIKE :district')
    
    # Developers filter (array)
    if filters.get('developers'):
        developer_conditions = []
        for idx, developer in enumerate(filters['developers']):
            param_name = f'developer_{idx}'
            params[param_name] = f'%{developer.lower()}%'
            developer_conditions.append(f'LOWER(developer_name) LIKE :{param_name}')
        
        if developer_conditions:
            where_conditions.append(f"({' OR '.join(developer_conditions)})")
    
    # Single developer filter
    if filters.get('developer'):
        params['developer'] = f'%{filters["developer"].lower()}%'
        where_conditions.append('LOWER(developer_name) LIKE :developer')
    
    # Residential complex filter
    if filters.get('residential_complex'):
        params['complex'] = f'%{filters["residential_complex"].lower()}%'
        where_conditions.append('LOWER(complex_name) LIKE :complex')
    
    # Building filter
    if filters.get('building'):
        params['building'] = f'%{filters["building"].lower()}%'
        where_conditions.append('LOWER(complex_building_name) LIKE :building')
    
    # Completion year filters
    if filters.get('completion') or filters.get('delivery_years'):
        years = filters.get('completion') or filters.get('delivery_years')
        year_conditions = []
        for year in years:
            if year != '–°–¥–∞–Ω':
                year_conditions.append(f'complex_building_end_build_year = {year}')
        
        if year_conditions:
            where_conditions.append(f"({' OR '.join(year_conditions)})")
    
    # Object classes filter
    if filters.get('object_classes'):
        class_conditions = []
        for idx, obj_class in enumerate(filters['object_classes']):
            param_name = f'class_{idx}'
            params[param_name] = f'%{obj_class.lower()}%'
            class_conditions.append(f'LOWER(complex_object_class_display_name) LIKE :{param_name}')
        
        if class_conditions:
            where_conditions.append(f"({' OR '.join(class_conditions)})")
    
    # Renovation filter
    if filters.get('renovation'):
        renovation_conditions = []
        for idx, renovation in enumerate(filters['renovation']):
            param_name = f'renovation_{idx}'
            params[param_name] = f'%{renovation.lower()}%'
            renovation_conditions.append(f'LOWER(renovation_display_name) LIKE :{param_name}')
        
        if renovation_conditions:
            where_conditions.append(f"({' OR '.join(renovation_conditions)})")
    
    # Features filter
    if filters.get('features'):
        feature_conditions = []
        for idx, feature in enumerate(filters['features']):
            param_name = f'feature_{idx}'
            params[param_name] = f'%{feature.lower()}%'
            feature_conditions.append(f'LOWER(description) LIKE :{param_name}')
        
        if feature_conditions:
            where_conditions.append(f"({' OR '.join(feature_conditions)})")
    
    # Building released filter (—Å–¥–∞–Ω/–Ω–µ —Å–¥–∞–Ω)
    if filters.get('building_released'):
        released_conditions = []
        now = datetime.now()
        current_year = now.year
        current_quarter = (now.month - 1) // 3 + 1
        
        for status in filters['building_released']:
            if status.lower() in ['—Å–¥–∞–Ω', 'delivered', 'ready']:
                released_conditions.append(f'''(
                    complex_end_build_year < {current_year} OR 
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter < {current_quarter})) OR
                    complex_building_end_build_year < {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter < {current_quarter}))
                )''')
            elif status.lower() in ['—Å—Ç—Ä–æ–∏—Ç—Å—è', 'under_construction', 'building']:
                released_conditions.append(f'''(
                    complex_end_build_year > {current_year} OR
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter >= {current_quarter})) OR
                    complex_building_end_build_year > {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter >= {current_quarter}))
                )''')
        
        if released_conditions:
            where_conditions.append(f"({' OR '.join(released_conditions)})")
    
    # Building floors filters
    if filters.get('building_floors_min'):
        try:
            params['building_floors_min'] = int(filters['building_floors_min'])
            where_conditions.append('object_max_floor >= :building_floors_min')
        except:
            pass
    
    if filters.get('building_floors_max'):
        try:
            params['building_floors_max'] = int(filters['building_floors_max'])
            where_conditions.append('object_max_floor <= :building_floors_max')
        except:
            pass
    
    # Build year filters
    if filters.get('build_year_min'):
        try:
            params['build_year_min'] = int(filters['build_year_min'])
            where_conditions.append('(complex_end_build_year >= :build_year_min OR complex_building_end_build_year >= :build_year_min)')
        except:
            pass
    
    if filters.get('build_year_max'):
        try:
            params['build_year_max'] = int(filters['build_year_max'])
            where_conditions.append('(complex_end_build_year <= :build_year_max OR complex_building_end_build_year <= :build_year_max)')
        except:
            pass
    
    # Regional filters
    regional_conditions = []
    
    if filters.get('regions'):
        for idx, region in enumerate(filters['regions']):
            param_name = f'region_{idx}'
            params[param_name] = f'%{region.lower()}%'
            regional_conditions.append(f'LOWER(address_display_name) LIKE :{param_name}')
    
    if filters.get('region'):
        params['region'] = f'%{filters["region"].lower()}%'
        regional_conditions.append('LOWER(address_display_name) LIKE :region')
    
    if filters.get('cities'):
        for idx, city in enumerate(filters['cities']):
            param_name = f'city_{idx}'
            params[param_name] = f'%{city.lower()}%'
            regional_conditions.append(f'LOWER(address_display_name) LIKE :{param_name}')
    
    if filters.get('city'):
        params['city'] = f'%{filters["city"].lower()}%'
        regional_conditions.append('LOWER(address_display_name) LIKE :city')
    
    if regional_conditions:
        where_conditions.append(f"({' OR '.join(regional_conditions)})")
    
    # Search filter (multiple fields)
    if filters.get('search'):
        params['search'] = f'%{filters["search"].lower()}%'
        where_conditions.append('''(
            LOWER(address_display_name) LIKE :search OR
            LOWER(developer_name) LIKE :search OR
            LOWER(complex_name) LIKE :search OR
            LOWER(address_locality_name) LIKE :search OR
            LOWER(complex_building_name) LIKE :search
        )''')
    
    return where_conditions, params, filters

def get_developers_list():
    """Get list of unique developers"""
    properties = load_properties()
    developers = set()
    for prop in properties:
        if 'developer' in prop and prop['developer']:
            developers.add(prop['developer'])
    return sorted(list(developers))

def get_districts_list():
    """Get list of unique districts"""
    properties = load_properties()
    districts = set()
    for prop in properties:
        districts.add(prop['district'])
    return sorted(list(districts))

def sort_properties(properties, sort_type):
    """Sort properties by specified criteria with None safety"""
    if sort_type == 'price_asc':
        return sorted(properties, key=lambda x: x.get('price') or 0)
    elif sort_type == 'price_desc':
        return sorted(properties, key=lambda x: x.get('price') or 0, reverse=True)
    elif sort_type == 'cashback_desc':
        return sorted(properties, key=lambda x: calculate_cashback(x.get('price') or 0), reverse=True)
    elif sort_type == 'area_asc':
        return sorted(properties, key=lambda x: x.get('area') or 0)
    elif sort_type == 'area_desc':
        return sorted(properties, key=lambda x: x.get('area') or 0, reverse=True)
    else:
        return properties

def get_similar_properties(property_id, district, limit=3):
    """Get similar properties in the same district"""
    properties = load_properties()
    similar = []
    
    for prop in properties:
        if str(prop['id']) != str(property_id) and prop['district'] == district:
            similar.append(prop)
            if len(similar) >= limit:
                break
    
    return similar

# Routes
@app.route('/')
def index():
    """Home page with featured content"""
    properties = load_properties()
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (–∫–∞–∫ –≤ —Ä–æ—É—Ç–µ /residential-complexes)
    exclusive_complexes = []
    try:
        from sqlalchemy import text
        complexes_query = db.session.execute(text("""
            SELECT 
                ep.complex_name,
                COUNT(*) as apartments_count,
                MIN(ep.price) as price_from,
                MAX(ep.price) as price_to,
                MIN(ep.object_area) as area_from,
                MAX(ep.object_area) as area_to,
                MIN(ep.object_min_floor) as floors_min,
                MAX(ep.object_max_floor) as floors_max,
                MAX(ep.developer_name) as developer_name,
                MAX(ep.address_display_name) as address_display_name,
                MAX(ep.complex_sales_address) as complex_sales_address,
                MAX(ep.complex_building_end_build_year) as end_build_year,
                MAX(ep.complex_building_end_build_quarter) as end_build_quarter,
                (SELECT photos FROM excel_properties p2 
                 WHERE p2.complex_name = ep.complex_name 
                 AND p2.photos IS NOT NULL 
                 ORDER BY p2.price DESC LIMIT 1) as photos,
                COALESCE(rc.id, ROW_NUMBER() OVER (ORDER BY ep.complex_name) + 1000) as real_id,
                CASE 
                    WHEN COUNT(DISTINCT ep.complex_building_id) > 0 
                    THEN COUNT(DISTINCT ep.complex_building_id)
                    WHEN COUNT(DISTINCT NULLIF(ep.complex_building_name, '')) > 0 
                    THEN COUNT(DISTINCT NULLIF(ep.complex_building_name, ''))
                    ELSE GREATEST(1, CEIL(COUNT(*) / 3.0))
                END as buildings_count,
                MAX(ep.complex_object_class_display_name) as object_class_display_name,
                rc.max_cashback_amount,
                d.max_cashback_percent
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
            LEFT JOIN developers d ON d.name = ep.developer_name
            WHERE ep.complex_name IS NOT NULL AND ep.complex_name != ''
            GROUP BY ep.complex_name, rc.id, rc.max_cashback_amount, d.max_cashback_percent
            ORDER BY 
                -- –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ª—É—á—à–∏–µ –ñ–ö (—Å–¥–∞–Ω–Ω—ã–µ –∏ –≥–æ—Ç–æ–≤—ã–µ –∫ –ø–æ–∫—É–ø–∫–µ)
                CASE 
                    WHEN MAX(ep.complex_building_end_build_year) = 2025 
                    AND MAX(ep.complex_building_end_build_quarter) = 4 
                    THEN 1  -- "IV –∫–≤. 2025 –≥. –°—Ç—Ä–æ–∏—Ç—Å—è" –≤ –∫–æ–Ω—Ü–µ (–Ω–µ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ)
                    ELSE 0  -- –ì–æ—Ç–æ–≤—ã–µ –∏ –±–ª–∏–∂–∞–π—à–∏–µ –∫ —Å–¥–∞—á–µ –ñ–ö —Å–Ω–∞—á–∞–ª–∞
                END,
                MIN(ep.price) ASC  -- –°–Ω–∞—á–∞–ª–∞ –±–æ–ª–µ–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ —Ü–µ–Ω–µ
            LIMIT 6
        """))
        
        complexes_data = complexes_query.fetchall()
        
        for row in complexes_data:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ
            main_photo = '/static/images/no-photo.jpg'
            photos_list = [main_photo]
            
            if row[13]:  # photos column
                try:
                    photos_raw = json.loads(row[13])
                    if photos_raw and isinstance(photos_raw, list):
                        photos_list = photos_raw[:2]  # –ü–µ—Ä–≤—ã–µ 2 —Ñ–æ—Ç–æ –¥–ª—è –∫–∞—Ä—Ç–æ—á–∫–∏
                        main_photo = photos_list[0] if photos_list else main_photo
                except:
                    pass
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏ —Ç–∏–ø–∞ –∫–æ–º–Ω–∞—Ç
            current_year = 2025
            current_quarter = 4
            
            is_completed = False
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            if row[11] and row[12]:  # end_build_year –∏ end_build_quarter
                build_year = int(row[11])
                build_quarter = int(row[12])
                
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} –∫–≤. {build_year} –≥."
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–º–Ω–∞—Ç
            room_types = []
            if row[5] and row[6]:  # area_from –∏ area_to
                if row[5] < 35:
                    room_types.append("–°—Ç—É–¥–∏–∏")
                if row[5] <= 45 and row[6] >= 35:
                    room_types.append("1–ö")
                if row[6] >= 55:
                    room_types.append("2-3–ö")
            else:
                room_types = ["–°—Ç—É–¥–∏–∏", "1-3–ö"]
            
            room_type_display = " - ".join(room_types) if room_types else "–†–∞–∑–ª–∏—á–Ω—ã–µ"
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
            safe_images = photos_list if photos_list and len(photos_list) > 0 else ['/static/images/no-photo.jpg']
            safe_main_image = safe_images[0] if safe_images else '/static/images/no-photo.jpg'
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–¥—Ä–µ—Å - —É–±–∏—Ä–∞–µ–º "–°–æ—á–∏" –∏–∑ –Ω–∞—á–∞–ª–∞
            clean_address = row[9] or ''
            if clean_address.startswith('–°–æ—á–∏, '):
                clean_address = clean_address[6:]  # –£–±–∏—Ä–∞–µ–º "–°–æ—á–∏, "
            elif clean_address.startswith('–≥. –°–æ—á–∏, '):
                clean_address = clean_address[9:]  # –£–±–∏—Ä–∞–µ–º "–≥. –°–æ—á–∏, "
            
            # –†–µ–∞–ª—å–Ω—ã–π –∫–µ—à–±–µ–∫ –∏–∑ –∞–¥–º–∏–Ω–∫–∏
            cashback_amount = row[17] if row[17] else None  # max_cashback_amount –∏–∑ residential_complexes
            cashback_percent = row[18] if row[18] else None  # max_cashback_percent –∏–∑ developers
            
            # –ï—Å–ª–∏ –∫–µ—à–±–µ–∫ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω–∫–µ, –≤—ã—á–∏—Å–ª—è–µ–º –∫–∞–∫ 5% –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ü–µ–Ω—ã
            if not cashback_amount and row[3]:
                cashback_amount = int(row[3] * 0.05)
                cashback_percent = 5.0  # –ü—Ä–æ—Ü–µ–Ω—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—É–º–º–µ
            elif not cashback_percent:
                cashback_percent = 10.0  # –ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –µ—Å—Ç—å —Å—É–º–º–∞ –Ω–æ –Ω–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞
            
            complex_dict = {
                'id': row[14] or 1,  # real_id
                'name': row[0] or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                'price_from': int(row[2] or 0),
                'price_to': int(row[3] or 0),
                'area_from': int(row[4] or 0),
                'area_to': int(row[5] or 0),
                'room_type': room_type_display,
                'address': clean_address,
                'developer': row[8] or '–ù–µ —É–∫–∞–∑–∞–Ω',
                'photos': safe_images,
                'images': safe_images,  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —à–∞–±–ª–æ–Ω–æ–º
                'image': safe_main_image,    # –û—Å–Ω–æ–≤–Ω–æ–µ —Ñ–æ—Ç–æ  
                'main_photo': safe_main_image,
                'main_image': safe_main_image,  # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≥–ª–∞–≤–Ω–æ–µ —Ñ–æ—Ç–æ
                'apartments_count': row[1] or 0,
                'completion_date': completion_date,
                'is_completed': is_completed,
                'cashback_amount': int(cashback_amount) if cashback_amount else 0,  # –†–µ–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –∏–∑ –∞–¥–º–∏–Ω–∫–∏
                'cashback_percent': float(cashback_percent),  # –ü—Ä–æ—Ü–µ–Ω—Ç –∏–∑ –∞–¥–º–∏–Ω–∫–∏
                'cashback_max': int(cashback_amount) if cashback_amount else 0,  # –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                'buildings_count': int(row[16]) if row[16] and str(row[16]).isdigit() else 1
            }
            exclusive_complexes.append(complex_dict)
            
    except Exception as e:
        print(f"Error loading exclusive complexes: {e}")
        import traceback
        traceback.print_exc()
        exclusive_complexes = []
    
    complexes = load_residential_complexes()  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
    developers_file = os.path.join('data', 'developers.json')
    with open(developers_file, 'r', encoding='utf-8') as f:
        developers = json.load(f)
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç–∞—Ç—å–∏ –±–ª–æ–≥–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    blog_articles = []
    try:
        from models import BlogPost
        from sqlalchemy import desc
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ç—å–∏ —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
        blog_posts = BlogPost.query.filter_by(status='published').filter(BlogPost.category_id.isnot(None)).order_by(desc(BlogPost.published_at)).limit(4).all()
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –µ–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —à–∞–±–ª–æ–Ω–∞
        for post in blog_posts:
            blog_articles.append({
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —Å—Ç–∞—Ç—å—è –æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category': post.category or '–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å',
                'url': f'/blog/{post.slug}'
            })
        
    except Exception as e:
        print(f"Error loading blog articles for index: {e}")
        # Fallback —Å—Ç–∞—Ç—å–∏ –µ—Å–ª–∏ –±–∞–∑–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞
        blog_articles = [
            {
                'title': '–ò–ø–æ—Ç–µ–∫–∞ –º—É—Ä–∞–±–∞—Ö–∞: —á—Ç–æ —ç—Ç–æ –∏ –∫–∞–∫ –æ—Ñ–æ—Ä–º–∏—Ç—å',
                'slug': 'ipoteka-murabaha',
                'excerpt': '–ò–ø–æ—Ç–µ–∫–∞ –º—É—Ä–∞–±–∞—Ö–∞ ‚Äî —ç—Ç–æ –∏—Å–ª–∞–º—Å–∫–∞—è –∏–ø–æ—Ç–µ–∫–∞ –±–µ–∑ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤, –≥–¥–µ –±–∞–Ω–∫ –ø–æ–∫—É–ø–∞–µ—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å –∏ –ø—Ä–æ–¥–∞–µ—Ç –µ–µ –∫–ª–∏–µ–Ω—Ç—É —Å –Ω–∞—Ü–µ–Ω–∫–æ–π.',
                'featured_image': 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': datetime.now(),
                'reading_time': 5,
                'category': '–ò–ø–æ—Ç–µ–∫–∞',
                'url': '/blog/ipoteka-murabaha'
            }
        ]
    
    # ‚úÖ –†–ï–ê–õ–¨–ù–´–ï –î–ê–ù–ù–´–ï: –ü–æ–ª—É—á–∞–µ–º 6 —Å–ª—É—á–∞–π–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞–ø—Ä—è–º—É—é –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ API
    try:
        import random
        from models import ExcelProperty
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –±–∞–∑—ã —Å–æ –í–°–ï–ú–ò –Ω—É–∂–Ω—ã–º–∏ –ø–æ–ª—è–º–∏
        from sqlalchemy import text
        result = db.session.execute(text("""
            SELECT inner_id, price, object_area, object_rooms, 
                   object_min_floor, object_max_floor,
                   address_display_name, complex_name, developer_name, photos,
                   complex_end_build_quarter, complex_end_build_year,
                   complex_building_end_build_quarter, complex_building_end_build_year
            FROM excel_properties
            WHERE price > 0 AND photos IS NOT NULL AND photos != '' AND photos != '[]'
                AND address_position_lat IS NOT NULL 
                AND address_position_lon IS NOT NULL
                AND object_area > 0
                AND complex_name IS NOT NULL AND complex_name != ''
            ORDER BY RANDOM()
            LIMIT 8
        """))
        
        featured_properties = []
        for row in result:
            try:
                # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ
                main_image = 'https://via.placeholder.com/400x300?text=–§–æ—Ç–æ+—Å–∫–æ—Ä–æ'
                gallery = [main_image]
                
                if row.photos:
                    try:
                        photos_raw = json.loads(row.photos)
                        if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                            main_image = photos_raw[0]
                            gallery = photos_raw[:5]
                    except:
                        pass
                
                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –ø–æ–ª–µ–π
                rooms = int(row.object_rooms or 0)
                area = float(row.object_area or 0)
                price = int(row.price or 0)
                
                # –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —ç—Ç–∞–∂–∏
                floor_min = int(row.object_min_floor or 1)
                floor_max = int(row.object_max_floor or floor_min)
                floor_text = f"{floor_min}/{floor_max} —ç—Ç." if floor_min == floor_max else f"{floor_min}-{floor_max}/{floor_max} —ç—Ç."
                
                # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–∏–ø–∞ –∫–≤–∞—Ä—Ç–∏—Ä—ã
                if rooms == 0:
                    room_type = "–°—Ç—É–¥–∏—è"
                else:
                    room_type = f"{rooms}-–∫–æ–º–Ω"
                
                # –°—Ç–∞—Ç—É—Å –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∏ –∫–≤–∞—Ä—Ç–∞–ª —Å–¥–∞—á–∏
                current_year = 2025
                build_quarter = row.complex_end_build_quarter or row.complex_building_end_build_quarter
                build_year = row.complex_end_build_year or row.complex_building_end_build_year
                
                if build_year and build_quarter:
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–≤–∞—Ä—Ç–∞–ª–∞
                    if build_quarter == 1:
                        quarter_text = f"1–∫–≤. {build_year}–≥."
                    elif build_quarter == 2:
                        quarter_text = f"2–∫–≤. {build_year}–≥."
                    elif build_quarter == 3:
                        quarter_text = f"3–∫–≤. {build_year}–≥."
                    elif build_quarter == 4:
                        quarter_text = f"4–∫–≤. {build_year}–≥."
                    else:
                        quarter_text = f"{build_quarter}–∫–≤. {build_year}–≥."
                    
                    # –°—Ç–∞—Ç—É—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –≥–æ–¥–∞ –∏ –∫–≤–∞—Ä—Ç–∞–ª–∞
                    if build_year < current_year or (build_year == current_year and build_quarter <= 1):
                        status_text = "–°–¥–∞–Ω"
                    else:
                        status_text = "–°—Ç—Ä–æ–∏—Ç—Å—è"
                else:
                    quarter_text = "–£—Ç–æ—á–Ω—è–µ—Ç—Å—è"
                    status_text = "–°—Ç—Ä–æ–∏—Ç—Å—è"
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
                prop = {
                    'id': str(row.inner_id),
                    'price': price,
                    'area': area,
                    'rooms': rooms,
                    'title': f"{room_type}, {area} –º¬≤, {floor_text}",
                    'complex': row.complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'developer': row.developer_name or '',
                    'address': row.address_display_name or '',
                    'image': main_image,
                    'gallery': gallery,
                    'cashback': int(price * 0.02),
                    'cashback_amount': int(price * 0.02),
                    'completion_date': quarter_text,
                    'status': status_text,
                    'floor_info': floor_text
                }
                featured_properties.append(prop)
                if len(featured_properties) >= 6:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 6 –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                    break
                
            except Exception as e:
                print(f"Error processing property {row.inner_id}: {e}")
                continue
        
        if featured_properties:
            print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(featured_properties)} —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –±–∞–∑—ã")
        else:
            raise Exception("No properties loaded")
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤: {e}")
        # Fallback –∫ —Å—Ç–∞—Ä—ã–º –¥–∞–Ω–Ω—ã–º
        featured_properties = sorted(properties, key=lambda x: x.get('cashback_amount', 0), reverse=True)[:6]
        for prop in featured_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
    
    # Get districts with statistics
    districts_data = {}
    for complex in complexes:
        district = complex['district']
        if district not in districts_data:
            districts_data[district] = {
                'name': district,
                'complexes_count': 0,
                'price_from': float('inf'),
                'apartments_count': 0
            }
        districts_data[district]['complexes_count'] += 1
        complex_price = complex.get('price_from') or 0
        if complex_price > 0:  # Only update if we have a valid price
            districts_data[district]['price_from'] = min(districts_data[district]['price_from'], complex_price)
        districts_data[district]['apartments_count'] += complex.get('apartments_count', 0) or 0
    
    districts = sorted(districts_data.values(), key=lambda x: x['complexes_count'], reverse=True)[:8]
    
    # Get featured developers (top 3 with most complexes)
    featured_developers = []
    for developer in developers[:3]:
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer['id']]
        developer_properties = [p for p in properties if any(c['id'] == p.get('complex_id') for c in developer_complexes)]
        
        developer_info = {
            'id': developer['id'],
            'name': developer['name'],
            'complexes_count': len(developer_complexes),
            'apartments_count': len(developer_properties),
            'price_from': min([p['price'] for p in developer_properties]) if developer_properties else 0,
            'max_cashback': max([c.get('cashback_percent', 5) for c in developer_complexes]) if developer_complexes else 5
        }
        featured_developers.append(developer_info)
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –±–ª–æ–≥–∞ –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    blog_categories = []
    try:
        from models import Category
        blog_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
    except Exception as e:
        print(f"Error loading blog categories for index: {e}")
    
    return render_template('index.html',
                         featured_properties=featured_properties,
                         districts=districts,
                         featured_developers=featured_developers,
                         residential_complexes=complexes[:3],
                         exclusive_complexes=exclusive_complexes,
                         blog_articles=blog_articles,
                         blog_categories=blog_categories)

@app.route('/properties')
def properties():
    """OPTIMIZED Properties listing page - SQL-level filtering, sorting, and pagination"""
    try:
        from models import ExcelProperty, Developer, ResidentialComplex
        from sqlalchemy import text
        
        # ‚úÖ USE UNIFIED FILTER FUNCTION
        where_conditions, params, filters = build_property_filters(request.args)
        
        # ‚úÖ –ü–ê–ì–ò–ù–ê–¶–ò–Ø: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)  # Ensure page >= 1
        per_page = 20
        offset = (page - 1) * per_page
        
        # ‚úÖ –°–û–†–¢–ò–†–û–í–ö–ê (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤: –¥–µ—Ñ–∏—Å –∏ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏–µ)
        sort_type = request.args.get('sort', 'price-asc').replace('_', '-')
        sort_clause = 'price ASC'
        if sort_type == 'price-desc':
            sort_clause = 'price DESC'
        elif sort_type == 'price-asc':
            sort_clause = 'price ASC'
        elif sort_type == 'area-asc':
            sort_clause = 'object_area ASC'
        elif sort_type == 'area-desc':
            sort_clause = 'object_area DESC'
        elif sort_type == 'date-desc':
            sort_clause = 'complex_building_end_build_year DESC, complex_building_end_build_quarter DESC'
        
        # Build complete WHERE clause
        where_clause = ' AND '.join(where_conditions) if where_conditions else '1=1'
        
        # ‚úÖ COUNT QUERY for total
        count_query = f"""
            SELECT COUNT(*)
            FROM excel_properties
            WHERE {where_clause}
        """
        
        total_result = db.session.execute(text(count_query), params)
        total_properties = total_result.scalar() or 0
        
        # ‚úÖ MAIN QUERY with filters, sorting, and pagination
        main_query = f"""
            SELECT inner_id, price, object_area, object_rooms, object_min_floor, object_max_floor,
                   address_display_name, renovation_display_name, min_rate, square_price, 
                   mortgage_price, complex_object_class_display_name, photos,
                   developer_name, complex_name, complex_end_build_year, complex_end_build_quarter,
                   complex_building_end_build_year, complex_building_end_build_quarter,
                   address_position_lat, address_position_lon, description, address_locality_name,
                   complex_building_name, parsed_city, parsed_region, renovation_type,
                   placement_type, deal_type, complex_building_accreditation,
                   complex_building_has_green_mortgage, complex_has_green_mortgage
            FROM excel_properties
            WHERE {where_clause}
            ORDER BY {sort_clause}
            LIMIT {per_page} OFFSET {offset}
        """
        
        result = db.session.execute(text(main_query), params)
        excel_properties = result.fetchall()
        
        # Convert to template format
        properties_data = []
        
        for row in excel_properties:
            try:
                inner_id, price, area, rooms, min_floor, max_floor, address, renovation, complex_min_rate, square_price, mortgage_price, class_type, photos, developer_name, complex_name, complex_end_year, complex_end_quarter, building_end_year, building_end_quarter, lat, lon, description, district_name, building_name, parsed_city, parsed_region, renovation_type, placement_type, deal_type, building_accreditation, building_green_mortgage, complex_green_mortgage = row
                
                price = price or 0
                area = area or 0
                rooms = rooms or 0
                min_floor = min_floor or 1
                max_floor = max_floor or min_floor
                
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –∏–∑ PostgreSQL array format {url1,url2,url3}
                images = []
                if photos:
                    try:
                        if photos.startswith('{') and photos.endswith('}'):
                            photos_clean = photos[1:-1]
                            if photos_clean:
                                images = [url.strip() for url in photos_clean.split(',')]
                        else:
                            import json
                            photos_list = json.loads(photos)
                            images = photos_list if photos_list else []
                    except:
                        images = []
                
                # Create title with detailed floor info
                if rooms == 0:
                    title = f"–°—Ç—É–¥–∏—è {area} –º¬≤"
                elif rooms == 1:
                    title = f"1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞, {area} –º¬≤"
                elif rooms == 2:
                    title = f"2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞, {area} –º¬≤"
                elif rooms == 3:
                    title = f"3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞, {area} –º¬≤"
                else:
                    title = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞, {area} –º¬≤"
                
                if min_floor and max_floor:
                    title += f", {min_floor}/{max_floor} —ç—Ç."
                
                # Create completion date from available data
                completion_date = '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
                if building_end_year and building_end_quarter:
                    completion_date = f"{building_end_year} –≥., {building_end_quarter} –∫–≤."
                elif complex_end_year and complex_end_quarter:
                    completion_date = f"{complex_end_year} –≥., {complex_end_quarter} –∫–≤."
                elif building_end_year:
                    completion_date = f"{building_end_year} –≥."
                elif complex_end_year:
                    completion_date = f"{complex_end_year} –≥."
                
                prop_data = {
                    'id': inner_id,
                    'title': title,
                    'price': price,
                    'area': area,
                    'rooms': rooms,
                    'floor': min_floor,
                    'total_floors': max_floor,
                    'object_min_floor': min_floor,
                    'object_max_floor': max_floor,
                    'object_area': area,
                    'address': address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                    'developer': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'developer_name': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'complex_name': complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'district': district_name or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'address_locality_name': district_name or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'renovation_type': renovation or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                    'finish_type': renovation or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                    'completion_date': completion_date,
                    'mortgage_rate': f"{complex_min_rate}%" if complex_min_rate else '3.5%',
                    'square_price': square_price,
                    'mortgage_payment': mortgage_price,
                    'class_type': class_type or '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'complex_object_class_display_name': class_type or '',
                    'renovation_display_name': renovation or '',
                    'renovation_type': renovation_type or '',
                    'placement_type': placement_type or '',
                    'deal_type': deal_type or '',
                    'building_accreditation': building_accreditation or '',
                    'building_floors': max_floor or 0,
                    'has_green_mortgage': building_green_mortgage or complex_green_mortgage or False,
                    'green_mortgage': building_green_mortgage or complex_green_mortgage or False,
                    'features': [f for f in [
                        '–ó–µ–ª–µ–Ω–∞—è –∏–ø–æ—Ç–µ–∫–∞' if (building_green_mortgage or complex_green_mortgage) else None,
                        '–ê–∫–∫—Ä–µ–¥–∏—Ç–∞—Ü–∏—è' if building_accreditation else None,
                        '–ù–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∞' if deal_type and '–Ω–æ–≤–æ—Å—Ç—Ä–æ–π' in str(deal_type).lower() else None,
                        '–ë–µ–∑ –æ—Ç–¥–µ–ª–∫–∏' if renovation and '–±–µ–∑ –æ—Ç–¥–µ–ª–∫–∏' in str(renovation).lower() else None,
                        '–° –æ—Ç–¥–µ–ª–∫–æ–π' if renovation and ('—Å –æ—Ç–¥–µ–ª–∫–æ–π' in str(renovation).lower() or '—á–∏—Å—Ç–æ–≤–∞—è' in str(renovation).lower()) else None,
                    ] if f],
                    'cashback': calculate_cashback(price, complex_name=complex_name) if price else 0,
                    'images': images,
                    'gallery': images,
                    'image': images[0] if images else 'https://via.placeholder.com/400x300/f3f4f6/9ca3af?text=–§–æ—Ç–æ+–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ',
                    'address_position_lat': lat,
                    'address_position_lon': lon,
                    'description': description or '',
                    'parsed_city': parsed_city,
                    'parsed_region': parsed_region
                }
                properties_data.append(prop_data)
                
            except Exception as e:
                print(f"Error processing excel property {inner_id}: {e}")
        
        # ‚úÖ PAGINATION INFO
        total_pages = (total_properties + per_page - 1) // per_page
        properties_page = properties_data  # Already paginated by SQL
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù –¢–ï–ö–°–¢: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞ "–æ–±—ä–µ–∫—Ç"
        def get_object_word(count):
            if count % 100 in [11, 12, 13, 14]:
                return "–æ–±—ä–µ–∫—Ç–æ–≤"
            elif count % 10 == 1:
                return "–æ–±—ä–µ–∫—Ç"
            elif count % 10 in [2, 3, 4]:
                return "–æ–±—ä–µ–∫—Ç–∞"
            else:
                return "–æ–±—ä–µ–∫—Ç–æ–≤"
        
        results_text = f"–ù–∞–π–¥–µ–Ω–æ {total_properties} " + get_object_word(total_properties)
        # Pagination applied
        
        # Pagination info
        pagination = {
            'page': page,
            'per_page': per_page,
            'total': total_properties,
            'total_pages': total_pages,
            'has_prev': page > 1,
            'has_next': page < total_pages,
            'prev_page': page - 1 if page > 1 else None,
            'next_page': page + 1 if page < total_pages else None
        }
        
        # Authentication
        user_authenticated = current_user.is_authenticated if hasattr(current_user, 'is_authenticated') else False
        manager_id = session.get('manager_id')
        manager_authenticated = bool(manager_id)
        
        # Auth status checked
        
        current_manager = None
        if manager_authenticated:
            from models import Manager
            current_manager = Manager.query.get(manager_id)
            # Manager found
        else:
            # No manager auth
            pass
        
        # Load data for filters
        developers = [d.name for d in Developer.query.all()]
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ñ–ö —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏ –∏–∑ Excel
        complexes_query = db.session.execute(text("""
            SELECT 
                complex_name,
                COUNT(*) as apartments_count,
                MIN(price) as price_from,
                MAX(price) as price_to,
                MAX(developer_name) as developer_name
            FROM excel_properties 
            GROUP BY complex_name
            ORDER BY complex_name
            LIMIT 11
        """))
        
        residential_complexes_with_photos = []
        for idx, row in enumerate(complexes_query.fetchall()):
            complex_dict = {
                'id': idx + 1,
                'name': row[0],
                'available_apartments': row[1],
                'price_from': row[2] or 0,
                'price_to': row[3] or 0,
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'developer': row[4] or '–ù–µ —É–∫–∞–∑–∞–Ω'
            }
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ –ñ–ö –∏–∑ —Å–∞–º–æ–π –¥–æ—Ä–æ–≥–æ–π –∫–≤–∞—Ä—Ç–∏—Ä—ã (–∫–∞–∫ —Ä–µ–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ç–∏–≤–Ω–æ–µ –¥–ª—è –ñ–ö)
            photos_query = db.session.execute(text("""
                SELECT photos FROM excel_properties 
                WHERE complex_name = :complex_name 
                AND photos IS NOT NULL 
                ORDER BY price DESC, object_area DESC
                LIMIT 1
            """), {'complex_name': complex_dict['name']})
            
            photos_row = photos_query.fetchone()
            if photos_row and photos_row[0]:
                try:
                    import json
                    photos_list = json.loads(photos_row[0])
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ —Ñ–æ—Ç–æ (–∏–Ω—Ç–µ—Ä—å–µ—Ä—ã –∫–≤–∞—Ä—Ç–∏—Ä) –∏ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö
                    start_index = min(len(photos_list) // 4, 5) if len(photos_list) > 8 else 1
                    complex_dict['image'] = photos_list[start_index] if len(photos_list) > start_index else photos_list[0]
                    # –î–ª—è —Å–ª–∞–π–¥–µ—Ä–∞ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ –∏–Ω—Ç–µ—Ä—å–µ—Ä—ã)
                    complex_dict['images'] = photos_list[start_index:] if len(photos_list) > start_index else photos_list
                except:
                    complex_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + complex_dict['name']
                    complex_dict['images'] = []
            else:
                complex_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + complex_dict['name']
                complex_dict['images'] = []
            
            residential_complexes_with_photos.append(complex_dict)
        
        # Complexes loaded with photos
        
        # Rendering template
        
        # Calculate total pages for JavaScript
        total_pages = (total_properties + per_page - 1) // per_page  # Ceiling division
        
        # Get manager info for current user (if logged in)
        manager_data = None
        if current_user.is_authenticated:
            user = User.query.get(current_user.id)
            if user and user.assigned_manager:
                manager = user.assigned_manager
                manager_data = {
                    'name': f"{manager.first_name} {manager.last_name}",
                    'phone': manager.phone,
                    'email': manager.email,
                    'photo': manager.profile_image if manager.profile_image and not 'randomuser.me' in manager.profile_image else None
                }
        
        return render_template('properties.html', 
                             properties=properties_page,  # –û–±—ä–µ–∫—Ç—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                             pagination=pagination,  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
                             filters=filters,
                             developers=developers,
                             districts=[],  # TODO: implement districts
                             residential_complexes=residential_complexes_with_photos,
                             results_text=results_text,  # ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ 
                             total_properties=total_properties,  # ‚úÖ –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö
                             total_pages=total_pages,  # Total pages for pagination
                             page=page,  # Current page number
                             current_sort=sort_type,  # –¢–µ–∫—É—â–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
                             user_authenticated=user_authenticated,
                             manager_authenticated=manager_authenticated,
                             current_manager=current_manager, manager=manager_data,
                             yandex_maps_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
                             
    except Exception as e:
        print(f"ERROR in properties route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

@app.route('/object/<int:property_id>')
def property_detail(property_id):
    """Individual property page - uses Excel property data"""
    try:
        # Get property from excel_properties table
        from sqlalchemy import text
        result = db.session.execute(text("""
            SELECT inner_id, price, object_area, object_rooms, object_min_floor, object_max_floor,
                   address_display_name, renovation_display_name, min_rate, square_price, 
                   mortgage_price, complex_object_class_display_name, photos,
                   developer_name, complex_name, complex_end_build_year, complex_end_build_quarter,
                   complex_building_end_build_year, complex_building_end_build_quarter,
                   address_position_lat, address_position_lon, description,
                   address_locality_name, address_short_display_name, 
                   complex_sales_address, complex_sales_phone, complex_with_renovation,
                   complex_has_accreditation, complex_has_green_mortgage, complex_has_mortgage_subsidy,
                   trade_in, deal_type, object_is_apartment, published_dt, placement_type,
                   complex_building_name, complex_building_released, complex_id
            FROM excel_properties 
            WHERE inner_id = :property_id
        """), {"property_id": property_id})
        
        row = result.fetchone()
        if not row:
            print(f"Excel property {property_id} not found")
            return redirect(url_for('properties'))
        
        # Parse row data - –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ –Ω–æ–≤—ã–µ –ø–æ–ª—è –≤–∫–ª—é—á–∞—è complex_id
        # ‚úÖ FIX: Ensure floor values are integers to prevent string/int comparison errors
        inner_id, price, area, rooms, min_floor, max_floor, address, renovation, complex_min_rate, square_price, mortgage_price, class_type, photos, developer_name, complex_name, complex_end_year, complex_end_quarter, building_end_year, building_end_quarter, lat, lon, description, locality_name, short_address, sales_address, sales_phone, with_renovation, has_accreditation, has_green_mortgage, has_mortgage_subsidy, trade_in, deal_type, is_apartment, published_dt, placement_type, building_name, building_released, complex_id = row
        
        # ‚úÖ FIX: Convert floor values to int to prevent comparison errors
        try:
            min_floor = int(min_floor) if min_floor else 1
        except (ValueError, TypeError):
            min_floor = 1
        
        try:
            max_floor = int(max_floor) if max_floor else min_floor
        except (ValueError, TypeError):
            max_floor = min_floor
        
        # Parse photos
        images = []
        if photos:
            try:
                if photos.startswith('{') and photos.endswith('}'):
                    photos_clean = photos[1:-1]
                    if photos_clean:
                        images = [url.strip() for url in photos_clean.split(',')]
                else:
                    import json
                    photos_list = json.loads(photos)
                    images = photos_list if photos_list else []
            except:
                images = []
        
        # Create completion date
        completion_date = '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
        if building_end_year and building_end_quarter:
            completion_date = f"{building_end_year} –≥., {building_end_quarter} –∫–≤."
        elif complex_end_year and complex_end_quarter:
            completion_date = f"{complex_end_year} –≥., {complex_end_quarter} –∫–≤."
        elif building_end_year:
            completion_date = f"{building_end_year} –≥."
        elif complex_end_year:
            completion_date = f"{complex_end_year} –≥."
        
        # Build property data for template - –≤—Å–µ –ø–æ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        property_data = {
            'id': inner_id,
            'complex_id': complex_id,  # –î–æ–±–∞–≤–ª—è–µ–º complex_id –¥–ª—è —Å—Å—ã–ª–æ–∫ –Ω–∞ –ñ–ö
            'price': price or 0,
            'area': area or 0,
            'rooms': rooms or 0,
            'floor': min_floor or 1,
            'total_floors': max_floor or min_floor or 1,
            'address': address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'short_address': short_address or address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'locality_name': locality_name or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
            'developer': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'complex_name': complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'building_name': building_name or '–ö–æ—Ä–ø—É—Å 1',
            'building_released': building_released,
            'renovation_type': renovation or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'completion_date': completion_date,
            'mortgage_rate': f"{complex_min_rate}%" if complex_min_rate else '3.5%',
            'square_price': square_price,
            'mortgage_payment': mortgage_price,
            'class_type': class_type or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'cashback': calculate_cashback(price, complex_name=complex_name) if price else 0,
            'images': images,
            'image': images[0] if images else 'https://via.placeholder.com/400x300/f3f4f6/9ca3af?text=–§–æ—Ç–æ+–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ',
            'address_position_lat': lat,
            'address_position_lon': lon,
            'description': description or f"–ü—Ä–æ–¥–∞–µ—Ç—Å—è –∫–≤–∞—Ä—Ç–∏—Ä–∞ –≤ {complex_name}. –û—Ç–ª–∏—á–Ω–∞—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∫–∞, –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –æ—Ç–¥–µ–ª–∫–∞.",
            'gallery': images,
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–∑ Excel –±–∞–∑—ã
            'sales_address': sales_address or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'sales_phone': sales_phone or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'with_renovation': with_renovation,
            'has_accreditation': has_accreditation,
            'has_green_mortgage': has_green_mortgage,
            'has_mortgage_subsidy': has_mortgage_subsidy,
            'trade_in_available': trade_in,
            'deal_type': deal_type or '–ü—Ä–æ–¥–∞–∂–∞',
            'is_apartment': is_apartment,
            'published_date': published_dt,
            'placement_type': placement_type or '–ù–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∞'
        }
        
        if not property_data:
            print(f"Property {property_id} not found")
            return redirect(url_for('properties'))
        
        # Ensure all required fields exist for template
        property_data['cashback_amount'] = property_data['cashback']
        
        # Generate full title format for property detail page
        rooms = property_data.get('rooms', 0)
        area = property_data.get('area', 0)
        floor = property_data.get('floor', 1)
        total_floors = property_data.get('total_floors', 20)
        
        # Generate room type text
        if rooms > 0:
            room_text = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
        else:
            room_text = "–°—Ç—É–¥–∏—è"
            
        # Create full detailed title for property page
        title_parts = [room_text]
        
        if area:
            title_parts.append(f"{area} –º¬≤")
            
        title_parts.append(f"{floor}/{total_floors} —ç—Ç.")
        
        # Join with commas for full format
        property_data['title'] = ", ".join(title_parts)
        
        if 'property_type' not in property_data:
            property_data['property_type'] = f"{rooms}-–∫–æ–º–Ω" if rooms > 0 else "–°—Ç—É–¥–∏—è"
            
        if 'completion_date' not in property_data:
            property_data['completion_date'] = '2025'
            
        if 'total_floors' not in property_data:
            property_data['total_floors'] = 20
            
        if 'apartment_number' not in property_data:
            property_data['apartment_number'] = str(property_data['id'])
            
        if 'building' not in property_data:
            property_data['building'] = '–ö–æ—Ä–ø—É—Å 1'
            
        # Add template-required fields
        if 'complex_id' not in property_data:
            property_data['complex_id'] = property_data.get('residential_complex_id', 1)
            
        if 'complex_name' not in property_data:
            property_data['complex_name'] = property_data.get('residential_complex', '–ñ–ö')
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ñ–ö –∏–∑ —Ç–∞–±–ª–∏—Ü—ã residential_complexes
        complex_info = None
        if complex_id or complex_name:
            complex_result = db.session.execute(text("""
                SELECT name, district_id, developer_id, object_class_display_name, 
                       start_build_year, end_build_year, has_accreditation, 
                       has_green_mortgage, with_renovation, cashback_rate
                FROM residential_complexes 
                WHERE complex_id = :complex_id OR name = :complex_name
            """), {"complex_id": str(complex_id) if complex_id else '', "complex_name": complex_name})
            complex_row = complex_result.fetchone()
            if complex_row:
                complex_info = {
                    'name': complex_row[0],
                    'district_id': complex_row[1],
                    'developer_id': complex_row[2],
                    'class_display_name': complex_row[3],
                    'start_year': complex_row[4],
                    'end_year': complex_row[5],
                    'has_accreditation': complex_row[6],
                    'has_green_mortgage': complex_row[7],
                    'with_renovation': complex_row[8],
                    'cashback_rate': complex_row[9] if complex_row[9] is not None else 5.0
                }
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –∫–µ—à–±–µ–∫–∞ –∏–∑ –ñ–ö –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        if 'cashback_percent' not in property_data:
            property_data['cashback_percent'] = complex_info.get('cashback_rate', 5.0) if complex_info else 5.0
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –ñ–ö –µ—Å–ª–∏ –µ—Å—Ç—å complex_id
        similar_apartments = []
        if complex_id:
            # 1. –í—Å–µ–≥–æ –∫–≤–∞—Ä—Ç–∏—Ä –≤ —ç—Ç–æ–º –ñ–ö
            total_result = db.session.execute(text("""
                SELECT COUNT(*) as total
                FROM excel_properties 
                WHERE complex_id = :complex_id
            """), {"complex_id": complex_id})
            property_data['complex_total_apartments'] = int(total_result.fetchone()[0] or 0)
            
            # 2. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–≤–∞—Ä—Ç–∏—Ä —Ç–∞–∫–æ–π –∂–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∫–∏ (–ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∫–æ–º–Ω–∞—Ç)
            same_type_result = db.session.execute(text("""
                SELECT COUNT(*) as total
                FROM excel_properties 
                WHERE complex_id = :complex_id AND object_rooms = :rooms
            """), {"complex_id": complex_id, "rooms": rooms})
            property_data['same_type_apartments'] = int(same_type_result.fetchone()[0] or 0)
            
            # 3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ—Ä–ø—É—Å–æ–≤ –≤ –ñ–ö
            buildings_result = db.session.execute(text("""
                SELECT COUNT(DISTINCT complex_building_name) as total
                FROM excel_properties 
                WHERE complex_id = :complex_id AND complex_building_name IS NOT NULL
            """), {"complex_id": complex_id})
            property_data['complex_buildings_count'] = int(buildings_result.fetchone()[0] or 1)
            
            # 4. –ù–û–í–û–ï: –ü–æ–ª—É—á–∞–µ–º –¥—Ä—É–≥–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –∏–∑ —ç—Ç–æ–≥–æ –∂–µ –ñ–ö (–∏—Å–∫–ª—é—á–∞—è —Ç–µ–∫—É—â—É—é)
            similar_result = db.session.execute(text("""
                SELECT inner_id, price, object_area, object_rooms, object_min_floor, 
                       object_max_floor, photos, complex_building_name
                FROM excel_properties 
                WHERE complex_id = :complex_id AND inner_id != :current_id
                ORDER BY object_rooms ASC, price ASC
                LIMIT 8
            """), {"complex_id": complex_id, "current_id": property_id})
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —à–∞–±–ª–æ–Ω–∞
            for row in similar_result.fetchall():
                apt_id, apt_price, apt_area, apt_rooms, apt_min_floor, apt_max_floor, apt_photos, apt_building = row
                
                # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
                apt_images = []
                if apt_photos:
                    try:
                        if apt_photos.startswith('{') and apt_photos.endswith('}'):
                            photos_clean = apt_photos[1:-1]
                            if photos_clean:
                                apt_images = [url.strip() for url in photos_clean.split(',')]
                        else:
                            import json
                            photos_list = json.loads(apt_photos)
                            apt_images = photos_list if photos_list else []
                    except:
                        apt_images = []
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–∏–ø –∫–æ–º–Ω–∞—Ç
                room_type = f"{apt_rooms}-–∫–æ–º–Ω" if apt_rooms > 0 else "–°—Ç—É–¥–∏—è"
                
                similar_apartments.append({
                    'id': apt_id,
                    'price': apt_price or 0,
                    'area': apt_area or 0,
                    'rooms': apt_rooms or 0,
                    'room_type': room_type,
                    'floor': apt_min_floor or 1,
                    'total_floors': apt_max_floor or apt_min_floor or 1,
                    'building': apt_building or '–ö–æ—Ä–ø—É—Å 1',
                    'cashback': calculate_cashback(apt_price) if apt_price else 0,
                    'image': apt_images[0] if apt_images else 'https://via.placeholder.com/300x200/f3f4f6/9ca3af?text=–§–æ—Ç–æ+–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ',
                    'title': f"{room_type}, {apt_area} –º¬≤, {apt_min_floor}/{apt_max_floor or apt_min_floor} —ç—Ç." if apt_area else f"{room_type}"
                })
        else:
            property_data['complex_total_apartments'] = 0
            property_data['same_type_apartments'] = 0
            property_data['complex_buildings_count'] = 0
            
        print(f"Rendering property {property_id}: {property_data.get('title', 'Unknown')}")
        # Get manager info for current user (if logged in)
        manager_data = None
        if current_user.is_authenticated:
            user = User.query.get(current_user.id)
            if user and user.assigned_manager:
                manager = user.assigned_manager
                manager_data = {
                    'name': f"{manager.first_name} {manager.last_name}",
                    'phone': manager.phone,
                    'email': manager.email,
                    'photo': manager.profile_image if manager.profile_image and not 'randomuser.me' in manager.profile_image else None
                }
        
        return render_template('property_detail.html', property=property_data, complex_info=complex_info, similar_apartments=similar_apartments, manager=manager_data)
        
    except Exception as e:
        print(f"ERROR in property detail route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def create_slug(name):
    """Create SEO-friendly slug from complex name with transliteration"""
    if not name:
        return "unknown"
    
    # Transliteration table for Russian to Latin
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch', '—ä': '',
        '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
        # Uppercase variants
        '–ê': 'A', '–ë': 'B', '–í': 'V', '–ì': 'G', '–î': 'D', '–ï': 'E', '–Å': 'Yo',
        '–ñ': 'Zh', '–ó': 'Z', '–ò': 'I', '–ô': 'Y', '–ö': 'K', '–õ': 'L', '–ú': 'M',
        '–ù': 'N', '–û': 'O', '–ü': 'P', '–†': 'R', '–°': 'S', '–¢': 'T', '–£': 'U',
        '–§': 'F', '–•': 'H', '–¶': 'Ts', '–ß': 'Ch', '–®': 'Sh', '–©': 'Sch', '–™': '',
        '–´': 'Y', '–¨': '', '–≠': 'E', '–Æ': 'Yu', '–Ø': 'Ya'
    }
    
    # Remove –ñ–ö prefix and quotes
    name = re.sub(r'^–ñ–ö\s*["\']?', '', name, flags=re.IGNORECASE)
    name = re.sub(r'["\']', '', name)  # Remove remaining quotes
    
    # Transliterate Cyrillic to Latin
    slug = ''
    for char in name:
        if char in translit_map:
            slug += translit_map[char]
        else:
            slug += char
    
    # Clean up: remove special characters except spaces and hyphens
    slug = re.sub(r'[^\w\s-]', '', slug)
    # Replace spaces/multiple hyphens with single hyphen
    slug = re.sub(r'[-\s]+', '-', slug)
    
    return slug.lower().strip('-')

@app.route('/residential_complex/<int:complex_id>')
@app.route('/residential-complex/<int:complex_id>')  # Support both formats
@app.route('/residential-complex/<complex_name>')  # Support name-based routing
@app.route('/zk/<slug>')  # New SEO-friendly format: /zk/zhk-kislorod
def residential_complex_detail(complex_id=None, complex_name=None, slug=None):
    """Individual residential complex page"""
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö - –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ –∏–º–µ–Ω–∏, ID –∏ slug
        if slug:
            # –ü–æ–∏—Å–∫ –ø–æ slug - –∏—â–µ–º –ñ–ö, —á–µ–π slug —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–º—É
            complexes_query = db.session.execute(text("""
                SELECT rc.*
                FROM residential_complexes rc
            """))
            complex_row = None
            for row in complexes_query.fetchall():
                if create_slug(row.name) == slug:
                    complex_row = row
                    break
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü–µ, –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –≤ Excel
            if not complex_row:
                excel_complexes = db.session.execute(text("""
                    SELECT DISTINCT complex_name
                    FROM excel_properties
                """)).fetchall()
                for excel_row in excel_complexes:
                    if create_slug(excel_row[0]) == slug:
                        complex_name = excel_row[0]
                        break
        elif complex_name:
            complex_query = db.session.execute(text("""
                SELECT rc.*
                FROM residential_complexes rc
                WHERE rc.name = :complex_name
            """), {'complex_name': complex_name})
            complex_row = complex_query.fetchone()
        elif complex_id:
            complex_query = db.session.execute(text("""
                SELECT rc.*
                FROM residential_complexes rc
                WHERE rc.complex_id = :complex_id_str OR rc.id = :complex_id
            """), {'complex_id': complex_id, 'complex_id_str': str(complex_id)})
            complex_row = complex_query.fetchone()
        else:
            complex_row = None
        if not complex_row:
            print(f"Complex {complex_id or complex_name or slug} not found in database")
            # –°–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–µ Excel –¥–∞–Ω–Ω—ã—Ö
            if complex_name:
                excel_query = db.session.execute(text("""
                    SELECT complex_name, COUNT(*) as apartments_count
                    FROM excel_properties 
                    WHERE complex_name = :complex_name
                    GROUP BY complex_name
                """), {'complex_name': complex_name})
                excel_row = excel_query.fetchone()
                if excel_row:
                    complex_data = {
                        'id': 1,
                        'name': excel_row[0],
                        'apartments_count': excel_row[1],
                        'description': f'–ñ–ö {excel_row[0]} —Å {excel_row[1]} –∫–≤–∞—Ä—Ç–∏—Ä–∞–º–∏'
                    }
                else:
                    return redirect(url_for('properties'))
            else:
                return redirect(url_for('properties'))
        else:
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º complex_row –≤ —Å–ª–æ–≤–∞—Ä—å
            try:
                complex_data = dict(complex_row._mapping)
            except (AttributeError, TypeError) as e:
                print(f"Error converting complex_row to dict: {e}")
                return redirect(url_for('properties'))
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ Excel –¥–ª—è —ç—Ç–æ–≥–æ –ñ–ö –≤–∫–ª—é—á–∞—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ—Ä–ø—É—Å–æ–≤
        excel_data_query = db.session.execute(text("""
            SELECT 
                COUNT(*) as total_apartments,
                MIN(price) as min_price,
                MAX(price) as max_price,
                AVG(price) as avg_price,
                MIN(object_area) as min_area,
                MAX(object_area) as max_area,
                MIN(object_min_floor) as min_floor,
                MAX(object_max_floor) as max_floor_in_complex,
                MAX(address_short_display_name) as address_display_name,
                MAX(complex_sales_address) as sales_address,
                CASE 
                    WHEN COUNT(DISTINCT complex_building_name) > 0 THEN COUNT(DISTINCT complex_building_name)
                    ELSE 1 
                END as buildings_count,
                MAX(complex_start_build_year) as complex_start_year,
                MAX(complex_start_build_quarter) as complex_start_quarter,
                MAX(complex_object_class_display_name) as object_class,
                bool_or(complex_with_renovation) as with_renovation
            FROM excel_properties ep
            WHERE ep.complex_name = :complex_name
        """), {'complex_name': complex_data['name']})
        
        excel_data = excel_data_query.fetchone()
        if excel_data and excel_data[0]:
            # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–º–ø–ª–µ–∫—Å–∞ —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ Excel
            complex_data['apartments_count'] = excel_data[0]
            complex_data['price_from'] = int(excel_data[1]) if excel_data[1] else 3000000
            complex_data['price_to'] = int(excel_data[2]) if excel_data[2] else 15000000
            complex_data['real_price_from'] = complex_data['price_from']
            complex_data['real_price_to'] = complex_data['price_to']
            complex_data['real_area_from'] = excel_data[4] if excel_data[4] else 35
            complex_data['real_area_to'] = excel_data[5] if excel_data[5] else 135
            complex_data['real_floors_min'] = excel_data[6] if excel_data[6] else 1
            complex_data['real_floors_max'] = excel_data[7] if excel_data[7] else 25
            complex_data['total_floors_in_complex'] = excel_data[7] if excel_data[7] else 25
            complex_data['full_address'] = excel_data[8] if excel_data[8] else complex_data.get('sales_address', '')
            complex_data['sales_address'] = excel_data[9] if excel_data[9] else complex_data.get('sales_address', '')
            # –ù–æ–≤—ã–µ –ø–æ–ª—è
            complex_data['buildings_count'] = excel_data[10] if excel_data[10] else 1
            complex_data['complex_start_year'] = excel_data[11] if excel_data[11] else 2020
            complex_data['complex_start_quarter'] = excel_data[12] if excel_data[12] else 1
            complex_data['object_class_display_name'] = excel_data[13] if excel_data[13] else '–ö–æ–º—Ñ–æ—Ä—Ç'
            complex_data['with_renovation'] = excel_data[14] if excel_data[14] else False
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–µ –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö
            developer_query = db.session.execute(text("""
                SELECT DISTINCT developer_name 
                FROM excel_properties 
                WHERE complex_name = :complex_name 
                AND developer_name IS NOT NULL
                LIMIT 1
            """), {'complex_name': complex_data['name']})
            
            developer_row = developer_query.fetchone()
            if developer_row:
                complex_data['developer_name'] = developer_row[0]
                # Developer set
            else:
                # No developer found
                pass
                
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –∫–∞—Ä—Ç—ã
            coordinates_query = db.session.execute(text("""
                SELECT address_position_lat, address_position_lon 
                FROM excel_properties 
                WHERE complex_name = :complex_name 
                AND address_position_lat IS NOT NULL 
                AND address_position_lon IS NOT NULL
                LIMIT 1
            """), {'complex_name': complex_data['name']})
            
            coordinates_row = coordinates_query.fetchone()
            if coordinates_row:
                complex_data['coordinates'] = [coordinates_row[0], coordinates_row[1]]
                # Coordinates set
            else:
                complex_data['coordinates'] = [45.0355, 38.9753]  # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                # Using default coordinates
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –ñ–ö –∏–∑ —Å–∞–º–æ–π –¥–æ—Ä–æ–≥–æ–π –∫–≤–∞—Ä—Ç–∏—Ä—ã (–∫–∞–∫ —Ä–µ–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ç–∏–≤–Ω—ã–µ –¥–ª—è –ñ–ö)
            first_apartment_query = db.session.execute(text("""
                SELECT photos FROM excel_properties 
                WHERE complex_name = :complex_name 
                AND photos IS NOT NULL 
                ORDER BY price DESC, object_area DESC
                LIMIT 1
            """), {'complex_name': complex_data['name']})
            
            first_apartment = first_apartment_query.fetchone()
            if first_apartment and first_apartment[0]:
                try:
                    photos_raw = first_apartment[0]
                    # –ü–∞—Ä—Å–∏–º PostgreSQL array —Ñ–æ—Ä–º–∞—Ç {url1,url2,url3}
                    if photos_raw.startswith('{') and photos_raw.endswith('}'):
                        photos_clean = photos_raw[1:-1]  # —É–±–∏—Ä–∞–µ–º { –∏ }
                        if photos_clean:
                            photos_list = [url.strip() for url in photos_clean.split(',')]
                    else:
                        # –ï—Å–ª–∏ —ç—Ç–æ JSON —Ñ–æ—Ä–º–∞—Ç, –ø–∞—Ä—Å–∏–º –∫–∞–∫ JSON
                        import json
                        photos_list = json.loads(photos_raw)
                    
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ —Ñ–æ—Ç–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–æ–∫ –∏ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö
                    start_index = min(len(photos_list) // 4, 5) if len(photos_list) > 8 else 1
                    complex_images = photos_list[start_index:] if len(photos_list) > start_index else photos_list
                    complex_data['images'] = complex_images[:10]  # –ë–µ—Ä–µ–º –¥–æ 10 —Ñ–æ—Ç–æ –ñ–ö –¥–ª—è —Å–ª–∞–π–¥–µ—Ä–∞
                    complex_data['image'] = complex_images[0] if complex_images else photos_list[0]
                except Exception as e:
                    print(f"Error parsing photos for complex {complex_data['name']}: {e}")
                    complex_data['images'] = []
                    complex_data['image'] = None
            else:
                complex_data['images'] = []
                complex_data['image'] = None
                
            print(f"Updated complex data with Excel: {complex_data['apartments_count']} apartments, price from {complex_data['price_from']}, address: {complex_data['full_address']}, photos: {len(complex_data.get('images', []))}")
        
        if not complex_data:
            print(f"Complex {complex_id} not found")
            return redirect(url_for('properties'))
        
        # Ensure required fields exist
        if 'price_from' not in complex_data:
            complex_data['price_from'] = 3000000
        if 'real_price_from' not in complex_data:
            complex_data['real_price_from'] = complex_data['price_from']
        if 'cashback_percent' not in complex_data:
            complex_data['cashback_percent'] = complex_data.get('cashback_rate', 5.0)
        
        # Add developer_id for link functionality
        if 'developer_id' not in complex_data:
            developer_mapping = {
                '–ì–ö ¬´–ò–Ω–≤–µ—Å—Ç—Å—Ç—Ä–æ–π–∫—É–±¬ª': 1,
                '–ñ–ö –î–µ–≤–µ–ª–æ–ø–º–µ–Ω—Ç': 2,
                '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –°—Ç—Ä–æ–π': 3,
                '–Æ–∂–Ω—ã–π –î–æ–º': 4,
                '–ö—É–±–∞–Ω—å –î–µ–≤–µ–ª–æ–ø–º–µ–Ω—Ç': 5
            }
            developer_name = complex_data.get('developer', '')
            complex_data['developer_id'] = developer_mapping.get(developer_name, 1)
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–≤–∞—Ä—Ç–∏—Ä—ã —ç—Ç–æ–≥–æ –ñ–ö –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö
        apartments_query = db.session.execute(text("""
            SELECT *
            FROM excel_properties ep
            WHERE ep.complex_name = :complex_name
            ORDER BY ep.price ASC
        """), {'complex_name': complex_data['name']})
        
        complex_properties = []
        cashback_rate_decimal = complex_data.get('cashback_percent', 5.0) / 100.0
        for i, prop_row in enumerate(apartments_query):
            prop_dict = dict(prop_row._mapping)
            # –î–æ–±–∞–≤–ª—è–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ø–æ–ª—è
            prop_dict['id'] = prop_dict.get('inner_id', i + 1)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º inner_id –∏–∑ Excel –¥–ª—è —Å—Å—ã–ª–æ–∫
            prop_dict['cashback_amount'] = int(prop_dict['price'] * cashback_rate_decimal) if prop_dict.get('price') else 0
            prop_dict['type'] = f"{prop_dict.get('object_rooms', 1)}-–∫–æ–º–Ω"
            prop_dict['residential_complex_id'] = complex_id
            prop_dict['residential_complex'] = complex_data['name']
            
            # –ü—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç—Ç–∞–∂ –∫–≤–∞—Ä—Ç–∏—Ä—ã –∏–∑ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç—Ç–∞–∂–µ–π –≤ –∫–æ–º–ø–ª–µ–∫—Å–µ
            apartment_floor = prop_dict.get('object_min_floor', 1)  # –≠—Ç–∞–∂ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–≤–∞—Ä—Ç–∏—Ä—ã
            total_floors = complex_data.get('total_floors_in_complex', 25)  # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç—Ç–∞–∂–µ–π –≤ –∫–æ–º–ø–ª–µ–∫—Å–µ
            # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–≤–∞—Ä—Ç–∏—Ä—ã
            rooms = prop_dict.get('object_rooms', 1)
            if rooms == 0:
                room_type = "–°—Ç—É–¥–∏—è"
            else:
                room_type = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
            prop_dict['title'] = f"{room_type}, {prop_dict.get('object_area', 0)} –º¬≤, {apartment_floor}/{total_floors} —ç—Ç."
            prop_dict['apartment_floor'] = apartment_floor
            prop_dict['total_floors_in_complex'] = total_floors
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏–∑ Excel (PostgreSQL array —Ñ–æ—Ä–º–∞—Ç)
            photos_raw = prop_dict.get('photos', '')
            try:
                if photos_raw and photos_raw.startswith('{') and photos_raw.endswith('}'):
                    # PostgreSQL array —Ñ–æ—Ä–º–∞—Ç {url1,url2,url3}
                    photos_clean = photos_raw[1:-1]  # —É–±–∏—Ä–∞–µ–º { –∏ }
                    if photos_clean:
                        photos_list = [url.strip() for url in photos_clean.split(',')]
                else:
                    # –ï—Å–ª–∏ —ç—Ç–æ JSON —Ñ–æ—Ä–º–∞—Ç, –ø–∞—Ä—Å–∏–º –∫–∞–∫ JSON
                    import json
                    photos_list = json.loads(photos_raw) if photos_raw else []
                
                prop_dict['image'] = photos_list[0] if photos_list else 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=–ö–≤–∞—Ä—Ç–∏—Ä–∞'
                prop_dict['photos_list'] = photos_list  # –í—Å–µ —Ñ–æ—Ç–æ –¥–ª—è –≥–∞–ª–µ—Ä–µ–∏
            except Exception as e:
                print(f"Error parsing photos for apartment {prop_dict.get('inner_id', 'unknown')}: {e}")
                prop_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=–ö–≤–∞—Ä—Ç–∏—Ä–∞'
                prop_dict['photos_list'] = []
                
            prop_dict['property_type'] = '–ö–≤–∞—Ä—Ç–∏—Ä–∞'
            complex_properties.append(prop_dict)
        
        # Group properties by room count and calculate statistics for each type
        properties_by_rooms = {}
        room_stats = {}
        for prop in complex_properties:
            rooms = prop.get('object_rooms', 1)
            # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–≤–∞—Ä—Ç–∏—Ä—ã
            if rooms == 0:
                room_key = '–°—Ç—É–¥–∏—è'
                room_type = '–°—Ç—É–¥–∏—è'
            else:
                room_key = f'{rooms}-–∫–æ–º–Ω'
                room_type = f'{rooms}-–∫–æ–º–Ω'
            
            if room_key not in properties_by_rooms:
                properties_by_rooms[room_key] = []
                room_stats[room_key] = {
                    'count': 0,
                    'prices': [],
                    'areas': [],
                    'name': room_type
                }
            
            properties_by_rooms[room_key].append(prop)
            room_stats[room_key]['count'] += 1
            if prop.get('price'):
                room_stats[room_key]['prices'].append(prop['price'])
            if prop.get('object_area'):
                room_stats[room_key]['areas'].append(prop['object_area'])
        
        # Calculate min/max for each room type
        for room_key in room_stats:
            stats = room_stats[room_key]
            if stats['prices']:
                stats['price_from'] = min(stats['prices'])
                stats['price_to'] = max(stats['prices'])
            else:
                stats['price_from'] = 0
                stats['price_to'] = 0
            
            if stats['areas']:
                stats['area_from'] = min(stats['areas'])
                stats['area_to'] = max(stats['areas'])
            else:
                stats['area_from'] = 0
                stats['area_to'] = 0
        
        complex_data['room_stats'] = room_stats
        
        # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∫–≤–∞—Ä—Ç–∏—Ä –ø–æ –∫–æ—Ä–ø—É—Å–∞–º/–ª–∏—Ç–µ—Ä–∞–º —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π
        properties_by_building_unsorted = {}
        for prop in complex_properties:
            building_name = prop.get('complex_building_name', '–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å')
            if building_name not in properties_by_building_unsorted:
                properties_by_building_unsorted[building_name] = []
            properties_by_building_unsorted[building_name].append(prop)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–æ—Ä–ø—É—Å–∞ –ø–æ —á–∏—Å–ª–æ–≤–æ–º—É –ø–æ—Ä—è–¥–∫—É
        def sort_buildings(building_name):
            import re
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ None –∏–ª–∏ –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É
            if not building_name:
                return 999  # None/–ø—É—Å—Ç—ã–µ –≤ –∫–æ–Ω—Ü–µ
            # –ò—â–µ–º —á–∏—Å–ª–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –∫–æ—Ä–ø—É—Å–∞
            match = re.search(r'([0-9]+)', str(building_name))
            if match:
                return int(match.group(1))
            else:
                return 999  # –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤ –∫–æ–Ω—Ü–µ
        
        # –°–æ–∑–¥–∞–µ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –∫–æ—Ä–ø—É—Å–æ–≤
        properties_by_building = {}
        sorted_building_names = sorted(properties_by_building_unsorted.keys(), key=sort_buildings)
        for building_name in sorted_building_names:
            properties_by_building[building_name] = properties_by_building_unsorted[building_name]
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∫–æ—Ä–ø—É—Å–∞—Ö –∏–∑ Excel —Å –º–∞–∫—Å–∏–º—É–º–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        buildings_data = {}
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –∫–æ—Ä–ø—É—Å–∞—Ö –∏–∑ Excel —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —Å—Ç–∞—Ç—É—Å–æ–º
            buildings_query = db.session.execute(text("""
                SELECT 
                    ep.complex_building_name as building_name,
                    ep.complex_building_end_build_year as end_build_year,
                    ep.complex_building_end_build_quarter as end_build_quarter,
                    ep.complex_start_build_year as start_build_year,  
                    ep.complex_start_build_quarter as start_build_quarter,
                    ep.complex_object_class_display_name as object_class,
                    COUNT(*) as total_apartments,
                    MAX(ep.complex_building_end_build_year) as max_end_build_year,
                    MAX(ep.complex_building_end_build_quarter) as max_end_build_quarter,
                    MAX(ep.object_max_floor) as total_floors,
                    999 as sort_order
                FROM excel_properties ep
                WHERE ep.complex_name = :complex_name 
                AND ep.complex_building_name IS NOT NULL
                GROUP BY ep.complex_building_name, ep.complex_building_end_build_year, 
                         ep.complex_building_end_build_quarter, ep.complex_start_build_year,
                         ep.complex_start_build_quarter, ep.complex_object_class_display_name
                ORDER BY sort_order, ep.complex_building_name
            """), {
                'complex_name': complex_data.get('name', '')
            })
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –≤ Python –¥–ª—è –∫—Ä–æ—Å—Å-–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç–∏
            from datetime import datetime
            import re
            current_date = datetime.now()
            current_year = current_date.year
            current_quarter = (current_date.month - 1) // 3 + 1
            
            # –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
            buildings_list = []
            for building_row in buildings_query:
                building_dict = dict(building_row._mapping)
                
                # –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–æ—Ä–ø—É—Å–∞ –≤ Python 
                end_year = building_dict.get('max_end_build_year')
                end_quarter = building_dict.get('max_end_build_quarter')
                
                if end_year and end_quarter:
                    if (end_year < current_year or 
                        (end_year == current_year and end_quarter <= current_quarter)):
                        building_dict['building_status'] = '–°–¥–∞–Ω'
                    else:
                        building_dict['building_status'] = '–°—Ç—Ä–æ–∏—Ç—Å—è'
                    # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è —à–∞–±–ª–æ–Ω–∞
                    building_dict['end_build_year'] = end_year
                    building_dict['end_build_quarter'] = end_quarter
                else:
                    building_dict['building_status'] = '–ù–µ —É–∫–∞–∑–∞–Ω'
                
                # –í—ã—á–∏—Å–ª—è–µ–º sort_order –≤ Python (–∫—Ä–æ—Å—Å-–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ)
                building_name = building_dict.get('building_name', '')
                match = re.search(r'([0-9]+)', building_name)
                if match:
                    building_dict['sort_order'] = int(match.group(1))
                else:
                    building_dict['sort_order'] = 999
                    
                buildings_list.append(building_dict)
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ sort_order –≤ Python
            buildings_list.sort(key=lambda x: (x['sort_order'], x.get('building_name', '')))
            
            # –°–æ–∑–¥–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Å–ª–æ–≤–∞—Ä—å
            for building_dict in buildings_list:
                buildings_data[building_dict['building_name']] = building_dict
            
            print(f"Loaded {len(buildings_data)} buildings for complex {complex_data.get('name')}")
        except Exception as e:
            print(f"Error loading buildings data: {e}")
            import traceback
            traceback.print_exc()
        
        complex_data['buildings'] = buildings_data
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∫–æ—Ä–ø—É—Å–æ–≤
        from datetime import datetime
        current_date = datetime.now()
        complex_data['current_year'] = current_date.year
        complex_data['current_quarter'] = (current_date.month - 1) // 3 + 1
        
        # –ù–∞–π—Ç–∏ –ø–æ—Ö–æ–∂–∏–µ –ñ–ö - —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        similar_complexes = []
        try:
            # –ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è 3 –¥—Ä—É–≥–∏—Ö –ñ–ö
            current_complex_name = complex_data.get('name', '')
            
            with db.engine.connect() as connection:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏
                result = connection.execute(text("""
                    SELECT DISTINCT 
                        ep.complex_name,
                        rc.id,
                        MIN(ep.price) as price_from,
                        MAX(ep.price) as price_to,
                        COUNT(*) as apartments_count,
                        MAX(ep.developer_name) as developer_name,
                        MAX(ep.address_short_display_name) as location,
                        MAX(ep.photos) as photos
                    FROM excel_properties ep
                    LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
                    WHERE ep.complex_name != :current_complex_name
                    AND ep.price IS NOT NULL
                    GROUP BY ep.complex_name, rc.id
                    ORDER BY MIN(ep.price) ASC
                    LIMIT 3
                """), {'current_complex_name': current_complex_name})
                
                for row in result.fetchall():
                    # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ
                    image_url = 'https://via.placeholder.com/300x200'
                    if row[7]:  # photos field
                        try:
                            import json
                            photos_raw = row[7]
                            # –§–æ—Ç–æ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ
                            photos_list = json.loads(photos_raw)
                            if photos_list:
                                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ —Ñ–æ—Ç–æ (–∏–Ω—Ç–µ—Ä—å–µ—Ä—ã) –∏ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö
                                start_index = min(len(photos_list) // 4, 5) if len(photos_list) > 8 else 1
                                image_url = photos_list[start_index] if len(photos_list) > start_index else photos_list[0]
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    similar_complex = {
                        'id': row[1] or 999,
                        'name': row[0],
                        'price_from': int(row[2]) if row[2] else 0,
                        'price_to': int(row[3]) if row[3] else 0,
                        'apartments_count': row[4],
                        'developer': row[5] or '–ù–µ —É–∫–∞–∑–∞–Ω',
                        'location': row[6] or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                        'image': image_url,
                        'completion_date': '2025 –≥.',
                        'cashback_percent': 5.0,
                        'url': f'/residential-complex/{row[1]}' if row[1] else '#'
                    }
                    similar_complexes.append(similar_complex)
                    
        except Exception as e:
            print(f"Error finding similar complexes: {e}")
            # –ï—Å–ª–∏ –≤—Å–µ —É–ø–∞–ª–æ, –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
            similar_complexes = []
        
        print(f"Found {len(similar_complexes)} similar complexes for {complex_data.get('name', 'Unknown')}")
        print(f"Rendering complex {complex_id}: {complex_data.get('name', 'Unknown')}")
        return render_template('residential_complex_detail.html', 
                             complex=complex_data,
                             properties=complex_properties,
                             properties_by_rooms=properties_by_rooms,
                             properties_by_building=properties_by_building,
                             similar_complexes=similar_complexes)
                             
    except Exception as e:
        print(f"ERROR in complex detail route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

@app.route('/developer/<int:developer_id>')
def developer_detail(developer_id):
    """Individual developer page"""
    try:
        # Load developer data from JSON file instead of DB to avoid conflicts
        with open('data/developers.json', 'r', encoding='utf-8') as f:
            developers_data = json.load(f)
        
        # Find developer by ID
        developer = None
        for dev in developers_data:
            if dev['id'] == developer_id:
                developer = dev
                break
        
        if not developer:
            return "–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", 404
        
        # Add missing template fields for new developers
        if 'total_apartments_sold' not in developer:
            developer['total_apartments_sold'] = 150
        if 'projects_completed' not in developer:
            developer['projects_completed'] = 8
        if 'years_experience' not in developer:
            developer['years_experience'] = 10
        if 'rating' not in developer:
            developer['rating'] = 4.5
        if 'construction_technology' not in developer:
            developer['construction_technology'] = '–ú–æ–Ω–æ–ª–∏—Ç–Ω–æ-–∫–∞—Ä–∫–∞—Å–Ω–∞—è'
        if 'warranty_years' not in developer:
            developer['warranty_years'] = 5
        if 'advantages' not in developer:
            developer['advantages'] = [
                '–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ',
                '–°–æ–±–ª—é–¥–µ–Ω–∏–µ —Å—Ä–æ–∫–æ–≤ —Å–¥–∞—á–∏',
                '–†–∞–∑–≤–∏—Ç–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞',
                '–í—ã–≥–æ–¥–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏'
            ]
        
        # Get all complexes by this developer
        complexes = load_residential_complexes()
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer_id or c.get('developer') == developer['name']]
        
        # Get all properties by this developer
        properties = load_properties()
        developer_properties = [p for p in properties if p.get('developer') == developer['name']]
        
        return render_template('developer_detail.html',
                             developer=developer,
                             complexes=developer_complexes,
                             properties=developer_properties)
    except Exception as e:
        print(f"ERROR in developer_detail route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def crop_watermark(image_url, crop_bottom_percent=8):
    """
    Crop watermark from image by removing bottom portion
    
    Args:
        image_url: URL of the image to crop
        crop_bottom_percent: Percentage of image height to crop from bottom (default 8%)
    
    Returns:
        PIL Image object with watermark cropped
    """
    try:
        # Download image
        response = requests.get(image_url, timeout=10)
        response.raise_for_status()
        
        # Open image
        img = Image.open(io.BytesIO(response.content))
        
        # Calculate crop dimensions
        width, height = img.size
        crop_height = int(height * (crop_bottom_percent / 100))
        new_height = height - crop_height
        
        # Crop image (remove bottom portion with watermark)
        cropped_img = img.crop((0, 0, width, new_height))
        
        return cropped_img
    except Exception as e:
        print(f"Error cropping watermark from {image_url}: {e}")
        return None

def generate_qr_code(url):
    """Generate QR code for given URL and return as base64 string"""
    try:
        # Create QR code instance
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        
        # Add data to QR code
        qr.add_data(url)
        qr.make(fit=True)
        
        # Create image
        qr_image = qr.make_image(fill_color="black", back_color="white")
        
        # Convert to base64
        buffer = io.BytesIO()
        qr_image.save(buffer, format='PNG')
        qr_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return qr_base64
    except Exception as e:
        print(f"Error generating QR code: {e}")
        return None

@app.route('/object/<int:property_id>/pdf')
def property_pdf(property_id):
    """Property PDF card page with QR code"""
    property_data = get_property_by_id(property_id)
    if not property_data:
        return redirect(url_for('properties'))
    
    # Calculate cashback for this property using complex_name
    cashback = calculate_cashback(property_data['price'], complex_name=property_data.get('complex_name'))
    
    # Add cashback data to property_data for PDF template
    property_data['cashback_amount'] = cashback
    
    # Get cashback percent from residential complex
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.cashback_rate:
                property_data['cashback_percent'] = float(complex.cashback_rate)
            else:
                property_data['cashback_percent'] = 5.0  # Default 5%
        else:
            property_data['cashback_percent'] = 5.0  # Default 5%
    except:
        property_data['cashback_percent'] = 5.0  # Default 5%
    
    # Get current date for PDF generation
    current_date = datetime.now().strftime('%d.%m.%Y')
    
    # Generate QR code with link to object page
    # Use custom domain from environment variable or fall back to current request domain
    custom_domain = os.environ.get('QR_DOMAIN')
    if custom_domain:
        # Remove trailing slash and ensure it starts with http:// or https://
        custom_domain = custom_domain.rstrip('/')
        if not custom_domain.startswith(('http://', 'https://')):
            custom_domain = 'https://' + custom_domain
        object_url = custom_domain + url_for('property_detail', property_id=property_id)
    else:
        # Default behavior - use current request domain
        object_url = request.url_root.rstrip('/') + url_for('property_detail', property_id=property_id)
    
    qr_code_base64 = generate_qr_code(object_url)
    
    # Add missing fields for PDF template
    property_data['name'] = property_data.get('title', '–û–±—ä–µ–∫—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏')
    
    # Get layout image from residential complex (first photo from gallery)
    complex_layout_image = None
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.gallery_images:
                try:
                    import json
                    gallery = json.loads(complex.gallery_images)
                    if gallery and isinstance(gallery, list) and len(gallery) > 0:
                        complex_layout_image = gallery[0]
                except (json.JSONDecodeError, TypeError, IndexError) as e:
                    print(f"Error parsing gallery images for complex {property_data.get('complex_name')}: {e}")
    except Exception as e:
        print(f"Error loading complex layout image: {e}")
    
    # Create presentation object for PDF template
    presentation = {
        'title': 'InBack.ru - –ö—ç—à–±–µ–∫ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏'
    }
    
    # Create property_images structure expected by PDF template
    property_images = {
        'photos': property_data.get('gallery', []),  # All apartment photos
        'floor_plan': property_data.get('floor_plan')  # Floor plan photo
    }
    
    return render_template('property_pdf.html', 
                         property=property_data,
                         property_images=property_images,
                         presentation=presentation,
                         cashback=cashback,
                         current_date=current_date,
                         qr_code=qr_code_base64,
                         object_url=object_url,
                         complex_layout_image=complex_layout_image)

@app.route('/about')
def about():
    """About page"""
    return render_template('about.html')

@app.route('/how-it-works')
def how_it_works():
    """How it works page"""
    return render_template('how-it-works.html')

@app.route('/reviews')
def reviews():
    """Reviews page"""
    return render_template('reviews.html')

@app.route('/contacts')
def contacts():
    """Contacts page"""
    return render_template('contacts.html')

@app.route('/blog')
def blog():
    """Blog main page with articles listing, search, and categories"""
    from models import BlogPost, Category
    from sqlalchemy import text
    
    # Get search parameters  
    search_query = request.args.get('search', '')
    category_filter = request.args.get('category', '')
    page = int(request.args.get('page', 1))
    per_page = 6
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–µ–π —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
    all_articles = []
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—å–∏ —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
        blog_posts = BlogPost.query.filter_by(status='published').filter(BlogPost.category_id.isnot(None)).all()
        for post in blog_posts:
            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            category_name = None
            if post.category_id:
                category_obj = Category.query.get(post.category_id)
                if category_obj:
                    category_name = category_obj.name
            
            all_articles.append({
                'id': post.id,
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —Å—Ç–∞—Ç—å—è –æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'content': post.content,
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'created_at': post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category_id': post.category_id,
                'category_name': category_name,
                'url': f'/blog/{post.slug}',
                'source': 'BlogPost'
            })
        
    except Exception as e:
        print(f"Error loading unified articles for blog: {e}")
    
    # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
    filtered_articles = all_articles.copy()
    
    # –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É
    if search_query:
        filtered_articles = [
            article for article in filtered_articles
            if search_query.lower() in article['title'].lower() or 
               search_query.lower() in (article['excerpt'] or '').lower() or
               search_query.lower() in (article['content'] or '').lower()
        ]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if category_filter:
        category = Category.query.filter_by(name=category_filter, is_active=True).first()
        if category:
            filtered_articles = [
                article for article in filtered_articles
                if article['category_id'] == category.id
            ]
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∞—Ç–µ
    filtered_articles.sort(key=lambda x: x['published_at'] or x['created_at'], reverse=True)
    
    # –†—É—á–Ω–∞—è –ø–∞–≥–∏–Ω–∞—Ü–∏—è
    total_articles = len(filtered_articles)
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    articles_page = filtered_articles[start_idx:end_idx]
    
    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –ø–æ—Ö–æ–∂–∏–π –Ω–∞ paginate –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    class PaginationMock:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
    
    articles = PaginationMock(articles_page, page, per_page, total_articles)
    
    # –ï—Å–ª–∏ –Ω–µ—Ç —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å—Ç–∞—Ç—å–∏ –ø—Ä–æ—Å—Ç–æ —Å–ø–∏—Å–∫–æ–º
    if not search_query and not category_filter:
        # Get all active categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å—Ç–∞—Ç—å–∏ –ø—Ä–æ—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º
        articles_to_show = all_articles[:per_page]
        return render_template('blog.html',
                             articles=articles_to_show,  # –ü–µ—Ä–≤—ã–µ —Å—Ç–∞—Ç—å–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                             all_categories=all_categories,  # –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                             search_query=search_query,
                             category_filter=category_filter,
                             current_page=page,
                             total_articles=len(all_articles),
                             show_category_sections=False)  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º
    else:
        # –ï—Å–ª–∏ –µ—Å—Ç—å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–º —Å–ø–∏—Å–∫–æ–º
        # Get all active categories for dynamic navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles_page,
                             all_categories=all_categories,
                             search_query=search_query,
                             category_filter=category_filter,
                             current_page=page,
                             total_articles=total_articles,
                             show_category_sections=False)

# Removed duplicate blog route - using blog_post function at line 7515

@app.route('/blog/category/<category_slug>')
def blog_category(category_slug):
    """Blog category page with search functionality"""
    try:
        from models import BlogPost, Category
        
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ slug —Å—Ç–∞—Ç—å–∏
        article = BlogPost.query.filter_by(slug=category_slug, status='published').first()
        if article:
            # –≠—Ç–æ —Å—Ç–∞—Ç—å—è, –∞ –Ω–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç
            return redirect(url_for('blog_post', slug=category_slug))
        
        # –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ slug –∏–ª–∏ –ø–æ –∏–º–µ–Ω–∏
        category = Category.query.filter(
            (Category.slug == category_slug) | 
            (Category.name.ilike(f'%{category_slug}%'))
        ).first()
        
        if not category:
            return redirect(url_for('blog'))
        
        # Get search query from URL parameters
        search_query = request.args.get('q', '').strip()
        
        # Get articles in this category
        page = int(request.args.get('page', 1))
        per_page = 6
        
        # Base query - articles in this category using foreign key
        articles_query = BlogPost.query.filter_by(status='published', category_id=category.id)
        
        # Add search filter if query provided
        if search_query:
            from sqlalchemy import or_, func
            search_filter = f"%{search_query.lower()}%"
            articles_query = articles_query.filter(
                or_(
                    func.lower(BlogPost.title).like(search_filter),
                    func.lower(BlogPost.excerpt).like(search_filter),
                    func.lower(BlogPost.content).like(search_filter)
                )
            )
        
        # Order by date descending
        articles_query = articles_query.order_by(BlogPost.created_at.desc())
        
        articles = articles_query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Get all categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles.items,
                             all_categories=all_categories,
                             current_category=category,
                             featured_articles=[],
                             search_query=search_query,
                             category_filter=category_slug,
                             current_page=page,
                             total_pages=articles.pages,
                             total_articles=articles.total)
                             
    except Exception as e:
        # Log error for debugging
        import traceback
        print(f"[ERROR] Exception in blog_category ({category_slug}): {str(e)}")
        print(f"[ERROR] Traceback: {traceback.format_exc()}")
        # Graceful fallback - redirect to main blog page
        flash('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', 'error')
        return redirect(url_for('blog'))

@app.route('/news')
def news():
    """News article page"""
    return render_template('news.html')

@app.route('/streets')
def streets():
    """Streets page"""
    # Load streets from database with slugs
    streets_db = db.session.execute(text("""
        SELECT name, slug, district_id 
        FROM streets 
        ORDER BY name
    """)).fetchall()
    
    # Get district names
    districts_db = db.session.execute(text("""
        SELECT id, name FROM districts
    """)).fetchall()
    districts_map = {d.id: d.name for d in districts_db}
    
    # Format streets data
    streets_data = []
    for street in streets_db:
        # Get first letter for grouping
        first_char = street.name[0].upper() if street.name else '–ê'
        
        streets_data.append({
            'name': street.name,
            'slug': street.slug,  # Use slug from database
            'district': districts_map.get(street.district_id, ''),
            'letter': first_char,
            'properties_count': 0,  # Can be calculated if needed
            'new_buildings': 0  # Can be calculated if needed
        })
    
    return render_template('streets.html', 
                         streets=streets_data)

# Redirect from /streets/<street_name> to /street/<slug>
@app.route('/streets/<path:street_name>')
def streets_redirect(street_name):
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å /streets/ –Ω–∞ /street/ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
    import urllib.parse
    
    # –î–µ–∫–æ–¥–∏—Ä—É–µ–º URL-encoded –∏–º—è
    decoded_name = urllib.parse.unquote(street_name)
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ª–æ–≥–∏–∫—É —á—Ç–æ –∏ street_slug() –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è slug
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
    }
    
    # –û—á–∏—â–∞–µ–º –∏–º—è
    name = decoded_name.strip().lower()
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)
    
    # –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # –ó–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –¥–µ—Ñ–∏—Å—ã –∏ —á–∏—Å—Ç–∏–º
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    slug = result.strip('-')
    
    # –†–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π URL
    return redirect(url_for('street_detail', street_name=slug), code=301)

@app.route('/street/<path:street_name>')
def street_detail(street_name):
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —É–ª–∏—Ü—ã —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –∫–∞—Ä—Ç–æ–π"""
    try:
        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º —É–ª–∏—Ü—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ slug
        street_db = db.session.execute(text("""
            SELECT name, slug, latitude, longitude, zoom_level, geometry, geometry_source
            FROM streets 
            WHERE slug = :street_slug
        """), {'street_slug': street_name}).fetchone()
        
        if street_db:
            # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–ª—è SEO
            import math
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É–ª–∏—Ü—ã
            street_type = '—É–ª–∏—Ü–µ'
            street_type_nominative = '—É–ª–∏—Ü–∞'
            name_lower = street_db.name.lower()
            if '–ø—Ä–æ–µ–∑–¥' in name_lower:
                street_type = '–ø—Ä–æ–µ–∑–¥–µ'
                street_type_nominative = '–ø—Ä–æ–µ–∑–¥'
            elif '–ø–µ—Ä–µ—É–ª–æ–∫' in name_lower or '–ø–µ—Ä.' in name_lower:
                street_type = '–ø–µ—Ä–µ—É–ª–∫–µ'
                street_type_nominative = '–ø–µ—Ä–µ—É–ª–æ–∫'
            elif '–±—É–ª—å–≤–∞—Ä' in name_lower:
                street_type = '–±—É–ª—å–≤–∞—Ä–µ'
                street_type_nominative = '–±—É–ª—å–≤–∞—Ä'
            elif '–ø–ª–æ—â–∞–¥—å' in name_lower:
                street_type = '–ø–ª–æ—â–∞–¥–∏'
                street_type_nominative = '–ø–ª–æ—â–∞–¥—å'
            elif '—à–æ—Å—Å–µ' in name_lower:
                street_type = '—à–æ—Å—Å–µ'
                street_type_nominative = '—à–æ—Å—Å–µ'
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
            distance_to_center = 0
            if street_db.latitude and street_db.longitude:
                center_lat, center_lng = 45.0448, 38.9760
                lat_diff = street_db.latitude - center_lat
                lng_diff = street_db.longitude - center_lng
                distance_to_center = round(math.sqrt(lat_diff**2 + lng_diff**2) * 111, 1)  # –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ –∫–º
                
                coordinates = {
                    'lat': float(street_db.latitude),
                    'lng': float(street_db.longitude)
                }
            else:
                coordinates = {
                    'lat': 45.0448,
                    'lng': 38.9760
                }
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—É –≥–æ—Ä–æ–¥–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
            location_zone = '—Ü–µ–Ω—Ç—Ä–µ –≥–æ—Ä–æ–¥–∞'
            if distance_to_center < 3:
                location_zone = '—Ü–µ–Ω—Ç—Ä–µ –≥–æ—Ä–æ–¥–∞'
            elif distance_to_center < 7:
                location_zone = '—Å—Ä–µ–¥–Ω–µ–π –∑–æ–Ω–µ –≥–æ—Ä–æ–¥–∞'
            else:
                location_zone = '–æ—Ç–¥–∞–ª—ë–Ω–Ω–æ–π –∑–æ–Ω–µ –≥–æ—Ä–æ–¥–∞'
            
            # –í–∞—Ä–∏–∞—Ü–∏–∏ –æ–ø–∏—Å–∞–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–π –±—É–∫–≤—ã (–¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
            first_letter_ord = ord(street_db.name[0].upper()) if street_db.name else 0
            variation = first_letter_ord % 4
            
            advantages = [
                ['—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –ñ–ö', '—Ä–∞–∑–≤–∏—Ç–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π', '–æ—Ç–ª–∏—á–Ω–æ–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é'],
                ['–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞–º–∏', '–≤—ã—Å–æ–∫–∏–º –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–æ–º', '—É–¥–æ–±–Ω—ã–º —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ–º'],
                ['–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∞–º–∏', '–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–º —Ä–∞–π–æ–Ω–æ–º', '–±–ª–∏–∑–æ—Å—Ç—å—é –∫ —Ü–µ–Ω—Ç—Ä—É'],
                ['–Ω–∞–¥—ë–∂–Ω—ã–º–∏ –¥–µ–≤–µ–ª–æ–ø–µ—Ä–∞–º–∏', '–∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ–π —Å—Ä–µ–¥–æ–π', '–∞–∫—Ç–∏–≤–Ω—ã–º —Ä–∞–∑–≤–∏—Ç–∏–µ–º —Ä–∞–π–æ–Ω–∞']
            ][variation]
            
            why_buy_variants = [
                '–≤—ã–≥–æ–¥–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏ —Ö–æ—Ä–æ—à–∞—è —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å',
                '—Ä–∞–∑–≤–∏—Ç–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏ –±–ª–∏–∑–æ—Å—Ç—å –∫–æ –≤—Å–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º –æ–±—ä–µ–∫—Ç–∞–º',
                '–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–π —Ä–∞–π–æ–Ω —Å –≤—ã—Å–æ–∫–∏–º –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–æ–º',
                '–∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –∂–∏–∑–Ω–∏ –∏ –∞–∫—Ç–∏–≤–Ω–æ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏'
            ][variation]
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            street = {
                'name': street_db.name,
                'slug': street_db.slug,
                'district': '',
                'description': f'{street_type_nominative.capitalize()} {street_db.name} –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ',
                'geometry': street_db.geometry if street_db.geometry else None,
                'geometry_source': street_db.geometry_source if street_db.geometry_source else None,
                'street_type': street_type,
                'street_type_nominative': street_type_nominative,
                'distance_to_center': distance_to_center,
                'location_zone': location_zone,
                'advantages': advantages,
                'why_buy': why_buy_variants
            }
                
            app.logger.debug(f"Found street in database: {street['name']} with coordinates: {coordinates}")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å–≤–æ–π—Å—Ç–≤–∞—Ö –¥–ª—è —ç—Ç–æ–π —É–ª–∏—Ü—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
            properties_on_street = []
            try:
                with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                    properties_data = json.load(f)
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ —É–ª–∏—Ü–µ
                for prop in properties_data:
                    if (street['name'].lower() in prop.get('location', '').lower() or
                        street['name'].lower() in prop.get('full_address', '').lower()):
                        properties_on_street.append(prop)
            except:
                pass
            
            return render_template('street_detail.html',
                                 street=street,
                                 coordinates=coordinates,
                                 properties=properties_on_street,
                                 title=f'{street["name"]} - –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ —Å –∫—ç—à–±–µ–∫–æ–º | InBack',
                                 yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
        else:
            # –ò—â–µ–º –≤ JSON —Ñ–∞–π–ª–µ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
            streets_data = load_streets()
            
            # –ò—â–µ–º —É–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ (—É—á–∏—Ç—ã–≤–∞–µ–º URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ)
            street_name_decoded = street_name.replace('-', ' ').replace('_', ' ')
            street = None
            
            # –õ–æ–≥–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            app.logger.debug(f"Looking for street: {street_name} -> {street_name_decoded}")
        
        # –§—É–Ω–∫—Ü–∏—è —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å—Ç–∞—Ä—ã—Ö URL
        def translit_to_latin(text):
            translit_map = {
                '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
                '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'i', '–∫': 'k', '–ª': 'l', '–º': 'm',
                '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
                '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
            }
            result = ''
            for char in text.lower():
                result += translit_map.get(char, char)
            return result
        
        for s in streets_data:
            # –°–æ–∑–¥–∞–µ–º URL-slug —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –≤ —Ñ–∏–ª—å—Ç—Ä–µ (—Å –∫–∏—Ä–∏–ª–ª–∏—Ü–µ–π)
            street_slug_generated = s['name'].lower().replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–Ω—É—é —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            translit_name = translit_to_latin(s['name'])
            translit_slug = translit_name.replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ —Å–∏–º–≤–æ–ª–æ–≤ (–∫–∞–∫ –±—ã–ª–æ —Ä–∞–Ω—å—à–µ)
            simple_translit = s['name'].lower().replace(' ', '-').replace('.', '').replace('—ë', 'e').replace('–π', 'i').replace('–∞', 'a').replace('–≥', 'g').replace('—Ä', 'r').replace('–∏', 'i').replace('–Ω', 'n').replace('(', '').replace(')', '').replace(',', '')
            
            # –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ–∏—Å–∫–∞
            if (street_slug_generated == street_name.lower() or
                translit_slug == street_name.lower() or
                simple_translit == street_name.lower() or
                s['name'].lower() == street_name_decoded.lower() or
                s['name'].lower().replace(' —É–ª.', '').replace(' —É–ª', '') == street_name_decoded.lower().replace(' —É–ª.', '').replace(' —É–ª', '')):
                street = s
                app.logger.debug(f"Found street: {s['name']} with slug: {street_slug_generated}, translit: {translit_slug}")
                break
        
        if not street:
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            for s in streets_data:
                street_name_clean = street_name_decoded.lower().replace('—É–ª', '').replace('.', '').strip()
                street_db_clean = s['name'].lower().replace('—É–ª.', '').replace('—É–ª', '').replace('.', '').strip()
                
                if (street_name_clean in street_db_clean or 
                    street_db_clean in street_name_clean or
                    street_name_decoded.lower() in s['name'].lower()):
                    street = s
                    app.logger.debug(f"Found street by partial match: {s['name']}")
                    break
        
        if not street:
            app.logger.error(f"Street not found: {street_name} ({street_name_decoded})")
            abort(404)
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        from models import Street
        
        # –ò—â–µ–º —É–ª–∏—Ü—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
        street_db = Street.query.filter_by(name=street['name']).first()
        
        if street_db and street_db.latitude and street_db.longitude:
            coordinates = {
                'lat': float(street_db.latitude),
                'lng': float(street_db.longitude)
            }
        else:
            # –ï—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
            coordinates = {
                'lat': 45.035470,
                'lng': 38.975313
            }
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å–≤–æ–π—Å—Ç–≤–∞—Ö –¥–ª—è —ç—Ç–æ–π —É–ª–∏—Ü—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
        properties_on_street = []
        try:
            with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                properties_data = json.load(f)
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ —É–ª–∏—Ü–µ
            for prop in properties_data:
                if (street['name'].lower() in prop.get('location', '').lower() or
                    street['name'].lower() in prop.get('full_address', '').lower()):
                    properties_on_street.append(prop)
        except:
            pass
        
        return render_template('street_detail.html',
                             street=street,
                             coordinates=coordinates,
                             properties=properties_on_street,
                             title=f'{street["name"]} - –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ —Å –∫—ç—à–±–µ–∫–æ–º | InBack',
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    
    except Exception as e:
        app.logger.error(f"Error loading street detail: {e}")
        abort(404)

@app.route('/sitemap.xml')
def sitemap():
    """Serve static sitemap.xml file"""
    try:
        # –ß–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π sitemap —Ñ–∞–π–ª
        sitemap_path = os.path.join(app.static_folder, 'sitemap.xml')
        
        if os.path.exists(sitemap_path):
            with open(sitemap_path, 'r', encoding='utf-8') as f:
                xml_content = f.read()
            
            response = app.response_class(
                response=xml_content,
                status=200,
                mimetype='application/xml'
            )
            return response
        else:
            # –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π sitemap
            xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://inback.ru/</loc>
    <lastmod>2025-09-06</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>
  <url>
    <loc>https://inback.ru/properties</loc>
    <lastmod>2025-09-06</lastmod>
    <changefreq>daily</changefreq>
    <priority>0.9</priority>
  </url>
</urlset>'''
            
            response = app.response_class(
                response=xml_content,
                status=200,
                mimetype='application/xml'
            )
            return response
        
    except Exception as e:
        app.logger.error(f"Error serving sitemap: {e}")
        abort(500)

@app.route('/google873bf5c5df6b6710.html')
def google_verification():
    """Google Search Console verification file"""
    return 'google-site-verification: google873bf5c5df6b6710.html'

@app.route('/comparison')
@login_required
def comparison():
    """Unified comparison page for properties and complexes"""
    return render_template('comparison.html')

@app.route('/comparison-new')
@login_required
def comparison_new():
    """New improved comparison page for properties and complexes"""
    return render_template('comparison_new.html')

@app.route('/thank-you')
def thank_you():
    """Thank you page after form submission"""
    return render_template('thank_you.html')

@app.route('/api/property/<int:property_id>')
def api_property_detail(property_id):
    """API endpoint to get property data for comparison"""
    property_data = get_property_by_id(property_id)
    
    if not property_data:
        return jsonify({'error': 'Property not found'}), 404
    
    
    # Use cashback_rate from excel_properties (already loaded in property_data)
    cashback_rate = property_data.get('cashback_rate', 5.0)
    
    # Calculate cashback amount using the actual cashback_rate from database
    if property_data.get('price'):
        property_data['cashback'] = round(property_data['price'] * cashback_rate / 100)
    else:
        property_data['cashback'] = 0
    
    # Add fields expected by comparison interface
    property_data['object_min_floor'] = property_data.get('floor')
    property_data['object_max_floor'] = property_data.get('total_floors')
    property_data['complex_name'] = property_data.get('residential_complex')
    
    return jsonify(property_data)

@app.route('/complex-comparison')
def complex_comparison():
    """Complex comparison page"""
    return render_template('complex_comparison.html')


@app.route('/favorites')
def favorites():
    """Favorites page with animated heart pulse effects"""
    return render_template('favorites.html')



@app.route('/robots.txt')
def robots_txt():
    """Robots.txt for search engine crawlers"""
    robots_content = """User-agent: *
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/
Disallow: /dashboard

Sitemap: https://inback.ru/sitemap.xml

# Crawl-delay for better server performance
Crawl-delay: 1

# Specific rules for major search engines
User-agent: Googlebot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Yandex
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Bingbot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/"""
    
    return app.response_class(
        response=robots_content,
        status=200,
        mimetype='text/plain'
    )

# Old blog search function removed - using updated version at bottom of file


@app.route('/api/residential-complexes')
def api_residential_complexes():
    """API endpoint for getting residential complexes for cashback calculator"""
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ù–ê–ü–†–Ø–ú–£–Æ –∏–∑ JSON —Ñ–∞–π–ª–∞, –º–∏–Ω—É—è –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        import json
        import os
        
        residential_complexes_file = 'static/data/residential_complexes.json'
        if not os.path.exists(residential_complexes_file):
            print(f"JSON file not found: {residential_complexes_file}")
            return jsonify({'complexes': []})
        
        with open(residential_complexes_file, 'r', encoding='utf-8') as file:
            json_complexes = json.load(file)
        
        api_complexes = []
        
        for complex in json_complexes:
            # Extract unique name and calculate cashback rate
            complex_name = complex.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ñ–ö')
            cashback_rate = 5.0  # Default rate
            
            # Try to get rate from complex data or calculate based on price
            if 'cashback_rate' in complex:
                cashback_rate = float(complex['cashback_rate'])
            elif complex.get('real_price_from'):
                # Calculate rate based on price range (higher price = lower rate)
                price = complex.get('real_price_from', 5000000)
                if price < 3000000:
                    cashback_rate = 5.0
                elif price < 8000000:
                    cashback_rate = 4.5
                else:
                    cashback_rate = 4.0
            
            api_complexes.append({
                'id': complex.get('id', len(api_complexes) + 1),
                'name': complex_name,
                'cashback_rate': cashback_rate,
                'price_from': complex.get('real_price_from'),
                'district': complex.get('district', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
            })
        
        print(f"API residential-complexes loaded from JSON: {len(api_complexes)} complexes")
        return jsonify({'complexes': api_complexes})
    
    except Exception as e:
        # Load all residential complexes from JSON data
        try:
            complexes = load_residential_complexes()
            api_complexes = []
            
            for complex in complexes:
                # Extract unique name and calculate cashback rate
                complex_name = complex.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ñ–ö')
                cashback_rate = 5.0  # Default rate
                
                # Try to get rate from complex data or calculate based on price
                if 'cashback_rate' in complex:
                    cashback_rate = float(complex['cashback_rate'])
                elif complex.get('real_price_from'):
                    # Calculate rate based on price range (higher price = lower rate)
                    price = complex.get('real_price_from', 5000000)
                    if price < 3000000:
                        cashback_rate = 5.0
                    elif price < 8000000:
                        cashback_rate = 4.5
                    else:
                        cashback_rate = 4.0
                
                api_complexes.append({
                    'id': complex.get('id', len(api_complexes) + 1),
                    'name': complex_name,
                    'cashback_rate': cashback_rate,
                    'price_from': complex.get('real_price_from'),
                    'district': complex.get('district', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
                })
            
            # Remove duplicates by name
            unique_complexes = {}
            for complex in api_complexes:
                name = complex['name']
                if name not in unique_complexes:
                    unique_complexes[name] = complex
            
            return jsonify({'complexes': list(unique_complexes.values())})
        
        except Exception as json_error:
            print(f"Error loading JSON complexes: {json_error}")
            # Final fallback to simple list
            return jsonify({
                'complexes': [
                    {'id': 1, 'name': '–ñ–ö ¬´–õ–µ—Ç–Ω–∏–π¬ª', 'cashback_rate': 5.0},
                    {'id': 2, 'name': '–ñ–ö ¬´–ß–∞–π–Ω—ã–µ —Ö–æ–ª–º—ã¬ª', 'cashback_rate': 4.5},
                    {'id': 3, 'name': '–ñ–ö ¬´–ö–∏—Å–ª–æ—Ä–æ–¥¬ª', 'cashback_rate': 5.0},
                    {'id': 4, 'name': '–ñ–ö ¬´–ì—Ä–∞–Ω–¥ –ö–∞—Å–∫–∞–¥¬ª', 'cashback_rate': 4.0}
                ]
            })

@app.route('/api/residential-complexes-full')
def api_residential_complexes_full():
    """API endpoint for getting all residential complexes from JSON file"""
    complexes = load_residential_complexes()
    return jsonify({'complexes': complexes})

@app.route('/api/cashback/calculate', methods=['POST'])
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_calculate_cashback():
    """API endpoint for calculating cashback"""
    try:
        data = request.get_json()
        price = float(data.get('price', 0))
        complex_id = data.get('complex_id')
        
        if not price or price <= 0:
            return jsonify({'error': 'Invalid price'}), 400
        
        # Get cashback rate from database
        cashback_rate = 5.0  # default
        
        if complex_id:
            try:
                # –ò—â–µ–º –∫–æ–º–ø–ª–µ–∫—Å –≤ JSON –¥–∞–Ω–Ω—ã—Ö
                import json
                import os
                
                residential_complexes_file = 'static/data/residential_complexes.json'
                if os.path.exists(residential_complexes_file):
                    with open(residential_complexes_file, 'r', encoding='utf-8') as file:
                        json_complexes = json.load(file)
                    
                    for complex in json_complexes:
                        if str(complex.get('id')) == str(complex_id):
                            if 'cashback_rate' in complex:
                                cashback_rate = float(complex['cashback_rate'])
                            elif complex.get('real_price_from'):
                                # Calculate rate based on price range
                                complex_price = complex.get('real_price_from', 5000000)
                                if complex_price < 3000000:
                                    cashback_rate = 5.0
                                elif complex_price < 8000000:
                                    cashback_rate = 4.5
                                else:
                                    cashback_rate = 4.0
                            break
                            
                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ JSON, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback —Å—Ç–∞–≤–∫–∏ –ø–æ ID
            except:
                # Fallback rates
                complex_rates = {
                    1: 5.5, 2: 6.0, 3: 7.0, 4: 5.0,
                    5: 6.5, 6: 5.5, 7: 7.5, 8: 8.0
                }
                cashback_rate = complex_rates.get(int(complex_id), 5.0)
        
        cashback_amount = price * (cashback_rate / 100)
        
        # Cap at maximum
        max_cashback = 500000
        if cashback_amount > max_cashback:
            cashback_amount = max_cashback
        
        return jsonify({
            'cashback_amount': int(cashback_amount),
            'cashback_rate': cashback_rate,
            'price': int(price),
            'formatted_amount': f"{int(cashback_amount):,}".replace(',', ' ')
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/cashback/apply', methods=['POST'])
@login_required
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_apply_cashback():
    """API endpoint for submitting cashback application"""
    try:
        from models import CashbackApplication, UserActivity, CallbackRequest
        
        data = request.get_json()
        if not data:
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
            
        price = data.get('price')
        complex_id = data.get('complex_id')  # –ú–æ–∂–µ—Ç –±—ã—Ç—å null –¥–ª—è –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞
        complex_name = data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')
        cashback_amount = data.get('cashback_amount')
        cashback_rate = data.get('cashback_rate', 2.5)
        user_phone = data.get('phone', '')
        user_name = data.get('name', '')
        
        # Validate required fields (complex_id –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω)
        if not all([price, cashback_amount, user_phone, user_name]):
            return jsonify({'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Validate data types
        try:
            price = float(price)
            cashback_amount = float(cashback_amount)
            cashback_rate = float(cashback_rate)
        except (ValueError, TypeError):
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        # Create cashback application
        cashback_app = CashbackApplication(
            user_id=current_user.id,
            property_name=f"–ö–≤–∞—Ä—Ç–∏—Ä–∞ –≤ {complex_name}",
            property_type="–ö–≤–∞—Ä—Ç–∏—Ä–∞",
            property_size=50.0,  # Default size, can be improved later
            property_price=int(price),
            complex_name=complex_name,
            developer_name=data.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
            cashback_amount=int(cashback_amount),
            cashback_percent=cashback_rate,
            status='–í –æ–±—Ä–∞–±–æ—Ç–∫–µ'
        )
        
        db.session.add(cashback_app)
        
        # Record user activity
        UserActivity.log_activity(
            user_id=current_user.id,
            activity_type='cashback_application',
            description=f'–ü–æ–¥–∞–Ω–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ {int(cashback_amount):,} ‚ÇΩ –ø–æ –æ–±—ä–µ–∫—Ç—É –≤ {complex_name}'.replace(',', ' '),
            complex_id=complex_id
        )
        
        # Create callback request for manager
        callback = CallbackRequest(
            name=user_name,
            phone=user_phone,
            notes=f"–ó–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ {int(cashback_amount):,} ‚ÇΩ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –≤ {complex_name} —Å—Ç–æ–∏–º–æ—Å—Ç—å—é {int(price):,} ‚ÇΩ".replace(',', ' ')
        )
        
        db.session.add(callback)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.'
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏: {str(e)}'}), 500

@app.route('/api/image-proxy')
def image_proxy():
    """
    Proxy endpoint to serve images with watermark cropped out
    Usage: /api/image-proxy?url=<image_url>&crop=<percent>
    """
    image_url = request.args.get('url')
    crop_percent = request.args.get('crop', '8')  # Default 8%
    
    if not image_url:
        return jsonify({'error': 'No image URL provided'}), 400
    
    try:
        crop_percent = int(crop_percent)
        
        # Crop watermark from image
        cropped_img = crop_watermark(image_url, crop_bottom_percent=crop_percent)
        
        if cropped_img is None:
            # If cropping failed, redirect to original image
            return redirect(image_url)
        
        # Convert to bytes
        img_io = io.BytesIO()
        cropped_img.save(img_io, format='JPEG', quality=90, optimize=True)
        img_io.seek(0)
        
        # Return image with caching headers
        response = make_response(send_file(img_io, mimetype='image/jpeg'))
        response.headers['Cache-Control'] = 'public, max-age=2592000'  # Cache for 30 days
        response.headers['X-Content-Type-Options'] = 'nosniff'
        
        return response
        
    except Exception as e:
        print(f"Error in image proxy: {e}")
        # Fallback to original image on error
        return redirect(image_url)

@app.route('/api/search/suggestions')
def search_suggestions():
    """API endpoint for search suggestions (autocomplete) - REAL DATABASE VERSION"""
    query = request.args.get('query', request.args.get('q', '')).lower().strip()
    if not query or len(query) < 2:
        return jsonify([])
    
    suggestions = []
    
    try:
        # 1. Search by room types (PRIORITY - user's main request)
        room_suggestions = {
            '—Å—Ç—É–¥': '–°—Ç—É–¥–∏—è',
            '1-–∫': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '1-–∫–æ–º': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è', 
            '1 –∫': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '–æ–¥–Ω': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2-–∫': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2-–∫–æ–º': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2 –∫': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è', 
            '–¥–≤—É—Ö': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3-–∫': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3-–∫–æ–º': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3 –∫': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—Ç—Ä–µ—Ö': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—Ç—Ä—ë—Ö': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4-–∫': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4-–∫–æ–º': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—á–µ—Ç—ã—Ä': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è'
        }
        
        for pattern, room_type in room_suggestions.items():
            if pattern in query:
                # Count real properties by room type - use ALL available fields
                if '—Å—Ç—É–¥' in pattern:
                    count = db.session.execute(text("""
                        SELECT COUNT(*) FROM excel_properties 
                        WHERE object_rooms = 0
                    """)).scalar()
                else:
                    room_num = room_type.split('-')[0] if '-' in room_type else '1'
                    count = db.session.execute(text("""
                        SELECT COUNT(*) FROM excel_properties 
                        WHERE object_rooms = :room_num
                    """), {'room_num': int(room_num)}).scalar()
                
                # –°–æ–∑–¥–∞–µ–º URL —Å —Ç–µ–º –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º —á—Ç–æ –±—ã—Å—Ç—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
                if '—Å—Ç—É–¥' in pattern:
                    room_param = '0'
                else:
                    room_param = room_type.split('-')[0] if '-' in room_type else '1'
                
                suggestions.append({
                    'type': 'room_type', 
                    'text': room_type,
                    'title': room_type,  # –î–æ–±–∞–≤–ª—è–µ–º title –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    'subtitle': f'–ù–∞–π–¥–µ–Ω–æ {count} –∫–≤–∞—Ä—Ç–∏—Ä',
                    'url': url_for('properties', rooms=room_param)  # rooms=1 –∫–∞–∫ –±—ã—Å—Ç—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
                })
        
        # 2. Search in REAL residential complexes from database (using correct field names)
        complexes_query = db.session.execute(text("""
            SELECT DISTINCT complex_name, COUNT(*) as count
            FROM excel_properties 
            WHERE LOWER(complex_name) LIKE :query 
            AND complex_name IS NOT NULL
            AND complex_name != ''
            GROUP BY complex_name
            ORDER BY count DESC
            LIMIT 5
        """), {'query': f'%{query}%'}).fetchall()
        
        for row in complexes_query:
            if row[0] and len(row[0]) > 2:  # Skip empty/short names
                suggestions.append({
                    'type': 'complex',
                    'text': row[0],
                    'subtitle': f'{row[1]} –∫–≤–∞—Ä—Ç–∏—Ä –¥–æ—Å—Ç—É–ø–Ω–æ',
                    'url': url_for('properties', complex=row[0])
                })
        
        # 3. Search in REAL developers from database
        developers_query = db.session.execute(text("""
            SELECT DISTINCT developer_name, COUNT(*) as count
            FROM excel_properties 
            WHERE LOWER(developer_name) LIKE :query 
            AND developer_name IS NOT NULL
            GROUP BY developer_name
            ORDER BY count DESC
            LIMIT 3
        """), {'query': f'%{query}%'}).fetchall()
        
        for row in developers_query:
            if row[0] and len(row[0]) > 2:
                suggestions.append({
                    'type': 'developer',
                    'text': row[0],
                    'subtitle': f'–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ ‚Ä¢ {row[1]} –ø—Ä–æ–µ–∫—Ç–æ–≤',
                    'url': url_for('properties', developer=row[0])
                })
        
        # 4. Search in districts
        districts_query = db.session.execute(text("""
            SELECT DISTINCT parsed_district, COUNT(*) as count
            FROM excel_properties 
            WHERE LOWER(parsed_district) LIKE :query 
            AND parsed_district IS NOT NULL
            GROUP BY parsed_district
            ORDER BY count DESC
            LIMIT 3
        """), {'query': f'%{query}%'}).fetchall()
        
        for row in districts_query:
            if row[0] and '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π' not in row[0]:  # Skip generic region name
                clean_district = row[0].replace('–†–æ—Å—Å–∏—è, ', '').replace('–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, ', '')
                suggestions.append({
                    'type': 'district',
                    'text': clean_district,
                    'subtitle': f'{row[1]} –∫–≤–∞—Ä—Ç–∏—Ä –≤ —Ä–∞–π–æ–Ω–µ',
                    'url': url_for('properties', district=clean_district)
                })
        
        # Sort by relevance (room types first, then exact matches)
        suggestions.sort(key=lambda x: (
            0 if x['type'] == 'room_type' else 1,
            0 if x['text'].lower().startswith(query) else 1,
            len(x['text'])
        ))
        
        return jsonify(suggestions[:8])  # Return top 8 suggestions
        
    except Exception as e:
        app.logger.error(f"Error in search suggestions: {e}")
        return jsonify([])

# Mortgage routes
@app.route('/ipoteka')
def ipoteka():
    """Main mortgage page"""
    return render_template('ipoteka.html')

@app.route('/family-mortgage')
def family_mortgage():
    """Family mortgage page"""
    return render_template('family_mortgage.html')

@app.route('/it-mortgage')
def it_mortgage():
    """IT mortgage page"""
    return render_template('it_mortgage.html')

@app.route('/insurance')
def insurance():
    """Insurance page"""
    return render_template('insurance.html')

@app.route('/submit-insurance-application', methods=['POST'])
def submit_insurance_application():
    """Submit insurance application with CSRF protection and enhanced validation"""
    try:
        # Validate CSRF token for form submissions
        try:
            validate_csrf(request.form.get('csrf_token'))
        except Exception:
            return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        
        # Get form data
        name = request.form.get('name', '').strip()
        phone = request.form.get('phone', '').strip()
        bank = request.form.get('bank', '').strip()
        credit_amount = request.form.get('credit_amount', '').strip()
        birth_date = request.form.get('birth_date', '').strip()
        gender = request.form.get('gender', '').strip()
        comment = request.form.get('comment', '').strip()
        
        # Enhanced validation for required fields
        if not all([name, phone, bank, credit_amount, birth_date, gender]):
            return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Validate name (2-50 characters, only letters and spaces)
        if not re.match(r'^[–∞-—è–ê-–Ø—ë–Åa-zA-Z\s]{2,50}$', name):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è'}), 400
        
        # Validate phone (Russian phone number format)
        phone_clean = re.sub(r'[^\d]', '', phone)
        if not re.match(r'^[78]\d{10}$', phone_clean):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'}), 400
        
        # Validate credit amount (numeric, reasonable range)
        try:
            credit_amount_num = float(re.sub(r'[^\d.]', '', credit_amount))
            if credit_amount_num < 100000 or credit_amount_num > 50000000:
                return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫—Ä–µ–¥–∏—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 100 000 –¥–æ 50 000 000 —Ä—É–±–ª–µ–π'}), 400
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞ –∫—Ä–µ–¥–∏—Ç–∞'}), 400
        
        # Validate birth date
        try:
            from datetime import datetime
            birth_dt = datetime.strptime(birth_date, '%Y-%m-%d')
            age = (datetime.now() - birth_dt).days / 365.25
            if age < 18 or age > 100:
                return jsonify({'success': False, 'error': '–í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 18 –¥–æ 100 –ª–µ—Ç'}), 400
        except ValueError:
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è'}), 400
        
        # Validate gender
        if gender not in ['–ú—É–∂—á–∏–Ω–∞', '–ñ–µ–Ω—â–∏–Ω–∞']:
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–ª'}), 400
        
        # Format credit amount for display
        try:
            credit_amount_num = int(credit_amount)
            credit_amount_formatted = f"{credit_amount_num:,}".replace(",", " ") + " ‚ÇΩ"
        except:
            credit_amount_formatted = credit_amount + " ‚ÇΩ"
        
        # Dual notification: send to both email and Telegram
        current_time = datetime.now().strftime('%d.%m.%Y %H:%M')
        
        # Send email notification
        email_success = False
        try:
            email_success = send_email(
                'bithome@mail.ru', 
                f'–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –æ—Ç {name}', 
                'emails/insurance_application.html', 
                name=name, 
                phone=phone, 
                bank=bank, 
                credit_amount=credit_amount_formatted, 
                birth_date=birth_date, 
                gender=gender, 
                comment=comment, 
                submitted_at=datetime.now(),
                current_time=current_time
            )
        except Exception as email_error:
            app.logger.error(f"Error sending insurance application email: {email_error}")
        
        # Send Telegram notification
        telegram_success = False
        try:
            from email_service import send_telegram_insurance_notification
            telegram_success = send_telegram_insurance_notification(
                name=name,
                phone=phone,
                bank=bank,
                credit_amount=credit_amount_formatted,
                birth_date=birth_date,
                gender=gender,
                comment=comment,
                current_time=current_time
            )
        except Exception as telegram_error:
            app.logger.error(f"Error sending insurance application Telegram: {telegram_error}")
        
        # Determine response based on both results
        if email_success and telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email –∏ –≤ Telegram'})
        elif email_success and not telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Telegram', 'warning': True})
        elif not email_success and telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ email', 'warning': True})
        else:
            return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏ –∏ –Ω–∞ email, –∏ –≤ Telegram'}), 500
            
    except Exception as e:
        app.logger.error(f"Error in insurance application: {e}")
        return jsonify({'success': False, 'error': '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'}), 500

@app.route('/api/check-it-company', methods=['POST'])
@csrf.exempt
def check_it_company():
    """Check if company is in IT companies list by INN or company name"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏'}), 400
            
        inn = data.get('inn', '').strip()
        company_name = data.get('company_name', '').strip()
        
        if not inn and not company_name:
            return jsonify({'error': '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –ò–ù–ù –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏'}), 400
        
        # –ü–æ–∏—Å–∫ –ø–æ –ò–ù–ù
        if inn:
            try:
                inn_int = int(inn)
                company = db.session.execute(text("""
                    SELECT inn, name FROM it_companies 
                    WHERE inn = :inn LIMIT 1
                """), {'inn': inn_int}).fetchone()
                
                if company:
                    return jsonify({
                        'found': True,
                        'inn': company[0],
                        'company_name': company[1],
                        'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π'
                    })
            except ValueError:
                pass
        
        # –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–æ–º–ø–∞–Ω–∏–∏ (—á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
        if company_name:
            company = db.session.execute(text("""
                SELECT inn, name FROM it_companies 
                WHERE LOWER(name) LIKE LOWER(:company_name) 
                LIMIT 1
            """), {'company_name': f'%{company_name}%'}).fetchone()
            
            if company:
                return jsonify({
                    'found': True,
                    'inn': company[0],
                    'company_name': company[1],
                    'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π'
                })
        
        return jsonify({
            'found': False,
            'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ò–ù–ù –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–ø–∞–Ω–∏–∏.'
        })
        
    except Exception as e:
        print(f"Error checking IT company: {e}")
        return jsonify({'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–º–ø–∞–Ω–∏–∏'}), 500

@app.route('/api/suggest-it-companies', methods=['POST'])
@csrf.exempt
def suggest_it_companies():
    """Get IT company suggestions for autocomplete"""
    try:
        data = request.get_json()
        query = data.get('query', '').strip().lower()
        
        if len(query) < 2:
            return jsonify({'suggestions': []})
            
        # Search for companies matching the query
        suggestions = db.session.execute(text("""
            SELECT DISTINCT name FROM it_companies 
            WHERE LOWER(name) LIKE :query 
            ORDER BY name 
            LIMIT 10
        """), {'query': f'%{query}%'}).fetchall()
        
        return jsonify({
            'suggestions': [suggestion[0] for suggestion in suggestions]
        })
        
    except Exception as e:
        print(f"Error in suggest_it_companies: {str(e)}")
        return jsonify({'suggestions': []})

@app.route('/api/detect-city', methods=['GET'])
@csrf.exempt
def detect_city():
    """Detect user's city by IP address using ipwhois.io API"""
    
    # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç—Ä–∞–Ω—Å–ª–∏—Ç–∞ –≥–æ—Ä–æ–¥–æ–≤ –≤ —Ä—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è
    city_translations = {
        'Krasnodar': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
        'Moscow': '–ú–æ—Å–∫–≤–∞',
        'Saint Petersburg': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
        'Novosibirsk': '–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫',
        'Yekaterinburg': '–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥',
        'Nizhny Novgorod': '–ù–∏–∂–Ω–∏–π –ù–æ–≤–≥–æ—Ä–æ–¥',
        'Kazan': '–ö–∞–∑–∞–Ω—å',
        'Chelyabinsk': '–ß–µ–ª—è–±–∏–Ω—Å–∫',
        'Omsk': '–û–º—Å–∫',
        'Samara': '–°–∞–º–∞—Ä–∞',
        'Rostov-on-Don': '–†–æ—Å—Ç–æ–≤-–Ω–∞-–î–æ–Ω—É',
        'Ufa': '–£—Ñ–∞',
        'Krasnoyarsk': '–ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫',
        'Voronezh': '–í–æ—Ä–æ–Ω–µ–∂',
        'Perm': '–ü–µ—Ä–º—å',
        'Volgograd': '–í–æ–ª–≥–æ–≥—Ä–∞–¥',
        'Saratov': '–°–∞—Ä–∞—Ç–æ–≤',
        'Tyumen': '–¢—é–º–µ–Ω—å',
        'Tolyatti': '–¢–æ–ª—å—è—Ç—Ç–∏',
        'Izhevsk': '–ò–∂–µ–≤—Å–∫',
        'Barnaul': '–ë–∞—Ä–Ω–∞—É–ª',
        'Ulyanovsk': '–£–ª—å—è–Ω–æ–≤—Å–∫',
        'Irkutsk': '–ò—Ä–∫—É—Ç—Å–∫',
        'Khabarovsk': '–•–∞–±–∞—Ä–æ–≤—Å–∫',
        'Yaroslavl': '–Ø—Ä–æ—Å–ª–∞–≤–ª—å',
        'Vladivostok': '–í–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫',
        'Makhachkala': '–ú–∞—Ö–∞—á–∫–∞–ª–∞',
        'Tomsk': '–¢–æ–º—Å–∫',
        'Orenburg': '–û—Ä–µ–Ω–±—É—Ä–≥',
        'Kemerovo': '–ö–µ–º–µ—Ä–æ–≤–æ',
        'Novokuznetsk': '–ù–æ–≤–æ–∫—É–∑–Ω–µ—Ü–∫',
        'Ryazan': '–†—è–∑–∞–Ω—å',
        'Astrakhan': '–ê—Å—Ç—Ä–∞—Ö–∞–Ω—å',
        'Naberezhnye Chelny': '–ù–∞–±–µ—Ä–µ–∂–Ω—ã–µ –ß–µ–ª–Ω—ã',
        'Penza': '–ü–µ–Ω–∑–∞',
        'Lipetsk': '–õ–∏–ø–µ—Ü–∫',
        'Kirov': '–ö–∏—Ä–æ–≤',
        'Cheboksary': '–ß–µ–±–æ–∫—Å–∞—Ä—ã',
        'Kaliningrad': '–ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥',
        'Tula': '–¢—É–ª–∞',
        'Kursk': '–ö—É—Ä—Å–∫',
        'Sochi': '–°–æ—á–∏',
        'Stavropol': '–°—Ç–∞–≤—Ä–æ–ø–æ–ª—å',
        'Ulan-Ude': '–£–ª–∞–Ω-–£–¥—ç',
        'Tver': '–¢–≤–µ—Ä—å',
        'Magnitogorsk': '–ú–∞–≥–Ω–∏—Ç–æ–≥–æ—Ä—Å–∫',
        'Bryansk': '–ë—Ä—è–Ω—Å–∫',
        'Ivanovo': '–ò–≤–∞–Ω–æ–≤–æ',
        'Belgorod': '–ë–µ–ª–≥–æ—Ä–æ–¥'
    }
    
    # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä–µ–≥–∏–æ–Ω–æ–≤
    region_translations = {
        'Krasnodar Krai': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
        'Krasnodar Territory': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
        'Moscow': '–ú–æ—Å–∫–≤–∞',
        'Saint Petersburg': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
        'Moscow Oblast': '–ú–æ—Å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Sverdlovsk Oblast': '–°–≤–µ—Ä–¥–ª–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Novosibirsk Oblast': '–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Rostov Oblast': '–†–æ—Å—Ç–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Tatarstan': '–†–µ—Å–ø—É–±–ª–∏–∫–∞ –¢–∞—Ç–∞—Ä—Å—Ç–∞–Ω',
        'Bashkortostan': '–†–µ—Å–ø—É–±–ª–∏–∫–∞ –ë–∞—à–∫–æ—Ä—Ç–æ—Å—Ç–∞–Ω',
        'Chelyabinsk Oblast': '–ß–µ–ª—è–±–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å'
    }
    
    try:
        # Get user's IP address from request
        user_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ',' in user_ip:
            user_ip = user_ip.split(',')[0].strip()
        
        # Skip localhost/private IPs
        if user_ip in ['127.0.0.1', 'localhost', '::1'] or user_ip.startswith('192.168.') or user_ip.startswith('10.'):
            return jsonify({
                'success': True,
                'city': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'country': '–†–æ—Å—Å–∏—è',
                'detected': False,
                'message': '–õ–æ–∫–∞–ª—å–Ω—ã–π IP, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≥–æ—Ä–æ–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é'
            })
        
        # Use ipwhois.io API (free, no API key required, 10,000 requests/month)
        api_url = f'http://ipwho.is/{user_ip}'
        response = requests.get(api_url, timeout=3)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get('success', False):
                city_en = data.get('city', 'Krasnodar')
                region_en = data.get('region', 'Krasnodar Krai')
                
                # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≥–æ—Ä–æ–¥ –∏ —Ä–µ–≥–∏–æ–Ω –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                city = city_translations.get(city_en, city_en if not city_en else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
                region = region_translations.get(region_en, region_en if not region_en else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π')
                
                return jsonify({
                    'success': True,
                    'city': city,
                    'region': region,
                    'country': '–†–æ—Å—Å–∏—è',
                    'detected': True,
                    'ip': user_ip
                })
        
        # Fallback to default city
        return jsonify({
            'success': True,
            'city': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
            'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
            'country': '–†–æ—Å—Å–∏—è',
            'detected': False,
            'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥–æ—Ä–æ–¥, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≥–æ—Ä–æ–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é'
        })
        
    except Exception as e:
        print(f"Error detecting city: {e}")
        return jsonify({
            'success': True,
            'city': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
            'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
            'country': '–†–æ—Å—Å–∏—è',
            'detected': False,
            'error': str(e)
        })

@app.route('/military-mortgage')
def military_mortgage():
    """Military mortgage page"""
    return render_template('military_mortgage.html')

@app.route('/developer-mortgage')
def developer_mortgage():
    """Developer mortgage page"""
    return render_template('developer_mortgage.html')

@app.route('/maternal-capital')
def maternal_capital():
    """Maternal capital page"""
    return render_template('maternal_capital.html')

@app.route('/tax-deduction')
def tax_deduction():
    """Tax deduction page"""
    return render_template('tax_deduction.html')

@app.route('/residential')
def residential():
    """Residential complexes page"""
    return render_template('residential.html')

@app.route('/residential-complexes')
# –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º –∫—ç—à –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
def residential_complexes():
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö 
        # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏ + —Ä–µ–∞–ª—å–Ω—ã–µ ID –∏–∑ residential_complexes
        try:
            complexes_query = db.session.execute(text("""
                SELECT 
                    ep.complex_name,
                    COUNT(*) as apartments_count,
                    MIN(ep.price) as price_from,
                    MAX(ep.price) as price_to,
                    MIN(ep.object_area) as area_from,
                    MAX(ep.object_area) as area_to,
                    MIN(ep.object_min_floor) as floors_min,
                    MAX(ep.object_max_floor) as floors_max,
                    MAX(ep.developer_name) as developer_name,
                    MAX(ep.address_display_name) as address_display_name,
                    MAX(ep.complex_sales_address) as complex_sales_address,
                    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞—Ç—ã –∫–æ—Ä–ø—É—Å–æ–≤ –≤–º–µ—Å—Ç–æ –æ–±—â–∏—Ö –¥–∞—Ç –ñ–ö
                    MAX(ep.complex_building_end_build_year) as end_build_year,
                    MAX(ep.complex_building_end_build_quarter) as end_build_quarter,
                    (SELECT photos FROM excel_properties p2 
                     WHERE p2.complex_name = ep.complex_name 
                     AND p2.photos IS NOT NULL 
                     ORDER BY p2.price DESC LIMIT 1) as photos,
                    COALESCE(rc.id, ROW_NUMBER() OVER (ORDER BY ep.complex_name) + 1000) as real_id,
                    CASE 
                        WHEN COUNT(DISTINCT ep.complex_building_id) > 0 
                        THEN COUNT(DISTINCT ep.complex_building_id)
                        WHEN COUNT(DISTINCT NULLIF(ep.complex_building_name, '')) > 0 
                        THEN COUNT(DISTINCT NULLIF(ep.complex_building_name, ''))
                        ELSE GREATEST(1, CEIL(COUNT(*) / 3.0))  -- –ü—Ä–∏–º–µ—Ä–Ω–æ 3 –∫–≤–∞—Ä—Ç–∏—Ä—ã –Ω–∞ –∫–æ—Ä–ø—É—Å –¥–ª—è –ª—É—á—à–µ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
                    END as buildings_count,
                    MAX(ep.complex_object_class_display_name) as object_class_display_name,
                    COALESCE(MAX(rc.cashback_rate), 5.0) as cashback_rate
                FROM excel_properties ep
                LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
                GROUP BY ep.complex_name, rc.id
                ORDER BY 
                    -- –ñ–ö "IV –∫–≤. 2025 –≥. –°—Ç—Ä–æ–∏—Ç—Å—è" –≤—Å–µ–≥–¥–∞ –≤–Ω–∏–∑—É
                    CASE 
                        WHEN MAX(ep.complex_building_end_build_year) = 2025 
                        AND MAX(ep.complex_building_end_build_quarter) = 4 
                        THEN 1  -- "IV –∫–≤. 2025 –≥. –°—Ç—Ä–æ–∏—Ç—Å—è" –≤ –∫–æ–Ω—Ü–µ
                        ELSE 0  -- –û—Å—Ç–∞–ª—å–Ω—ã–µ –ñ–ö —Å–Ω–∞—á–∞–ª–∞
                    END,
                    ep.complex_name
            """))
            
            complexes_data = complexes_query.fetchall()
        except Exception as e:
            print(f"Database error loading complexes: {e}")
            # Fallback to basic query without photos
            complexes_query = db.session.execute(text("""
                SELECT 
                    ep.complex_name,
                    COUNT(*) as apartments_count,
                    MIN(ep.price) as price_from,
                    MAX(ep.price) as price_to,
                    MIN(ep.object_area) as area_from,
                    MAX(ep.object_area) as area_to,
                    MIN(ep.object_min_floor) as floors_min,
                    MAX(ep.object_max_floor) as floors_max,
                    MAX(ep.developer_name) as developer_name,
                    MAX(ep.address_display_name) as address_display_name,
                    MAX(ep.complex_sales_address) as complex_sales_address,
                    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞—Ç—ã –∫–æ—Ä–ø—É—Å–æ–≤ –≤–º–µ—Å—Ç–æ –æ–±—â–∏—Ö –¥–∞—Ç –ñ–ö
                    MAX(ep.complex_building_end_build_year) as end_build_year,
                    MAX(ep.complex_building_end_build_quarter) as end_build_quarter,
                    NULL as photos,
                    COALESCE(rc.id, ROW_NUMBER() OVER (ORDER BY ep.complex_name) + 1000) as real_id,
                    CASE 
                        WHEN COUNT(DISTINCT ep.complex_building_id) > 0 
                        THEN COUNT(DISTINCT ep.complex_building_id)
                        WHEN COUNT(DISTINCT NULLIF(ep.complex_building_name, '')) > 0 
                        THEN COUNT(DISTINCT NULLIF(ep.complex_building_name, ''))
                        ELSE GREATEST(1, CEIL(COUNT(*) / 3.0))  -- –ü—Ä–∏–º–µ—Ä–Ω–æ 3 –∫–≤–∞—Ä—Ç–∏—Ä—ã –Ω–∞ –∫–æ—Ä–ø—É—Å –¥–ª—è –ª—É—á—à–µ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
                    END as buildings_count,
                    MAX(ep.complex_object_class_display_name) as object_class_display_name,
                    COALESCE(MAX(rc.cashback_rate), 5.0) as cashback_rate
                FROM excel_properties ep
                LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
                GROUP BY ep.complex_name, rc.id
                ORDER BY 
                    -- –ñ–ö "IV –∫–≤. 2025 –≥. –°—Ç—Ä–æ–∏—Ç—Å—è" –≤—Å–µ–≥–¥–∞ –≤–Ω–∏–∑—É
                    CASE 
                        WHEN MAX(ep.complex_building_end_build_year) = 2025 
                        AND MAX(ep.complex_building_end_build_quarter) = 4 
                        THEN 1  -- "IV –∫–≤. 2025 –≥. –°—Ç—Ä–æ–∏—Ç—Å—è" –≤ –∫–æ–Ω—Ü–µ
                        ELSE 0  -- –û—Å—Ç–∞–ª—å–Ω—ã–µ –ñ–ö —Å–Ω–∞—á–∞–ª–∞
                    END,
                    ep.complex_name
            """))
            complexes_data = complexes_query.fetchall()
        
        complexes = []
        
        for idx, row in enumerate(complexes_data):
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å—Ä–æ–∫ —Å–¥–∞—á–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            is_completed = False
            
            from datetime import datetime
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
            current_year = 2025  # –ú—ã –≤ 2025 –≥–æ–¥—É
            current_quarter = 4   # –¢–µ–∫—É—â–∏–π –∫–≤–∞—Ä—Ç–∞–ª (—Å–µ–Ω—Ç—è–±—Ä—å = 4-–π –∫–≤–∞—Ä—Ç–∞–ª - –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
            
            if row[11] and row[12]:  # end_build_year –∏ end_build_quarter
                build_year = int(row[11])
                build_quarter = int(row[12])
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–¥–∞–Ω –ª–∏ –∫–æ–º–ø–ª–µ–∫—Å (–±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∞—è –ª–æ–≥–∏–∫–∞)
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                else:
                    is_completed = False  # –¢–µ–∫—É—â–∏–π –∏–ª–∏ –±—É–¥—É—â–∏–π –∫–≤–∞—Ä—Ç–∞–ª - –µ—â–µ —Å—Ç—Ä–æ–∏—Ç—Å—è
                    
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} –∫–≤. {build_year} –≥."
            elif row[11]:  # —Ç–æ–ª—å–∫–æ –≥–æ–¥
                build_year = int(row[11])
                is_completed = build_year < current_year  # –°—Ç—Ä–æ–≥–æ –º–µ–Ω—å—à–µ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                completion_date = f"{build_year} –≥."
            
            complex_dict = {
                'id': row[14],  # real_id from database
                'name': row[0],
                'available_apartments': row[1],
                'price_from': row[2] or 0,
                'price_to': row[3] or 0,
                'real_price_from': row[2] or 0,
                'real_price_to': row[3] or 0,
                'area_from': row[4] or 0,
                'area_to': row[5] or 0,
                'real_area_from': row[4] or 0,
                'real_area_to': row[5] or 0,
                'floors_min': row[6] or 1,
                'floors_max': row[7] or 25,
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'developer': row[8] or '–ù–µ —É–∫–∞–∑–∞–Ω',
                'address': row[9] or row[10] or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                'full_address': row[10] or row[9] or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                'location': row[9] or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                'completion_date': completion_date,
                'buildings_count': row[15] if len(row) > 15 else 1,  # –†–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ—Ä–ø—É—Å–æ–≤ –∏–∑ Excel
                'is_completed': is_completed,
                'status': '–°–¥–∞–Ω' if is_completed else '–°—Ç—Ä–æ–∏—Ç—Å—è',
                'object_class': row[16] if len(row) > 16 and row[16] else '–ö–æ–º—Ñ–æ—Ä—Ç',  # –∫–ª–∞—Å—Å –∂–∏–ª—å—è –∏–∑ –±–∞–∑—ã
                'housing_class': row[16] if len(row) > 16 and row[16] else '–ö–æ–º—Ñ–æ—Ä—Ç',  # –¥—É–±–ª–∏—Ä—É–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                'max_floors': row[7] or 25,  # —ç—Ç–∞–∂–Ω–æ—Å—Ç—å = floors_max
                'floors': row[7] or 25,  # –¥—É–±–ª–∏—Ä—É–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                'completion_year': build_year if 'build_year' in locals() else 2025,
                'cashback_rate': row[17] if len(row) > 17 else 5.0  # –†–µ–∞–ª—å–Ω—ã–π % –∫—ç—à–±–µ–∫–∞ –∏–∑ residential_complexes
            }
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –¥–ª—è –ñ–ö –∏–∑ —Å–∞–º–æ–π –¥–æ—Ä–æ–≥–æ–π –∫–≤–∞—Ä—Ç–∏—Ä—ã (–∫–∞–∫ —Ä–µ–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ç–∏–≤–Ω—ã–µ –¥–ª—è –ñ–ö)
            try:
                photos_query = db.session.execute(text("""
                    SELECT photos FROM excel_properties 
                    WHERE complex_name = :complex_name 
                    AND photos IS NOT NULL 
                    ORDER BY price DESC, object_area DESC
                    LIMIT 1
                """), {'complex_name': complex_dict['name']})
                
                photos_row = photos_query.fetchone()
                if photos_row and photos_row[0]:
                    try:
                        photos_raw = photos_row[0]
                        # –ü–∞—Ä—Å–∏–º PostgreSQL array —Ñ–æ—Ä–º–∞—Ç {url1,url2,url3}
                        if photos_raw.startswith('{') and photos_raw.endswith('}'):
                            photos_clean = photos_raw[1:-1]  # —É–±–∏—Ä–∞–µ–º { –∏ }
                            if photos_clean:
                                photos_list = [url.strip() for url in photos_clean.split(',')]
                        else:
                            # –ï—Å–ª–∏ —ç—Ç–æ JSON —Ñ–æ—Ä–º–∞—Ç, –ø–∞—Ä—Å–∏–º –∫–∞–∫ JSON
                            import json
                            photos_list = json.loads(photos_raw)
                        
                        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ —Ñ–æ—Ç–æ (–∏–Ω—Ç–µ—Ä—å–µ—Ä—ã –∫–≤–∞—Ä—Ç–∏—Ä) –∏ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö
                        start_index = min(len(photos_list) // 4, 5) if len(photos_list) > 8 else 1
                        complex_dict['image'] = photos_list[start_index] if len(photos_list) > start_index else photos_list[0]
                        # –î–ª—è —Å–ª–∞–π–¥–µ—Ä–∞ –±–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–µ –∏–Ω—Ç–µ—Ä—å–µ—Ä—ã)
                        complex_dict['images'] = photos_list[start_index:] if len(photos_list) > start_index else photos_list
                    except Exception as e:
                        print(f"Error parsing photos for complex {complex_dict['name']}: {e}")
                        complex_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + complex_dict['name'].replace(' ', '+')
                        complex_dict['images'] = []
                else:
                    complex_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + complex_dict['name']
                    complex_dict['images'] = []
            except Exception as e:
                print(f"Database error loading photos for complex {complex_dict['name']}: {e}")
                complex_dict['image'] = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + complex_dict['name'].replace(' ', '+')
                complex_dict['images'] = []
                
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
            try:
                rooms_query = db.session.execute(text("""
                    SELECT 
                        object_rooms,
                        COUNT(*) as count,
                        MIN(object_area) as min_area,
                        MAX(object_area) as max_area,
                        MIN(price) as min_price,
                        MAX(price) as max_price
                    FROM excel_properties 
                    WHERE complex_name = :complex_name
                    GROUP BY object_rooms
                    ORDER BY object_rooms
                """), {'complex_name': complex_dict['name']})
                
                room_stats = {}
                room_details = {}
                for room_row in rooms_query.fetchall():
                    rooms = room_row[0] or 0
                    count = room_row[1]
                    min_area = room_row[2] or 0
                    max_area = room_row[3] or 0
                    min_price = room_row[4] or 0
                    max_price = room_row[5] or 0
                    
                    room_type = f"{rooms}-–∫–æ–º–Ω" if rooms and rooms > 0 else "–°—Ç—É–¥–∏—è"
                    room_stats[room_type] = count
                    room_details[room_type] = {
                        'count': count,
                        'area_from': min_area,
                        'area_to': max_area,
                        'price_from': min_price,
                        'price_to': max_price
                    }
                
                complex_dict['real_room_distribution'] = room_stats
                complex_dict['room_details'] = room_details
            except Exception as e:
                print(f"Database error loading room stats for complex {complex_dict['name']}: {e}")
                complex_dict['real_room_distribution'] = {}
            
            complexes.append(complex_dict)
        
        # Database complexes loaded
        
        # Get unique districts and developers (with safe extraction)
        districts = sorted(list(set(complex.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in complexes if complex.get('district'))))
        developers = sorted(list(set(complex.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in complexes if complex.get('developer'))))
        
        # Pagination
        page = int(request.args.get('page', 1))
        per_page = 35  # Show all complexes on one page
        total_complexes = len(complexes)
        total_pages = (total_complexes + per_page - 1) // per_page
        offset = (page - 1) * per_page
        complexes_page = complexes[offset:offset + per_page]
        
        # Prepare pagination info
        pagination = {
            'page': page,
            'per_page': per_page,
            'total': total_complexes,
            'total_pages': total_pages,
            'has_prev': page > 1,
            'has_next': page < total_pages,
            'prev_page': page - 1 if page > 1 else None,
            'next_page': page + 1 if page < total_pages else None
        }
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ JavaScript
        is_manager = 'is_manager' in session and session.get('is_manager', False)
        manager_id = session.get('manager_id')
        
        return render_template('residential_complexes.html',
                             residential_complexes=complexes_page,
                             all_complexes=complexes,  # For JavaScript filtering
                             districts=districts,
                             developers=developers,
                             pagination=pagination,
                             is_manager=is_manager,
                             manager_id=manager_id)
                             
    except Exception as e:
        print(f"ERROR in residential_complexes: {e}")
        import traceback
        traceback.print_exc()
        return f"Error loading residential complexes: {str(e)}", 500





@app.route('/map')
def map_view():
    """Enhanced interactive map view page using real Excel data"""
    # Map route processing
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö —Å —Ä–µ–∞–ª—å–Ω—ã–º –∫–µ—à–±–µ–∫–æ–º –∏–∑ residential_complexes
        properties_query = db.session.execute(text("""
            SELECT ep.*, 
                   rc.cashback_rate,
                   rc.end_build_year,
                   rc.end_build_quarter,
                   rc.object_class_display_name AS rc_object_class
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON ep.complex_name = rc.name
            WHERE ep.address_position_lat IS NOT NULL AND ep.address_position_lon IS NOT NULL
            ORDER BY ep.price ASC
        """))
        
        properties = []
        for row in properties_query:
            prop_dict = dict(row._mapping)
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∫–µ—à–±–µ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ cashback_rate –∏–∑ residential_complexes
            price = prop_dict.get('price', 0)
            cashback_rate = prop_dict.get('cashback_rate', 0) or 0
            cashback_amount = int(price * (cashback_rate / 100)) if cashback_rate > 0 else 0
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –∫–∞—Ä—Ç—ã
            property_data = {
                'id': prop_dict.get('inner_id', prop_dict.get('id')),
                'price': price,
                'area': prop_dict.get('object_area', 0),
                'rooms': prop_dict.get('object_rooms', 0),
                'title': f"{'–°—Ç—É–¥–∏—è' if int(prop_dict.get('object_rooms', 0)) == 0 else str(int(prop_dict.get('object_rooms', 0))) + '-–∫–æ–º–Ω'}, {prop_dict.get('object_area', 0)} –º¬≤",
                'address': prop_dict.get('address_display_name', ''),
                'residential_complex': prop_dict.get('complex_name', ''),
                'complex_name': prop_dict.get('complex_name', ''),  # –î–æ–±–∞–≤–ª—è–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                'developer': prop_dict.get('developer_name', ''),
                'district': prop_dict.get('address_locality_display_name', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π'),
                'coordinates': {
                    'lat': float(prop_dict.get('address_position_lat', 45.0448)),
                    'lng': float(prop_dict.get('address_position_lon', 38.9760))
                },
                'url': f"/object/{prop_dict.get('inner_id', prop_dict.get('id'))}",
                'type': 'property',
                'cashback': cashback_amount,
                'cashback_rate': cashback_rate,
                'cashback_available': cashback_rate > 0,
                'status': 'available',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—è —ç—Ç–∞–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–∞—Ä—Ç—ã
                'object_min_floor': prop_dict.get('object_min_floor', 0),
                'object_max_floor': prop_dict.get('object_max_floor', 0),
                # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—è –¥–ª—è –Ω–æ–≤—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
                'renovation_type': prop_dict.get('renovation_type', ''),
                'renovation_display_name': prop_dict.get('renovation_display_name', ''),
                'complex_object_class_display_name': prop_dict.get('rc_object_class', '') or prop_dict.get('complex_object_class_display_name', ''),
                'complex_has_mortgage_subsidy': prop_dict.get('complex_has_mortgage_subsidy', False),
                'complex_has_government_program': prop_dict.get('complex_has_government_program', False),
                'complex_has_green_mortgage': prop_dict.get('complex_has_green_mortgage', False),
                # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –≥–æ–¥ —Å–¥–∞—á–∏ –∏–∑ residential_complexes
                'complex_building_end_build_year': prop_dict.get('end_build_year', None) or prop_dict.get('complex_building_end_build_year', None),
                'complex_building_end_build_quarter': prop_dict.get('end_build_quarter', None) or prop_dict.get('complex_building_end_build_quarter', None)
            }
            
            # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –¥–ª—è –ø—Ä–µ–≤—å—é (PostgreSQL array —Ñ–æ—Ä–º–∞—Ç)
            photos_raw = prop_dict.get('photos', '')
            try:
                if photos_raw and photos_raw.startswith('{') and photos_raw.endswith('}'):
                    photos_clean = photos_raw[1:-1]  # —É–±–∏—Ä–∞–µ–º { –∏ }
                    if photos_clean:
                        photos_list = [url.strip() for url in photos_clean.split(',') if url.strip()]
                        property_data['main_image'] = photos_list[0] if photos_list else 'https://via.placeholder.com/400x300'
                        # Photos parsed
                    else:
                        property_data['main_image'] = 'https://via.placeholder.com/400x300'
                elif photos_raw:
                    property_data['main_image'] = photos_raw
                else:
                    property_data['main_image'] = 'https://via.placeholder.com/400x300'
            except Exception as e:
                print(f"ERROR MAP: Failed to parse photos for {prop_dict.get('inner_id', 'unknown')}: {e}")
                property_data['main_image'] = 'https://via.placeholder.com/400x300'
            
            properties.append(property_data)
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        complexes_query = db.session.execute(text("""
            SELECT DISTINCT complex_name, developer_name, address_display_name, 
                   address_position_lat, address_position_lon, address_locality_display_name, COUNT(*) as apartments_count,
                   MIN(price) as price_from
            FROM excel_properties 
            WHERE address_position_lat IS NOT NULL AND address_position_lon IS NOT NULL
            GROUP BY complex_name, developer_name, address_display_name, address_position_lat, address_position_lon, address_locality_display_name
        """))
        
        residential_complexes = []
        for row in complexes_query:
            complex_dict = dict(row._mapping)
            complex_data = {
                'id': len(residential_complexes) + 1,
                'name': complex_dict.get('complex_name', ''),
                'developer': complex_dict.get('developer_name', ''),
                'address': complex_dict.get('address_display_name', ''),
                'district': complex_dict.get('address_locality_display_name', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π'),
                'apartments_count': complex_dict.get('apartments_count', 0),
                'price_from': complex_dict.get('price_from', 0),
                'coordinates': {
                    'lat': float(complex_dict.get('address_position_lat', 45.0448)),
                    'lng': float(complex_dict.get('address_position_lon', 38.9760))
                },
                'url': '/zk/' + complex_dict.get('complex_name', '').lower().replace(' ', '-').replace('"', '').replace('–∂–∫-', '').replace('–∂–∫ ', ''),
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # –§–∏–ª—å—Ç—Ä—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        all_districts = sorted(list(set(prop.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties)))
        all_developers = sorted(list(set(prop.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties)))
        all_complexes = sorted(list(set(prop.get('residential_complex', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties)))
        
        filters = {
            'rooms': request.args.getlist('rooms'),
            'price_min': request.args.get('price_min', ''),
            'price_max': request.args.get('price_max', ''),
            'district': request.args.get('district', ''),
            'developer': request.args.get('developer', ''),
            'residential_complex': request.args.get('residential_complex', ''),
        }
        
        # Map data loaded
        
        return render_template('map.html', 
                             properties=properties, 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_complexes=all_complexes,
                             filters=filters)
                             
    except Exception as e:
        print(f"ERROR in map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def extract_main_image_from_photos(photos_raw):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –ø–æ–ª—è photos, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—è –≤–Ω–µ—à–Ω–∏–µ –≤–∏–¥—ã –∑–¥–∞–Ω–∏–π"""
    if not photos_raw or not photos_raw.strip():
        return '/static/images/no-photo.jpg'
    
    try:
        import json
        # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ JSON –º–∞—Å—Å–∏–≤
        if photos_raw.startswith('[') and photos_raw.endswith(']'):
            images = json.loads(photos_raw)
            if not images:
                return '/static/images/no-photo.jpg'
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—è –≤–Ω–µ—à–Ω–∏–µ –≤–∏–¥—ã
            # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —Ç–∞–∫ –∫–∞–∫ –ø–µ—Ä–≤—ã–µ —á–∞—Å—Ç–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∫–∏
            if len(images) > 5:
                # –ë–µ—Ä–µ–º –∏–∑ —Å–µ—Ä–µ–¥–∏–Ω—ã/–∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞, –≥–¥–µ –æ–±—ã—á–Ω–æ —Ñ–æ—Ç–æ –∑–¥–∞–Ω–∏–π
                return images[len(images)//2]
            elif len(images) > 2:
                return images[-1]  # –ü–æ—Å–ª–µ–¥–Ω–µ–µ —Ñ–æ—Ç–æ
            else:
                return images[0]
        
        # PostgreSQL array format: {url1,url2,url3}
        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
            images_str = photos_raw[1:-1]  # Remove braces
            if images_str:
                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                return images[0] if images else '/static/images/no-photo.jpg'
            else:
                return '/static/images/no-photo.jpg'
        
        # –û–¥–∏–Ω–æ—á–Ω–∞—è —Å—Å—ã–ª–∫–∞
        else:
            return photos_raw
            
    except (json.JSONDecodeError, IndexError) as e:
        print(f"Error parsing photos: {e}, raw data: {photos_raw[:100]}")
        return '/static/images/no-photo.jpg'

@app.route('/complexes-map')
def complexes_map():
    """–ö–∞—Ä—Ç–∞ –∂–∏–ª—ã—Ö –∫–æ–º–ø–ª–µ–∫—Å–æ–≤"""
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –ñ–ö –∏–∑ Excel —Ç–∞–±–ª–∏—Ü—ã, –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –ø–æ–ª—è –∏–∑ —Ä–∞–±–æ—Ç–∞—é—â–µ–≥–æ —Ä–æ—É—Ç–∞
        complexes_query = db.session.execute(text("""
            SELECT 
                ep.complex_name,
                COUNT(*) as apartments_count,
                MIN(ep.price) as price_from,
                MAX(ep.price) as price_to,
                MAX(ep.developer_name) as developer_name,
                MAX(ep.address_display_name) as address_display_name,
                MAX(ep.complex_end_build_year) as end_build_year,
                MAX(ep.complex_end_build_quarter) as end_build_quarter,
                MAX(ep.complex_object_class_display_name) as object_class_display_name,
                AVG(ep.address_position_lat) as coordinates_lat,
                AVG(ep.address_position_lon) as coordinates_lng,
                COALESCE(MAX(ep.parsed_district), '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π') as district,
                MAX(ep.photos) as photos,
                MAX(rc.cashback_rate) as cashback_percent
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON ep.complex_name = rc.name
            WHERE ep.complex_name IS NOT NULL 
                AND ep.address_position_lat IS NOT NULL 
                AND ep.address_position_lon IS NOT NULL
                AND ep.complex_name != ''
            GROUP BY ep.complex_name
            ORDER BY ep.complex_name
        """))
        
        residential_complexes = []
        for row in complexes_query:
            complex_dict = dict(row._mapping)
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω–æ–µ –∏–º—è –∫–æ–º–ø–ª–µ–∫—Å–∞ –¥–ª—è URL (–∫–∞–∫ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö)
            full_complex_name = complex_dict.get('complex_name', '')
            clean_complex_name = full_complex_name.replace('–ñ–ö ', '').replace('"', '')
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –≥–æ–¥–∞ —Å–¥–∞—á–∏
            current_year = 2025
            end_build_year = complex_dict.get('end_build_year')
            status = '–ù–µ —É–∫–∞–∑–∞–Ω'
            if end_build_year:
                if end_build_year <= current_year:
                    status = '–°–¥–∞–Ω'
                else:
                    status = '–°—Ç—Ä–æ–∏—Ç—Å—è'
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞—Ç—É —Å–¥–∞—á–∏
            completion_date = ''
            if end_build_year:
                quarter = complex_dict.get('end_build_quarter')
                if quarter:
                    completion_date = f"{quarter} –∫–≤. {end_build_year}"
                else:
                    completion_date = f"{end_build_year} –≥–æ–¥"
            
            complex_data = {
                'id': hash(complex_dict.get('complex_name', '')) % 100000,  # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º ID –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–µ—à–∞ –∏–º–µ–Ω–∏
                'name': complex_dict.get('complex_name', ''),
                'developer': complex_dict.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'address': complex_dict.get('address_display_name', ''),
                'district': complex_dict.get('district', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π'),
                'apartments_count': complex_dict.get('apartments_count', 0),
                'price_from': complex_dict.get('price_from', 0),
                'coordinates': {
                    'lat': float(complex_dict.get('coordinates_lat', 45.0448)),
                    'lng': float(complex_dict.get('coordinates_lng', 38.9760))
                },
                'completion_date': completion_date,
                'status': status,
                'cashback_percent': complex_dict.get('cashback_percent', 0) or 0,  # –ò–∑ –ë–î residential_complexes
                'main_image': extract_main_image_from_photos(complex_dict.get('photos', '')),
                'description': f"–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å {complex_dict.get('complex_name', '')}",
                'object_class': complex_dict.get('object_class_display_name', ''),
                'housing_class': '',
                'max_floors': 0,
                'url': f"/residential-complex/{full_complex_name}",
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # –§–∏–ª—å—Ç—Ä—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        all_districts = sorted(list(set(complex.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in residential_complexes)))
        all_developers = sorted(list(set(complex.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in residential_complexes)))
        all_statuses = ['–í—Å–µ', '–°–¥–∞–Ω', '–°—Ç—Ä–æ–∏—Ç—Å—è']
        
        print(f"DEBUG: Found {len(residential_complexes)} complexes for map")
        if residential_complexes:
            print(f"DEBUG: First complex: {residential_complexes[0]}")
        
        return render_template('complexes_map.html', 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_statuses=all_statuses)
                             
    except Exception as e:
        print(f"ERROR in complexes-map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

# API Routes
@app.route('/api/properties')
@cache.cached(timeout=300, query_string=True)  # Cache for 5 min with query params
def api_properties():
    """API endpoint for properties from Excel data with real coordinates - OPTIMIZED for 300K+ listings"""
    try:
        # Pagination parameters
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))  # Default 50 items per page
        offset = (page - 1) * per_page
        
        # Get total count for pagination (cached-friendly)
        count_query = db.session.execute(text("""
            SELECT COUNT(*) FROM excel_properties 
            WHERE address_position_lat IS NOT NULL AND address_position_lon IS NOT NULL
        """))
        total_count = count_query.scalar()
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è (–≤–º–µ—Å—Ç–æ SELECT *)
        properties_query = db.session.execute(text("""
            SELECT 
                inner_id,
                price,
                object_area,
                object_rooms,
                complex_name,
                address_locality_display_name,
                address_display_name,
                developer_name,
                complex_object_class_display_name,
                renovation_display_name,
                object_min_floor,
                object_max_floor,
                address_position_lat,
                address_position_lon,
                photos
            FROM excel_properties 
            WHERE address_position_lat IS NOT NULL AND address_position_lon IS NOT NULL
            ORDER BY price ASC
            LIMIT :limit OFFSET :offset
        """), {'limit': per_page, 'offset': offset})
        
        properties = []
        for row in properties_query:
            prop_dict = dict(row._mapping)
            property_data = {
                'id': prop_dict.get('inner_id', prop_dict.get('id')),
                'price': prop_dict.get('price', 0),
                'area': prop_dict.get('object_area', 0),
                'rooms': prop_dict.get('object_rooms', 0),
                'title': f"{'–°—Ç—É–¥–∏—è' if int(prop_dict.get('object_rooms', 0)) == 0 else str(int(prop_dict.get('object_rooms', 0))) + '-–∫–æ–º–Ω'}, {prop_dict.get('object_area', 0)} –º¬≤",
                'subtitle': f"{prop_dict.get('complex_name', '')} ‚Ä¢ {prop_dict.get('address_locality_display_name', '')}",
                'address': prop_dict.get('address_display_name', ''),
                'residential_complex': prop_dict.get('complex_name', ''),
                'developer': prop_dict.get('developer_name', ''),
                'developer_name': prop_dict.get('developer_name', ''),
                'district': prop_dict.get('address_locality_display_name', '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π'),
                'complex_object_class_display_name': prop_dict.get('complex_object_class_display_name', ''),
                'renovation_display_name': prop_dict.get('renovation_display_name', ''),
                'object_min_floor': prop_dict.get('object_min_floor', 0),
                'object_max_floor': prop_dict.get('object_max_floor', 0),
                'coordinates': {
                    'lat': float(prop_dict.get('address_position_lat', 45.0448)),
                    'lng': float(prop_dict.get('address_position_lon', 38.9760))
                },
                'url': f"/object/{prop_dict.get('inner_id', prop_dict.get('id'))}",
                'type': 'property',
                'cashback': int(prop_dict.get('price', 0) * 0.035),
                'cashback_available': True,
                'status': 'available',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞'
            }
            
            # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ (PostgreSQL array —Ñ–æ—Ä–º–∞—Ç)
            photos_raw = prop_dict.get('photos', '')
            try:
                if photos_raw and photos_raw.startswith('{') and photos_raw.endswith('}'):
                    photos_clean = photos_raw[1:-1]  # —É–±–∏—Ä–∞–µ–º { –∏ }
                    if photos_clean:
                        photos_list = [url.strip() for url in photos_clean.split(',')]
                        property_data['main_image'] = photos_list[0] if photos_list else 'https://via.placeholder.com/400x300'
                    else:
                        property_data['main_image'] = 'https://via.placeholder.com/400x300'
                elif photos_raw:
                    # –ï—Å–ª–∏ —ç—Ç–æ JSON —Ñ–æ—Ä–º–∞—Ç, –ø–∞—Ä—Å–∏–º –∫–∞–∫ JSON
                    import json
                    photos_list = json.loads(photos_raw)
                    property_data['main_image'] = photos_list[0] if photos_list else 'https://via.placeholder.com/400x300'
                else:
                    property_data['main_image'] = 'https://via.placeholder.com/400x300'
            except Exception as e:
                print(f"Error parsing photos for API property {prop_dict.get('inner_id', 'unknown')}: {e}")
                property_data['main_image'] = 'https://via.placeholder.com/400x300'
            
            properties.append(property_data)
        
        print(f"DEBUG: API returned {len(properties)} properties (page {page}, total {total_count})")
        return jsonify({
            'properties': properties,
            'total': total_count,
            'page': page,
            'per_page': per_page,
            'total_pages': (total_count + per_page - 1) // per_page,
            'success': True
        })
        
    except Exception as e:
        print(f"ERROR in api_properties: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search-suggestions-OLD-DISABLED')
def api_search_suggestions_old_disabled():
    """‚ùå –°–¢–ê–†–´–ô API endpoint - –û–¢–ö–õ–Æ–ß–Å–ù, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª –Ω–æ–≤–æ–º—É"""
    return jsonify([])  # –í–°–ï–ì–î–ê –ü–£–°–¢–û–ô


# ===== –°–¢–ê–†–´–ô –ö–û–î –ü–û–õ–ù–û–°–¢–¨–Æ –£–î–ê–õ–Å–ù =====

@app.route('/api/residential-complexes-map')
def api_residential_complexes_map():
    """API endpoint for residential complexes with enhanced data for map"""
    complexes = load_residential_complexes()
    
    # Enhance complexes data for map
    for i, complex in enumerate(complexes):
        # Add coordinates if missing
        if 'coordinates' not in complex:
            base_lat = 45.0448
            base_lng = 38.9760
            lat_offset = (hash(str(i) + complex.get('name', '')) % 1000) / 8000 - 0.0625
            lng_offset = (hash(str(i) + complex.get('district', '')) % 1000) / 8000 - 0.0625
            complex['coordinates'] = {
                'lat': base_lat + lat_offset,
                'lng': base_lng + lng_offset
            }
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç –∫–æ—Ä–ø—É—Å–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        if 'buildings_count' not in complex:
            # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ—Ä–ø—É—Å–æ–≤ –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö
            try:
                result = db.session.execute(text("""
                    SELECT COUNT(DISTINCT complex_building_id) as buildings_count
                    FROM excel_properties 
                    WHERE complex_name = :complex_name
                """), {'complex_name': complex.get('name', '')})
                row = result.fetchone()
                complex['buildings_count'] = row[0] if row and row[0] else 1
            except:
                complex['buildings_count'] = 1  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 1 –∫–æ—Ä–ø—É—Å
        if 'apartments_count' not in complex:
            complex['apartments_count'] = 100 + (i % 300)
            
    return jsonify(complexes)

# Removed duplicate route - using api_property_detail instead

@app.route('/api/complex/<int:complex_id>')
def api_complex(complex_id):
    """API endpoint for single residential complex - HANDLES BOTH ID SYSTEMS"""
    print(f"üîç API /api/complex/{complex_id} called")
    
    # ‚úÖ FIX: Handle both ID systems - check if ID is from residential_complexes.id or excel_properties.complex_id
    actual_complex_id = complex_id
    
    # First, try direct lookup in excel_properties
    try:
        result = db.session.execute(text("""
            SELECT 
                ep.complex_id,
                ep.complex_name,
                MIN(ep.price) as min_price,
                MAX(ep.price) as max_price,
                COUNT(DISTINCT ep.inner_id) as apartments_count,
                COUNT(DISTINCT ep.complex_building_id) as buildings_count,
                ep.developer_name,
                MIN(ep.object_min_floor) as floors_min,
                MAX(ep.object_max_floor) as floors_max,
                MAX(ep.complex_building_end_build_year) as completion_year,
                MAX(ep.complex_building_end_build_quarter) as completion_quarter,
                MAX(ep.parsed_district) as district,
                MAX(ep.address_display_name) as address,
                COALESCE(MAX(rc.cashback_rate), MAX(ep.complex_min_rate), 0) as cashback_rate,
                MAX(ep.photos) as photos,
                MAX(ep.complex_object_class_display_name) as object_class
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON CAST(ep.complex_id AS TEXT) = rc.complex_id
            WHERE ep.complex_id = :complex_id 
            GROUP BY ep.complex_id, ep.complex_name, ep.developer_name
            LIMIT 1
        """), {'complex_id': complex_id}).fetchone()
        
        if result:
            print(f"‚úÖ Found complex {complex_id} in excel_properties: {result[1]}, apartments: {result[4]}, price: {result[2]}-{result[3]}")
            
            # Build completion date from year and quarter
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            if result[9] and result[10]:  # year and quarter
                completion_date = f"{result[9]} –≥., {result[10]} –∫–≤."
            elif result[9]:  # only year
                completion_date = f"{result[9]} –≥."
            
            # Extract first photo from photos array
            image_url = '/static/images/no-image.jpg'
            if result[14]:  # photos field
                try:
                    photos_data = json.loads(result[14])
                    if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                        image_url = photos_data[0]
                except (json.JSONDecodeError, TypeError):
                    pass
            
            response_data = {
                'id': result[0],
                'name': result[1],
                'min_price': result[2],
                'price_from': result[2],
                'max_price': result[3],
                'price_to': result[3],
                'apartments_count': result[4],
                'properties_count': result[4],
                'buildings_count': result[5],
                'developer': result[6],
                'developer_name': result[6],
                'floors_min': result[7],
                'floors_max': result[8],
                'completion_date': completion_date,
                'district': result[11] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'address': result[12] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'cashback_rate': result[13] or 0,
                'cashback_percent': result[13] or 0,
                'object_class': result[15] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'status': '–í –ø—Ä–æ–¥–∞–∂–µ',
                'image': image_url
            }
            print(f"üì§ Returning from excel_properties: {response_data}")
            return jsonify(response_data)
        else:
            print(f"‚ö†Ô∏è Complex {complex_id} not found in excel_properties directly")
            
            # ‚úÖ ID MAPPING FIX: Check if this is a residential_complexes.id - if so, get the complex_id and retry
            rc_result = db.session.execute(text("""
                SELECT complex_id FROM residential_complexes WHERE id = :id LIMIT 1
            """), {'id': complex_id}).fetchone()
            
            if rc_result and rc_result[0]:
                actual_complex_id = int(rc_result[0])
                print(f"üîÑ Mapping residential_complexes.id={complex_id} to excel_properties.complex_id={actual_complex_id}")
                
                # Retry with the actual complex_id
                result = db.session.execute(text("""
                    SELECT 
                        ep.complex_id,
                        ep.complex_name,
                        MIN(ep.price) as min_price,
                        MAX(ep.price) as max_price,
                        COUNT(DISTINCT ep.inner_id) as apartments_count,
                        COUNT(DISTINCT ep.complex_building_id) as buildings_count,
                        ep.developer_name,
                        MIN(ep.object_min_floor) as floors_min,
                        MAX(ep.object_max_floor) as floors_max,
                        MAX(ep.complex_building_end_build_year) as completion_year,
                        MAX(ep.complex_building_end_build_quarter) as completion_quarter,
                        MAX(ep.parsed_district) as district,
                        MAX(ep.address_display_name) as address,
                        COALESCE(MAX(rc.cashback_rate), MAX(ep.complex_min_rate), 0) as cashback_rate,
                        MAX(ep.photos) as photos,
                        MAX(ep.complex_object_class_display_name) as object_class
                    FROM excel_properties ep
                    LEFT JOIN residential_complexes rc ON CAST(ep.complex_id AS TEXT) = rc.complex_id
                    WHERE ep.complex_id = :complex_id 
                    GROUP BY ep.complex_id, ep.complex_name, ep.developer_name
                    LIMIT 1
                """), {'complex_id': actual_complex_id}).fetchone()
                
                if result:
                    print(f"‚úÖ Found complex via mapping: {result[1]}, apartments: {result[4]}, price: {result[2]}-{result[3]}")
                    
                    # Build completion date from year and quarter
                    completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
                    if result[9] and result[10]:  # year and quarter
                        completion_date = f"{result[9]} –≥., {result[10]} –∫–≤."
                    elif result[9]:  # only year
                        completion_date = f"{result[9]} –≥."
                    
                    # Extract first photo from photos array
                    image_url = '/static/images/no-image.jpg'
                    if result[14]:  # photos field
                        try:
                            photos_data = json.loads(result[14])
                            if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                                image_url = photos_data[0]
                        except (json.JSONDecodeError, TypeError):
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    response_data = {
                        'id': result[0],
                        'name': result[1],
                        'min_price': result[2],
                        'price_from': result[2],
                        'max_price': result[3],
                        'price_to': result[3],
                        'apartments_count': result[4],
                        'properties_count': result[4],
                        'buildings_count': result[5],
                        'developer': result[6],
                        'developer_name': result[6],
                        'floors_min': result[7],
                        'floors_max': result[8],
                        'completion_date': completion_date,
                        'district': result[11] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'address': result[12] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'cashback_rate': result[13] or 0,
                        'cashback_percent': result[13] or 0,
                        'object_class': result[15] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'status': '–í –ø—Ä–æ–¥–∞–∂–µ',
                        'image': image_url
                    }
                    print(f"üì§ Returning mapped complex data: {response_data}")
                    return jsonify(response_data)
            
            print(f"‚ö†Ô∏è Complex {complex_id} not found in residential_complexes mapping either, trying JSON fallback")
    except Exception as e:
        print(f"‚ùå Error loading complex {complex_id} from excel_properties: {e}")
        import traceback
        traceback.print_exc()
    
    # Fallback to residential_complexes (JSON file) if not found in database
    complexes = load_residential_complexes()
    print(f"üìä load_residential_complexes() returned {len(complexes)} complexes")
    for complex in complexes:
        if complex.get('id') == complex_id:
            print(f"‚úÖ Found complex {complex_id} in residential_complexes: {complex.get('name')}")
            print(f"üì§ Returning from residential_complexes: apartments_count={complex.get('apartments_count')}, min_price={complex.get('min_price')}, price_from={complex.get('price_from')}, cashback_rate={complex.get('cashback_rate')}")
            return jsonify(complex)
    
    print(f"‚ùå Complex {complex_id} not found anywhere, returning 404")
    return jsonify({'error': 'Complex not found'}), 404



@app.route('/api/mini-map/properties')
def api_mini_map_properties():
    """API endpoint for mini-map: return property coordinates"""
    try:
        # Get coordinates from excel_properties
        result = db.session.execute(text("""
            SELECT 
                ep.address_position_lat as lat,
                ep.address_position_lon as lng
            FROM excel_properties ep
            WHERE ep.address_position_lat IS NOT NULL 
                AND ep.address_position_lon IS NOT NULL
                AND ep.address_position_lat != 0
                AND ep.address_position_lon != 0
            LIMIT 500
        """))
        
        coordinates = []
        for row in result:
            coordinates.append({
                'lat': float(row.lat),
                'lng': float(row.lng)
            })
        
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"‚ùå Error in mini-map properties: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mini-map/complexes')
def api_mini_map_complexes():
    """API endpoint for mini-map: return complex coordinates"""
    try:
        # Get coordinates from excel_properties grouped by complex
        result = db.session.execute(text("""
            SELECT 
                ep.complex_name,
                AVG(ep.address_position_lat) as lat,
                AVG(ep.address_position_lon) as lng
            FROM excel_properties ep
            WHERE ep.complex_name IS NOT NULL 
                AND ep.address_position_lat IS NOT NULL 
                AND ep.address_position_lon IS NOT NULL
                AND ep.address_position_lat != 0
                AND ep.address_position_lon != 0
            GROUP BY ep.complex_name
        """))
        
        coordinates = []
        for row in result:
            coordinates.append({
                'name': row.complex_name,
                'lat': float(row.lat),
                'lng': float(row.lng)
            })
        
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"‚ùå Error in mini-map complexes: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/property/<property_id>/pdf')
def download_property_pdf(property_id):
    """Generate and download PDF for property"""
    try:
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': 'Property not found'}), 404
        
        # Create simple HTML for PDF generation
        html_content = f"""
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .property-details {{ margin-bottom: 20px; }}
                .detail-row {{ margin-bottom: 10px; }}
                .label {{ font-weight: bold; }}
                .price {{ color: #0088CC; font-size: 24px; font-weight: bold; }}
                .cashback {{ color: #FF5722; font-size: 18px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>InBack - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–≤–∞—Ä—Ç–∏—Ä–µ</h1>
                <p>–ö–≤–∞—Ä—Ç–∏—Ä–∞ #{property_id}</p>
            </div>
            
            <div class="property-details">
                <div class="detail-row">
                    <span class="label">–¢–∏–ø:</span> {property_data.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
                </div>
                <div class="detail-row">
                    <span class="label">–ü–ª–æ—â–∞–¥—å:</span> {property_data.get('area', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')} –º¬≤
                </div>
                <div class="detail-row">
                    <span class="label">–≠—Ç–∞–∂:</span> {property_data.get('floor', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫:</span> {property_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ñ–ö:</span> {property_data.get('residential_complex', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–†–∞–π–æ–Ω:</span> {property_data.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ê–¥—Ä–µ—Å:</span> {property_data.get('location', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–°—Ç–∞—Ç—É—Å:</span> {property_data.get('status', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                
                <div class="detail-row" style="margin-top: 30px;">
                    <div class="price">–¶–µ–Ω–∞: {property_data.get('price', 0):,} ‚ÇΩ</div>
                </div>
                <div class="detail-row">
                    <div class="cashback">–ö–µ—à–±–µ–∫: –¥–æ {calculate_cashback(property_data.get('price', 0)):,} ‚ÇΩ (5%)</div>
                </div>
            </div>
            
            <div style="margin-top: 50px; text-align: center; color: #666;">
                <p>InBack.ru - –≤–∞—à –∫–µ—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏</p>
                <p>–¢–µ–ª–µ—Ñ–æ–Ω: +7 (800) 123-12-12</p>
            </div>
        </body>
        </html>
        """
        
        # Return HTML for PDF conversion (browser will handle PDF generation)
        # Create ASCII-safe filename
        ascii_filename = f'property-{property_id}.html'
        
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html'
        )
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        return response
        
    except Exception as e:
        print(f"Error generating PDF for property {property_id}: {e}")
        return jsonify({'error': 'Failed to generate PDF'}), 500

@app.route('/developers')
@cache.cached(timeout=3600)  # –ö—ç—à –Ω–∞ 1 —á–∞—Å
def developers():
    """Developers listing page with real database data"""
    try:
        print("Loading developers from database...")
        
        from models import Developer, ResidentialComplex, Property
        from sqlalchemy import func
        
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        developers_list = (
            db.session.query(Developer, 
                            func.count(ResidentialComplex.id).label('complexes_count'),
                            func.count(Property.id).label('properties_count'))
            .outerjoin(ResidentialComplex, Developer.id == ResidentialComplex.developer_id)
            .outerjoin(Property, Developer.id == Property.developer_id)
            .group_by(Developer.id)
            .order_by(func.count(Property.id).desc())
            .all()
        )
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –¥–∞–Ω–Ω—ã–º–∏
        developers_data = []
        for developer, complexes_count, properties_count in developers_list:
            developer_dict = {
                'id': developer.id,
                'name': developer.name,
                'slug': developer.slug,
                'description': developer.description or f"–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ {developer.name}",
                'logo_url': developer.logo_url or f"https://via.placeholder.com/200x100/3B82F6/FFFFFF?text={developer.name.replace(' ', '+')}",
                'website': developer.website,
                'phone': developer.phone,
                'email': developer.email,
                'address': developer.address,
                'complexes_count': complexes_count,
                'properties_count': properties_count,
                'established_year': developer.established_year,
                # –ù—É–∂–Ω—ã–µ –ø–æ–ª—è –¥–ª—è —à–∞–±–ª–æ–Ω–∞
                'max_cashback': 10,  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 10%
                'max_cashback_percent': 10,
                # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                'stats': {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None  # –î–æ–±–∞–≤–∏–º –ø–æ–∑–∂–µ
                }
            }
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö –ø–æ –∏–º–µ–Ω–∏ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞
            excel_stats = db.session.execute(text("""
                SELECT 
                    COUNT(*) as total_properties,
                    AVG(ep.price) as avg_price,
                    MIN(ep.price) as min_price,
                    MAX(ep.price) as max_price,
                    COUNT(DISTINCT ep.complex_name) as total_complexes
                FROM excel_properties ep
                WHERE UPPER(TRIM(ep.developer_name)) = UPPER(TRIM(:developer_name))
            """), {'developer_name': developer.name}).fetchone()
            
            if excel_stats and excel_stats[0]:  # Check if we have data
                total_props, avg_price, min_price, max_price, total_complexes = excel_stats
                developer_dict['properties_count'] = total_props or properties_count
                developer_dict['complexes_count'] = total_complexes or complexes_count
                developer_dict['stats'] = {
                    'total_projects': total_complexes or complexes_count,
                    'total_apartments': total_props or properties_count,
                    'avg_price': int(avg_price) if avg_price else None,
                    'min_price': int(min_price) if min_price else None,
                    'max_price': int(max_price) if max_price else None
                }
            else:
                # Fallback to basic database stats
                developer_dict['stats'] = {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None
                }
            
            developers_data.append(developer_dict)
        
        print(f"Found {len(developers_data)} developers in database")
        
        return render_template('developers.html', developers=developers_data)
        
    except Exception as e:
        print(f"Error loading developers: {e}")
        return render_template('developers.html', developers=[])

@app.route('/developer/<developer_slug>')  
def developer_page(developer_slug):
    """Individual developer page by slug"""
    try:
        # No redirect logic needed - browser will handle encoding
        
        # Create variations of the developer name to search for
        # Convert slug back to possible name formats  
        developer_name_from_slug = developer_slug.replace('-', ' ')
        
        # Try to find developer in database using multiple search strategies
        developer = db.session.execute(
            text("""
            SELECT * FROM developers WHERE 
            LOWER(TRANSLATE(REPLACE(name, ' ', '-'), '¬´¬ª"().,;:', '')) = LOWER(:slug)
            OR LOWER(name) LIKE LOWER(:name_pattern)
            OR LOWER(REPLACE(name, ' ', '-')) = LOWER(:slug)
            OR slug = :slug
            LIMIT 1
            """),
            {
                "slug": developer_slug, 
                "name_pattern": f"%{developer_name_from_slug}%"
            }
        ).fetchone()
        
        if not developer:
            print(f"Developer not found in database: {developer_slug}")
            return redirect(url_for('developers'))
        
        # Convert row to dict-like object for template
        developer_dict = dict(developer._mapping)
        
        # –ü–æ–ª—É—á–∞–µ–º –ñ–ö —ç—Ç–æ–≥–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏ –∏ —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        developer_complexes_query = db.session.execute(text("""
            SELECT 
                ep.complex_name as name,
                ep.complex_name as id,
                COALESCE(MAX(ep.address_short_display_name), '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω') as location,
                COUNT(ep.inner_id) as apartments_count,
                COUNT(DISTINCT ep.complex_building_id) as buildings_count,
                MIN(ep.price) as min_price,
                MAX(ep.price) as max_price,
                AVG(ep.price) as avg_price,
                MAX(ep.address_position_lat) as lat,
                MAX(ep.address_position_lon) as lng,
                MAX(ep.complex_sales_address) as sales_address,
                -- –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏–∑ JSON –º–∞—Å—Å–∏–≤–∞ —Ñ–æ—Ä–º–∞—Ç–∞ ["url1","url2","url3"]
                CASE 
                    WHEN MAX(ep.photos) IS NOT NULL AND MAX(ep.photos) != '' AND MAX(ep.photos) != '[]' 
                        THEN ARRAY(SELECT json_array_elements_text(MAX(ep.photos)::json))
                    ELSE ARRAY['https://images.unsplash.com/photo-1545324418-cc1a3fa10c00?w=800']
                END as images,
                -- –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–≤—É—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏  
                CASE 
                    WHEN MAX(ep.photos) IS NOT NULL AND MAX(ep.photos) != '' AND MAX(ep.photos) != '[]' 
                        THEN (MAX(ep.photos)::json->>0)
                    ELSE 'https://images.unsplash.com/photo-1545324418-cc1a3fa10c00?w=800'
                END as image,
                CASE 
                    WHEN MAX(ep.complex_end_build_quarter) IS NOT NULL AND MAX(ep.complex_end_build_year) IS NOT NULL 
                        THEN COALESCE(MAX(ep.complex_end_build_quarter)::text, 'IV') || ' –∫–≤. ' || COALESCE(MAX(ep.complex_end_build_year)::text, '2024')
                    ELSE '–°–¥–∞–Ω'
                END as completion_date,
                MIN(ep.price) as real_price_from,
                COUNT(DISTINCT ep.object_rooms) as room_types_count
            FROM excel_properties ep
            WHERE UPPER(TRIM(ep.developer_name)) = UPPER(TRIM(:developer_name))
            GROUP BY ep.complex_name
            ORDER BY apartments_count DESC
        """), {'developer_name': developer.name})
        
        developer_complexes = []
        for complex_row in developer_complexes_query:
            complex_dict = dict(complex_row._mapping)
            
            # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä –ø–æ –∫–æ–º–Ω–∞—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è —ç—Ç–æ–≥–æ –ñ–ö
            room_distribution_query = db.session.execute(text("""
                SELECT 
                    CASE 
                        WHEN object_rooms = 0 THEN '–°—Ç—É–¥–∏—è'
                        WHEN object_rooms = 1 THEN '1-–∫–æ–º–Ω.'
                        WHEN object_rooms = 2 THEN '2-–∫–æ–º–Ω.'
                        WHEN object_rooms = 3 THEN '3-–∫–æ–º–Ω.'
                        WHEN object_rooms = 4 THEN '4-–∫–æ–º–Ω.'
                        ELSE CAST(object_rooms AS TEXT) || '-–∫–æ–º–Ω.'
                    END as room_type,
                    COUNT(*) as count,
                    MIN(price) as price_from,
                    MAX(price) as price_to,
                    MIN(object_area) as area_from,
                    MAX(object_area) as area_to
                FROM excel_properties 
                WHERE UPPER(TRIM(complex_name)) = UPPER(TRIM(:complex_name))
                  AND UPPER(TRIM(developer_name)) = UPPER(TRIM(:developer_name))
                GROUP BY object_rooms
                ORDER BY object_rooms
            """), {'complex_name': complex_dict['name'], 'developer_name': developer.name})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∫–æ–º–Ω–∞—Ç–Ω–æ—Å—Ç–∏
            real_room_distribution = {}
            room_details = {}
            
            for room_row in room_distribution_query:
                room_data = dict(room_row._mapping)
                room_type = room_data['room_type']
                real_room_distribution[room_type] = room_data['count']
                room_details[room_type] = {
                    'price_from': room_data['price_from'],
                    'price_to': room_data['price_to'],
                    'area_from': room_data['area_from'],
                    'area_to': room_data['area_to']
                }
            
            complex_dict['real_room_distribution'] = real_room_distribution
            complex_dict['room_details'] = room_details
            developer_complexes.append(complex_dict)
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–≤–∞—Ä—Ç–∏—Ä—ã —ç—Ç–æ–≥–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ –∏–∑ Excel –¥–∞–Ω–Ω—ã—Ö
        excel_properties_query = db.session.execute(text("""
            SELECT *
            FROM excel_properties ep
            WHERE UPPER(TRIM(ep.developer_name)) = UPPER(TRIM(:developer_name))
            ORDER BY ep.price ASC
        """), {'developer_name': developer.name})
        
        developer_properties = []
        for prop_row in excel_properties_query:
            prop_dict = dict(prop_row._mapping)
            developer_properties.append(prop_dict)
        
        properties_count = len(developer_properties)
        min_price = min([p['price'] for p in developer_properties]) if developer_properties else 0
        
        # Parse features and infrastructure if they exist
        import json as json_lib
        features = []
        infrastructure = []
        
        if developer_dict.get('features'):
            try:
                features = json_lib.loads(developer_dict['features'])
            except:
                features = []
        
        if developer_dict.get('infrastructure'):
            try:
                infrastructure = json_lib.loads(developer_dict['infrastructure'])
            except:
                infrastructure = []
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ Excel
        excel_stats = db.session.execute(text("""
            SELECT 
                COUNT(*) as total_properties,
                AVG(ep.price) as avg_price,
                MIN(ep.price) as min_price,
                MAX(ep.price) as max_price,
                COUNT(DISTINCT ep.complex_name) as total_complexes
            FROM excel_properties ep
            WHERE UPPER(TRIM(ep.developer_name)) = UPPER(TRIM(:developer_name))
        """), {'developer_name': developer.name}).fetchone()
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        if excel_stats and excel_stats[0]:
            total_props, avg_price, min_price_excel, max_price_excel, total_complexes = excel_stats
            developer_dict['properties_count'] = total_props
            developer_dict['complexes_count'] = total_complexes
            developer_dict['min_price'] = int(min_price_excel) if min_price_excel else 12000000
            developer_dict['max_price'] = int(max_price_excel) if max_price_excel else 0
            developer_dict['avg_price'] = int(avg_price) if avg_price else 0
            print(f"DEBUG: Excel stats for {developer.name}: min_price={min_price_excel}, total_props={total_props}")
        else:
            print(f"DEBUG: No Excel stats found for {developer.name}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ø–æ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å
        developer_dict['total_projects'] = developer_dict.get('completed_projects', 0) or developer_dict.get('complexes_count', 0)
        developer_dict['rating'] = developer_dict.get('rating') or 4.2
        developer_dict['founded_year'] = developer_dict.get('founded_year') or 2015
        developer_dict['detailed_description'] = developer_dict.get('description') or '–ù–∞–¥—ë–∂–Ω—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫ —Å –º–Ω–æ–≥–æ–ª–µ—Ç–Ω–∏–º –æ–ø—ã—Ç–æ–º —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∂–∏–ª—å—è –≤ —Ä–µ–≥–∏–æ–Ω–µ.'
        developer_dict['description'] = developer_dict.get('description') or developer_dict['detailed_description']
        developer_dict['advantages'] = developer_dict.get('advantages') or [
            '–°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ –±–µ–∑ —Å—É–±–ø–æ–¥—Ä—è–¥–∞',
            '–°–¥–∞—á–∞ –æ–±—ä–µ–∫—Ç–æ–≤ —Ç–æ—á–Ω–æ –≤ —Å—Ä–æ–∫', 
            '–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏',
            '–ü–æ–ª–Ω—ã–π –ø–∞–∫–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ —Å–µ—Ä–≤–∏—Å–æ–≤'
        ]
        
        return render_template('developer_detail.html', 
                             developer=developer_dict,
                             developer_name=developer_dict['name'],
                             complexes=developer_complexes,
                             apartments=developer_properties,
                             total_properties=properties_count,
                             min_price=min_price,
                             features=features,
                             infrastructure=infrastructure)
        
    except Exception as e:
        print(f"Error loading developer page for {developer_name}: {e}")
        import traceback
        traceback.print_exc()
        return redirect(url_for('developers'))

# Districts routes
@app.route('/districts')
def districts():
    """Districts listing page"""
    # –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–∏
    from models import District
    import json
    
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ä–∞–π–æ–Ω—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    districts_query = District.query.order_by(District.name).all()
    
    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å –ø–∞—Ä—Å–∏–Ω–≥–æ–º JSON
    districts_list = []
    for district in districts_query:
        district_data = {
            'id': district.id,
            'name': district.name,
            'slug': district.slug,
            'description': district.description,
            'latitude': district.latitude,
            'longitude': district.longitude,
            'distance_to_center': district.distance_to_center,
            'infrastructure_data': {}
        }
        
        # –ü–∞—Ä—Å–∏–º JSON –¥–∞–Ω–Ω—ã–µ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        if district.infrastructure_data:
            try:
                district_data['infrastructure_data'] = json.loads(district.infrastructure_data)
            except:
                district_data['infrastructure_data'] = {}
        
        districts_list.append(district_data)
    
    return render_template('districts.html', 
                         districts=districts_list,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

# ========================================
# –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–ê–Ø –ü–ê–ù–ï–õ–¨ –î–õ–Ø –ö–û–û–†–î–ò–ù–ê–¢
# ========================================

@app.route('/admin/coordinates')
def admin_coordinates():
    """–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–∞–Ω–µ–ª—å –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ä–∞–π–æ–Ω–æ–≤"""
    from models import District
    
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ä–∞–π–æ–Ω—ã
    districts = District.query.order_by(District.name).all()
    
    return render_template('admin/coordinates.html', 
                         districts=districts,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

@app.route('/admin/update-coordinates', methods=['POST'])
def admin_update_coordinates():
    """API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ä–∞–π–æ–Ω–∞"""
    from models import District
    import math
    
    try:
        district_id = request.form.get('district_id')
        latitude = float(request.form.get('latitude'))
        longitude = float(request.form.get('longitude'))
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–∞
        theater_lat, theater_lon = 45.035180, 38.977414
        
        def haversine_distance(lat1, lon1, lat2, lon2):
            R = 6371
            dlat = math.radians(lat2 - lat1)
            dlon = math.radians(lon2 - lon1)
            a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2
            c = 2 * math.asin(math.sqrt(a))
            return R * c
        
        distance = haversine_distance(latitude, longitude, theater_lat, theater_lon)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        district = District.query.get(district_id)
        if district:
            district.latitude = latitude
            district.longitude = longitude
            district.distance_to_center = distance
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ä–∞–π–æ–Ω–∞ {district.name} –æ–±–Ω–æ–≤–ª–µ–Ω—ã',
                'distance': round(distance, 1)
            })
        else:
            return jsonify({'success': False, 'message': '–†–∞–π–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω'})
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})

# ========================================
# –ê–õ–ò–ê–°–´ –î–õ–Ø –°–¢–ê–†–´–• URL –†–ê–ô–û–ù–û–í
# ========================================

@app.route('/district/tec')
def district_tec_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ URL –¢–≠–¶ –Ω–∞ –Ω–æ–≤—ã–π"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='tets'), code=301)

@app.route('/district/mkg')
def district_mkg_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ URL –ú–ö–ì (–ú–•–ì) –Ω–∞ –Ω–æ–≤—ã–π"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='mhg'), code=301)

@app.route('/district/skhi')
def district_skhi_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç –¥–ª—è –°–•–ò (–°–µ–ª—å—Å–∫–æ—Ö–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç–∏—Ç—É—Ç)"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='shi'), code=301)

@app.route('/district/<district>')
def district_detail(district):
    """Individual district page"""
    try:
        # Import District model
        from models import District
        
        # Get properties and complexes in this district
        properties = load_properties()
        complexes = load_residential_complexes()
        
        # Filter by district (simplified district matching)
        district_properties = [p for p in properties if district.replace('-', ' ').lower() in p.get('address', '').lower()]
        district_complexes = [c for c in complexes if district.replace('-', ' ').lower() in c.get('district', '').lower()]
        
        # Add cashback calculations
        for prop in district_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # District info mapping - all 54 districts
        district_names = {
            '40-let-pobedy': '40 –ª–µ—Ç –ü–æ–±–µ–¥—ã',
            '9i-kilometr': '9-–π –∫–∏–ª–æ–º–µ—Ç—Ä', 
            'aviagorodok': '–ê–≤–∏–∞–≥–æ—Ä–æ–¥–æ–∫',
            'avrora': '–ê–≤—Ä–æ—Ä–∞',
            'basket-hall': '–ë–∞—Å–∫–µ—Ç-—Ö–æ–ª–ª',
            'berezovy': '–ë–µ—Ä–µ–∑–æ–≤—ã–π',
            'cheremushki': '–ß–µ—Ä–µ–º—É—à–∫–∏',
            'dubinka': '–î—É–±–∏–Ω–∫–∞',
            'enka': '–≠–Ω–∫–∞',
            'festivalny': '–§–µ—Å—Ç–∏–≤–∞–ª—å–Ω—ã–π',
            'gidrostroitelei': '–ì–∏–¥—Ä–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–µ–π',
            'gorkhutor': '–ì–æ—Ä—Ö—É—Ç–æ—Ä',
            'hbk': '–•–ë–ö',
            'kalinino': '–ö–∞–ª–∏–Ω–∏–Ω–æ',
            'karasunsky': '–ö–∞—Ä–∞—Å—É–Ω—Å–∫–∏–π',
            'kolosisty': '–ö–æ–ª–æ—Å–∏—Å—Ç—ã–π',
            'komsomolsky': '–ö–æ–º—Å–æ–º–æ–ª—å—Å–∫–∏–π',
            'kozhzavod': '–ö–æ–∂–∑–∞–≤–æ–¥',
            'krasnaya-ploshchad': '–ö—Ä–∞—Å–Ω–∞—è –ø–ª–æ—â–∞–¥—å',
            'krasnodarskiy': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π',
            'kubansky': '–ö—É–±–∞–Ω—Å–∫–∏–π',
            'mkg': '–ú–ö–ì',
            'molodezhny': '–ú–æ–ª–æ–¥–µ–∂–Ω—ã–π',
            'muzykalny-mkr': '–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π –º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω',
            'nemetskaya-derevnya': '–ù–µ–º–µ—Ü–∫–∞—è –¥–µ—Ä–µ–≤–Ω—è',
            'novoznamenskiy': '–ù–æ–≤–æ–∑–Ω–∞–º–µ–Ω—Å–∫–∏–π',
            'panorama': '–ü–∞–Ω–æ—Ä–∞–º–∞',
            'pashkovskiy': '–ü–∞—à–∫–æ–≤—Å–∫–∏–π',
            'pashkovsky': '–ü–∞—à–∫–æ–≤—Å–∫–∏–π-2',
            'pokrovka': '–ü–æ–∫—Ä–æ–≤–∫–∞',
            'prikubansky': '–ü—Ä–∏–∫—É–±–∞–Ω—Å–∫–∏–π',
            'rayon-aeroporta': '–†–∞–π–æ–Ω –∞—ç—Ä–æ–ø–æ—Ä—Ç–∞',
            'repino': '–†–µ–ø–∏–Ω–æ',
            'rip': '–†–ò–ü',
            'severny': '–°–µ–≤–µ—Ä–Ω—ã–π',
            'shkolny': '–®–∫–æ–ª—å–Ω—ã–π',
            'slavyansky': '–°–ª–∞–≤—è–Ω—Å–∫–∏–π',
            'slavyansky2': '–°–ª–∞–≤—è–Ω—Å–∫–∏–π-2',
            'solnechny': '–°–æ–ª–Ω–µ—á–Ω—ã–π',
            'tabachnaya-fabrika': '–¢–∞–±–∞—á–Ω–∞—è —Ñ–∞–±—Ä–∏–∫–∞',
            'tec': '–¢–≠–¶',
            'tsentralnyy': '–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π',
            'uchhoz-kuban': '–£—á—Ö–æ–∑ –ö—É–±–∞–Ω—å',
            'vavilova': '–í–∞–≤–∏–ª–æ–≤–∞',
            'votochno-kruglikovskii': '–í–æ—Å—Ç–æ—á–Ω–æ-–ö—Ä—É–≥–ª–∏–∫–æ–≤—Å–∫–∏–π',
            'yablonovskiy': '–Ø–±–ª–æ–Ω–æ–≤—Å–∫–∏–π',
            'zapadny': '–ó–∞–ø–∞–¥–Ω—ã–π',
            'zapadny-obhod': '–ó–∞–ø–∞–¥–Ω—ã–π –æ–±—Ö–æ–¥',
            'zapadny-okrug': '–ó–∞–ø–∞–¥–Ω—ã–π –æ–∫—Ä—É–≥',
            'zip-zhukova': '–ó–ò–ü –ñ—É–∫–æ–≤–∞'
        }
        
        # Get district data from database with coordinates
        district_db = District.query.filter_by(slug=district).first()
        
        # Use district name from database if available, otherwise fallback to mapping
        if district_db and district_db.name:
            district_name = district_db.name
        else:
            district_name = district_names.get(district, district.replace('-', ' ').title())
        
        # Prepare district data for template
        infrastructure_data = None
        if district_db and district_db.infrastructure_data:
            try:
                import json
                if isinstance(district_db.infrastructure_data, str):
                    infrastructure_data = json.loads(district_db.infrastructure_data)
                else:
                    infrastructure_data = district_db.infrastructure_data
            except Exception as e:
                print(f"Infrastructure parsing error: {e}")
                infrastructure_data = None
        
        district_data = {
            'name': district_name,
            'slug': district,
            'latitude': district_db.latitude if district_db and district_db.latitude else None,
            'longitude': district_db.longitude if district_db and district_db.longitude else None,
            'zoom_level': district_db.zoom_level if district_db and district_db.zoom_level else 13,
            'description': district_db.description if district_db else None,
            'distance_to_center': getattr(district_db, 'distance_to_center', None) if district_db else None,
            'infrastructure_data': infrastructure_data,
            'geometry': getattr(district_db, 'geometry', None) if district_db else None,
            'geometry_source': getattr(district_db, 'geometry_source', None) if district_db else None
        }
        
        return render_template('district_detail.html', 
                             district=district,
                             district_name=district_name,
                             district_data=district_data,
                             properties=district_properties,
                             complexes=district_complexes,
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    except Exception as e:
        # Log detailed error for debugging
        import traceback
        print(f"ERROR in district_detail route: {e}")
        print("Full traceback:")
        traceback.print_exc()
        
        # Return error page
        from flask import render_template_string
        error_template = """
        <html>
        <head><title>–û—à–∏–±–∫–∞ - InBack.ru</title></head>
        <body>
            <h1>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞</h1>
            <p>–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ä–∞–π–æ–Ω–∞ {{ district }}.</p>
            <p>–û—à–∏–±–∫–∞: {{ error }}</p>
            <a href="/">–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
        </body>
        </html>
        """
        return render_template_string(error_template, district=district, error=str(e)), 500


# Content pages routes are already defined above

# API endpoint for infrastructure data
@app.route('/api/infrastructure')
def get_infrastructure():
    """API endpoint to get infrastructure data for coordinates"""
    try:
        lat = request.args.get('lat', type=float)
        lng = request.args.get('lng', type=float)
        radius = request.args.get('radius', 2000, type=int)
        
        if not lat or not lng:
            return jsonify({'error': 'Coordinates required'}), 400
        
        # Import infrastructure functions
        from infrastructure_api import get_poi_around_coordinates
        
        # Get POI data
        poi_data = get_poi_around_coordinates(lat, lng, radius)
        
        return jsonify(poi_data)
        
    except Exception as e:
        print(f"Error getting infrastructure data: {e}")
        return jsonify({'error': 'Failed to get infrastructure data'}), 500

# API endpoint for district streets
@app.route('/api/streets/district/<district_slug>')
def get_district_streets(district_slug):
    """API endpoint to get streets for a specific district"""
    try:
        from models import Street, District
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–π–æ–Ω –ø–æ slug
        district = District.query.filter_by(slug=district_slug).first()
        if not district:
            return jsonify({'error': 'District not found'}), 404
        
        # –ü–æ–ª—É—á–∞–µ–º —É–ª–∏—Ü—ã —Ä–∞–π–æ–Ω–∞ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
        streets = Street.query.filter_by(district_id=district.id).filter(
            Street.latitude.isnot(None),
            Street.longitude.isnot(None)
        ).all()
        
        streets_data = []
        for street in streets:
            streets_data.append({
                'id': street.id,
                'name': street.name,
                'slug': street.slug,
                'latitude': float(street.latitude) if street.latitude else None,
                'longitude': float(street.longitude) if street.longitude else None,
                'description': street.description
            })
        
        return jsonify(streets_data)
        
    except Exception as e:
        print(f"Error getting district streets: {e}")
        return jsonify({'error': 'Failed to get district streets'}), 500

# Privacy and legal pages
@app.route('/privacy-policy')
def privacy_policy():
    """Privacy policy page"""
    return render_template('privacy_policy.html')

def parse_user_agent(user_agent):
    """–ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ User-Agent —Å—Ç—Ä–æ–∫–∏"""
    info = {
        'raw': user_agent,
        'browser': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'version': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'os': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'device': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
    }
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±—Ä–∞—É–∑–µ—Ä
    if 'Chrome' in user_agent and 'Edg' not in user_agent:
        info['browser'] = 'Chrome'
        if 'Chrome/' in user_agent:
            version = user_agent.split('Chrome/')[1].split()[0]
            info['version'] = version
    elif 'Firefox' in user_agent:
        info['browser'] = 'Firefox'
        if 'Firefox/' in user_agent:
            version = user_agent.split('Firefox/')[1].split()[0]
            info['version'] = version
    elif 'Edg' in user_agent:
        info['browser'] = 'Microsoft Edge'
        if 'Edg/' in user_agent:
            version = user_agent.split('Edg/')[1].split()[0]
            info['version'] = version
    elif 'Safari' in user_agent and 'Chrome' not in user_agent:
        info['browser'] = 'Safari'
        if 'Version/' in user_agent:
            version = user_agent.split('Version/')[1].split()[0]
            info['version'] = version
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –û–°
    if 'Windows NT' in user_agent:
        info['os'] = 'Windows'
        if 'Windows NT 10.0' in user_agent:
            info['os'] = 'Windows 10/11'
    elif 'Mac OS X' in user_agent:
        info['os'] = 'macOS'
    elif 'Linux' in user_agent:
        info['os'] = 'Linux'
    elif 'Android' in user_agent:
        info['os'] = 'Android'
    elif 'iPhone' in user_agent:
        info['os'] = 'iOS'
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    if 'Mobile' in user_agent or 'Android' in user_agent or 'iPhone' in user_agent:
        info['device'] = '–ú–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ'
    elif 'Tablet' in user_agent or 'iPad' in user_agent:
        info['device'] = '–ü–ª–∞–Ω—à–µ—Ç'
    else:
        info['device'] = '–î–µ—Å–∫—Ç–æ–ø'
    
    return info

@app.route('/technical-info')
def technical_info():
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Å–µ—Å—Å–∏–∏ –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ"""
    import platform
    import socket
    import uuid
    import secrets
    from datetime import datetime
    from flask_login import current_user
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º session_id –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
    if 'session_id' not in session:
        session['session_id'] = secrets.token_hex(16)
    
    # –ü–∞—Ä—Å–∏–º User-Agent –¥–ª—è –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    user_agent = request.headers.get('User-Agent', '')
    browser_info = parse_user_agent(user_agent)
    
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    tech_info = {
        'server_info': {
            'server_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'platform': platform.platform(),
            'python_version': platform.python_version(),
            'hostname': socket.gethostname(),
            'flask_version': '2.3.3',  # –∏–ª–∏ –ø–æ–ª—É—á–∏—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
            'environment': 'development'
        },
        'session_info': {
            'session_id': session.get('session_id'),
            'user_id': current_user.id if current_user.is_authenticated else '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω',
            'username': current_user.full_name if current_user.is_authenticated and hasattr(current_user, 'full_name') else '–ì–æ—Å—Ç—å',
            'is_authenticated': current_user.is_authenticated,
            'session_permanent': session.permanent
        },
        'request_info': {
            'user_agent': user_agent,
            'ip_address': request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr),
            'method': request.method,
            'url': request.url,
            'referrer': request.headers.get('Referer', '–ü—Ä—è–º–æ–π –ø–µ—Ä–µ—Ö–æ–¥'),
            'accept_language': request.headers.get('Accept-Language', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'accept_encoding': request.headers.get('Accept-Encoding', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'content_type': request.headers.get('Content-Type', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'host': request.headers.get('Host', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
        },
        'browser_info': browser_info
    }
    
    return render_template('technical_info.html', tech_info=tech_info)

@app.route('/data-processing-consent')
def data_processing_consent():
    """Data processing consent page"""
    return render_template('data_processing_consent.html')

# Override Flask-Login unauthorized handler for API routes
@login_manager.unauthorized_handler  
def handle_unauthorized():
    # Check if this is an API route
    if request.path.startswith('/api/'):
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    # Regular redirect for web routes
    return redirect(url_for('login', next=request.url))

# User loader for Flask-Login
@login_manager.user_loader
def load_user(user_id):
    from models import User, Manager
    
    # Check if this is a manager ID (with prefix 'm_')
    if user_id.startswith('m_'):
        manager_id = int(user_id[2:])  # Remove 'm_' prefix
        manager = Manager.query.get(manager_id)
        if manager:
            return manager
    else:
        # Regular user ID
        try:
            user = User.query.get(int(user_id))
            if user:
                return user
        except ValueError:
            pass
    
    return None

def manager_required(f):
    """Decorator to require manager authentication via session"""
    from functools import wraps
    from models import Manager
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        print(f"DEBUG: manager_required - checking session authentication")
        print(f"DEBUG: manager_required - request.path: {request.path}")
        print(f"DEBUG: manager_required - request.method: {request.method}")
        print(f"DEBUG: manager_required - session.get('manager_id'): {session.get('manager_id')}")
        print(f"DEBUG: manager_required - session.get('is_manager'): {session.get('is_manager')}")
        
        # Check if this is an AJAX or JSON request
        is_ajax = (request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 
                   request.content_type == 'application/json' or
                   request.path.startswith('/api/'))
        
        # Check if manager is authenticated via session
        manager_id = session.get('manager_id')
        is_manager = session.get('is_manager')
        
        if not manager_id or not is_manager:
            print(f"DEBUG: manager_required - Manager not authenticated via session")
            if is_ajax:
                return jsonify({'success': False, 'error': 'Authentication required'}), 401
            return redirect(url_for('manager_login'))
        
        # Verify manager still exists in database
        try:
            manager = Manager.query.get(manager_id)
            if not manager:
                print(f"DEBUG: manager_required - Manager ID {manager_id} not found in database")
                # Clear invalid session
                session.pop('manager_id', None)
                session.pop('is_manager', None)
                if is_ajax:
                    return jsonify({'success': False, 'error': 'Authentication required'}), 401
                return redirect(url_for('manager_login'))
        except Exception as e:
            print(f"DEBUG: manager_required - Database error: {e}")
            if is_ajax:
                return jsonify({'success': False, 'error': 'Authentication error'}), 500
            return redirect(url_for('manager_login'))
        
        print(f"DEBUG: manager_required - Success! Manager {manager.email} authenticated via session")
        return f(*args, **kwargs)
    return decorated_function

# Authentication routes
@app.route('/set-demo-password')
def set_demo_password():
    """–í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–æ—É—Ç –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è –¥–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
    from models import User
    from werkzeug.security import generate_password_hash
    
    # –ù–∞–π—Ç–∏ –¥–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    demo_user = User.query.filter_by(email='demo@inback.ru').first()
    if demo_user:
        # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä–æ–ª—å "demo123"
        demo_user.password_hash = generate_password_hash('demo123')
        db.session.commit()
        return f"–ü–∞—Ä–æ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {demo_user.email}. –•—ç—à: {demo_user.password_hash[:50]}..."
    else:
        return "–î–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"

@app.route('/set-managers-passwords')
def set_managers_passwords():
    """–í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–æ—É—Ç –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä–æ–ª–µ–π –≤—Å–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º"""
    from models import Manager
    from werkzeug.security import generate_password_hash
    
    results = []
    
    # –ù–∞–π—Ç–∏ –≤—Å–µ—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å—Ç—ã–µ –ø–∞—Ä–æ–ª–∏
    managers = Manager.query.all()
    for manager in managers:
        if 'anna' in manager.email.lower():
            password = 'anna123'
        elif 'sergey' in manager.email.lower():
            password = 'sergey123'  
        elif 'maria' in manager.email.lower():
            password = 'maria123'
        else:
            password = 'manager123'  # –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
            
        manager.password_hash = generate_password_hash(password)
        results.append(f"{manager.email} -> {password}")
    
    db.session.commit()
    return f"–ü–∞—Ä–æ–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {len(managers)} –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤:<br>" + "<br>".join(results)

@app.route('/login', methods=['GET', 'POST'])
@csrf.exempt
def login():
    """Login page"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        from models import User
        email = request.form.get('email')
        password = request.form.get('password')
        remember = request.form.get('remember') == 'on'
        
        if not email or not password:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
            return render_template('auth/login.html')
        
        # Check if email or phone
        user = User.query.filter(
            (User.email == email) | (User.phone == email)
        ).first()
        
        if user:
            # Check if user needs to set password
            if user.needs_password_setup():
                session['temp_user_id'] = user.id
                flash('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å –¥–ª—è –≤—Ö–æ–¥–∞', 'info')
                return redirect(url_for('setup_password'))
            
            # Check if email is verified
            if not user.is_verified:
                flash('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ email –∏–ª–∏ –∑–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤–æ–µ –ø–∏—Å—å–º–æ.', 'warning')
                # Pass user email to template for resend functionality
                return render_template('auth/login.html', unverified_email=user.email)
            
            # Normal password check
            password_valid = user.check_password(password)
            if password_valid:
                # Clear manager session data if exists
                session.pop('manager_id', None)
                session.pop('is_manager', None)
                
                login_user(user, remember=remember)
                user.last_login = datetime.utcnow()
                db.session.commit()
                
                # Redirect to next page or dashboard
                next_page = request.args.get('next')
                return redirect(next_page) if next_page else redirect(url_for('dashboard'))
            else:
                flash('–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å', 'error')
        else:
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
    
    return render_template('auth/login.html')

@app.route('/setup-password', methods=['GET', 'POST'])
def setup_password():
    """Setup password for users created by managers"""
    temp_user_id = session.get('temp_user_id')
    if not temp_user_id:
        flash('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', 'error')
        return redirect(url_for('login'))
    
    from models import User
    user = User.query.get(temp_user_id)
    if not user or not user.needs_password_setup():
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω', 'error')
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        
        if not password or not confirm_password:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if len(password) < 8:
            flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if password != confirm_password:
            flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        # Set password
        user.set_password(password)
        user.is_verified = True
        db.session.commit()
        
        # Clear temp session and manager data
        session.pop('temp_user_id', None)
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        # Login user
        login_user(user)
        user.last_login = datetime.utcnow()
        db.session.commit()
        
        flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!', 'success')
        return redirect(url_for('dashboard'))
    
    return render_template('auth/setup_password.html', user=user)

@app.route('/register', methods=['POST'])
def register():
    """User registration"""
    from models import User
    
    full_name = request.form.get('full_name')
    email = request.form.get('email')
    phone = request.form.get('phone')
    password = request.form.get('password')
    confirm_password = request.form.get('confirm_password')
    terms = request.form.get('terms')
    
    # Validation
    if not all([full_name, email, password, confirm_password, terms]):
        flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
        return redirect(url_for('login'))
    
    if password != confirm_password:
        flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
        return redirect(url_for('login'))
    
    if not password or len(password) < 8:
        flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
        return redirect(url_for('login'))
    
    # Check if user exists
    if User.query.filter_by(email=email).first():
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
        return redirect(url_for('login'))
    
    # Create new user
    user = User(
        full_name=full_name,
        email=email,
        phone=phone
    )
    user.set_password(password)
    
    try:
        db.session.add(user)
        db.session.commit()
        
        # Send welcome notification with verification link
        try:
            from email_service import send_verification_email
            send_verification_email(user, base_url=request.url_root.rstrip('/'))
        except Exception as e:
            print(f"Error sending verification email: {e}")
        
        # Clear manager session data if exists
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        # DON'T login user immediately - require email verification first
        # login_user(user)  # REMOVED - user must verify email first
        
        flash('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ email –∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞.', 'success')
        return redirect(url_for('login'))
        
    except Exception as e:
        db.session.rollback()
        print(f"Registration error: {e}")
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {str(e)}', 'error')
        return redirect(url_for('login'))

@app.route('/confirm/<token>')
def confirm_email(token):
    """Email confirmation endpoint"""
    from models import User
    
    try:
        # Find user by verification token
        user = User.query.filter_by(verification_token=token).first()
        
        if not user:
            flash('–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è', 'error')
            return redirect(url_for('login'))
        
        if user.is_verified:
            flash('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('login'))
        
        # Confirm user
        user.is_verified = True
        user.verification_token = None  # Clear the token
        db.session.commit()
        
        # Send welcome email after verification
        try:
            from email_service import send_welcome_email
            send_welcome_email(user, base_url=request.url_root.rstrip('/'))
        except Exception as e:
            print(f"Error sending welcome email: {e}")
        
        flash('Email —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω! –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç.', 'success')
        return redirect(url_for('login'))
        
    except Exception as e:
        print(f"Email confirmation error: {e}")
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ email', 'error')
        return redirect(url_for('login'))

@app.route('/resend-verification', methods=['POST'])
@require_json_csrf
def resend_verification():
    """Resend verification email with rate limiting and enhanced security"""
    import re
    from models import User, EmailVerificationAttempt
    
    # Get request data - support both form and JSON
    if request.content_type == 'application/json':
        data = request.get_json() or {}
        email = data.get('email', '').strip().lower()
    else:
        email = request.form.get('email', '').strip().lower()
    
    # Get client info for logging
    ip_address = request.environ.get('HTTP_X_FORWARDED_FOR', request.environ.get('REMOTE_ADDR'))
    user_agent = request.headers.get('User-Agent', '')[:500]
    
    # Validate email format
    if not email:
        error_msg = '–í–≤–µ–¥–∏—Ç–µ email –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏'
        EmailVerificationAttempt.log_attempt(email or 'empty', ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Basic email format validation
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        error_msg = '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email –∞–¥—Ä–µ—Å'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Check rate limiting (5 minutes between successful attempts)
    if not EmailVerificationAttempt.can_resend_verification(email, rate_limit_minutes=5):
        error_msg = '–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç—ã–µ –∑–∞–ø—Ä–æ—Å—ã. –ü–æ–¥–æ–∂–¥–∏—Ç–µ 5 –º–∏–Ω—É—Ç –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–æ–π.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'warning')
        return redirect(url_for('login'))
    
    # Check for suspicious activity (more than 10 attempts in 1 hour)
    recent_attempts = EmailVerificationAttempt.get_recent_attempts_count(email, hours=1)
    if recent_attempts >= 10:
        error_msg = '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Find user
    user = User.query.filter_by(email=email).first()
    
    if not user:
        # Don't reveal whether user exists for security
        success_msg = '–ï—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç —Å —Ç–∞–∫–∏–º email —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–∏—Å—å–º–æ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, 'User not found')
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'info')
        return redirect(url_for('login'))
    
    if user.is_verified:
        error_msg = '–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'info')
        return redirect(url_for('login'))
    
    # Generate new verification token
    user.verification_token = secrets.token_urlsafe(32)
    db.session.commit()
    
    # Send new verification email
    try:
        from email_service import send_verification_email
        send_verification_email(user, base_url=request.url_root.rstrip('/'))
        
        # Log successful attempt
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, True, None)
        
        success_msg = '–ü–∏—Å—å–º–æ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à email.'
        print(f"‚úÖ VERIFICATION RESEND SUCCESS: Email sent to {email} from IP {ip_address}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'success')
        
    except Exception as e:
        error_msg = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∏—Å—å–º–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, str(e)[:200])
        print(f"‚ùå VERIFICATION RESEND ERROR: {e} for email {email}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 500
        flash(error_msg, 'error')
    
    return redirect(url_for('login'))

@app.route('/quiz-registration')
def quiz_registration():
    """Show quiz registration page"""
    return render_template('quiz_registration.html')

@app.route('/callback-request')
def callback_request_page():
    """Show callback request page"""
    return render_template('callback_request.html')

@app.route('/api/property-selection', methods=['POST'])
def property_selection():
    """Property selection application"""
    from models import Application, User
    data = request.get_json()
    
    try:
        # Extract data
        email = data.get('email', '').strip().lower()
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        
        # Application preferences
        preferred_district = data.get('preferred_district', '')
        property_type = data.get('property_type', '')
        room_count = data.get('room_count', '')
        budget_range = data.get('budget_range', '')
        
        # Property context information
        property_id = data.get('property_id')
        property_title = data.get('property_title', '')
        property_complex = data.get('property_complex', '')
        property_price = data.get('property_price')
        property_area = data.get('property_area')
        property_rooms = data.get('property_rooms')
        property_floor = data.get('property_floor')
        property_total_floors = data.get('property_total_floors')
        property_district = data.get('property_district', '')
        property_url = data.get('property_url', '')
        property_type_context = data.get('property_type_context', '')
        
        # Validation
        if not email or not name or not phone:
            return jsonify({'success': False, 'error': '–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã'})
        
        # Determine application type and build message
        is_specific_property = property_id and property_type_context == 'property'
        is_specific_complex = property_id and property_type_context == 'complex'
        
        if is_specific_property:
            # Specific property interest
            application_title = f"–ò–Ω—Ç–µ—Ä–µ—Å –∫ –∫–≤–∞—Ä—Ç–∏—Ä–µ: {property_title}"
            complex_name = property_complex or '–ù–µ —É–∫–∞–∑–∞–Ω'
            message = f"–ó–∞—è–≤–∫–∞ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–≤–∞—Ä—Ç–∏—Ä–µ:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n\n"
            message += f"=== –û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê ===\n"
            message += f"–ö–≤–∞—Ä—Ç–∏—Ä–∞: {property_title}\n"
            message += f"–ñ–ö: {property_complex}\n"
            if property_price:
                try:
                    formatted_price = f"{int(property_price):,}".replace(',', ' ')
                    message += f"–¶–µ–Ω–∞: {formatted_price} ‚ÇΩ\n"
                except (ValueError, TypeError):
                    message += f"–¶–µ–Ω–∞: {property_price} ‚ÇΩ\n"
            if property_area:
                message += f"–ü–ª–æ—â–∞–¥—å: {property_area} –º¬≤\n"
            if property_floor and property_total_floors:
                message += f"–≠—Ç–∞–∂: {property_floor}/{property_total_floors}\n"
            if property_district:
                message += f"–†–∞–π–æ–Ω: {property_district}\n"
            if property_url:
                message += f"–°—Å—ã–ª–∫–∞: {property_url}\n"
            message += f"\n=== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø ===\n"
            message += f"–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —Ä–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        elif is_specific_complex:
            # Specific complex interest
            application_title = f"–ò–Ω—Ç–µ—Ä–µ—Å –∫ –ñ–ö: {property_title}"
            complex_name = property_title
            message = f"–ó–∞—è–≤–∫–∞ –ø–æ –∂–∏–ª–æ–º—É –∫–æ–º–ø–ª–µ–∫—Å—É:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n\n"
            message += f"=== –û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê ===\n"
            message += f"–ñ–ö: {property_title}\n"
            if property_district:
                message += f"–†–∞–π–æ–Ω: {property_district}\n"
            if property_url:
                message += f"–°—Å—ã–ª–∫–∞: {property_url}\n"
            message += f"\n=== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø ===\n"
            message += f"–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —Ä–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        else:
            # General property selection
            application_title = "–ü–æ–¥–±–æ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã"
            complex_name = "–ü–æ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º"
            message = f"–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
            message += f"–†–∞–π–æ–Ω: {preferred_district or '–õ—é–±–æ–π'}\n"
            message += f"–¢–∏–ø: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        
        # Create application
        application = Application(
            user_id=None,  # No user account needed for applications
            property_id=property_id,  # Store specific property ID if available
            property_name=application_title,
            complex_name=complex_name,
            message=message,
            status='new',
            contact_name=name,
            contact_email=email,
            contact_phone=phone
        )
        
        db.session.add(application)
        
        # Application submitted successfully
        db.session.commit()
        
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Calculate potential cashback (2% of average budget)
            potential_cashback = ""
            if budget_range:
                if "–º–ª–Ω" in budget_range:
                    # Extract average from range like "3-5 –º–ª–Ω"
                    numbers = [float(x) for x in budget_range.replace(" –º–ª–Ω", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                    if numbers:
                        avg_price = sum(numbers) / len(numbers) * 1000000
                        cashback = int(avg_price * 0.02)
                        formatted_cashback = f"{cashback:,}".replace(',', ' ')
                        potential_cashback = f"üí∞ *–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫:* {formatted_cashback} —Ä—É–±. (2%)\n"
            
            # Build telegram message based on application type
            if is_specific_property:
                telegram_message = f"""üè† *–ó–ê–Ø–í–ö–ê –ü–û –ö–û–ù–ö–†–ï–¢–ù–û–ô –ö–í–ê–†–¢–ò–†–ï*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üè° *–û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê:*
‚Ä¢ –ö–≤–∞—Ä—Ç–∏—Ä–∞: {property_title}
‚Ä¢ –ñ–ö: {property_complex}
{f"‚Ä¢ –¶–µ–Ω–∞: {int(property_price):,} ‚ÇΩ".replace(',', ' ') if property_price else ''}
{f"‚Ä¢ –ü–ª–æ—â–∞–¥—å: {property_area} –º¬≤" if property_area else ''}
{f"‚Ä¢ –≠—Ç–∞–∂: {property_floor}/{property_total_floors}" if property_floor and property_total_floors else ''}
{f"‚Ä¢ –°—Å—ã–ª–∫–∞: {property_url}" if property_url else ''}

üîç *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–≤–∞—Ä—Ç–∏—Ä—ã –Ω–∞ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –û–±—Å—É–¥–∏—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é –∫–≤–∞—Ä—Ç–∏—Ä—É
3Ô∏è‚É£ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫—ç—à–±–µ–∫ –∏ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ö–ª–∏–µ–Ω—Ç —É–∂–µ –≤—ã–±—Ä–∞–ª –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –∫–≤–∞—Ä—Ç–∏—Ä—É!"""
            elif is_specific_complex:
                telegram_message = f"""üè¢ *–ó–ê–Ø–í–ö–ê –ü–û –ñ–ò–õ–û–ú–£ –ö–û–ú–ü–õ–ï–ö–°–£*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üèóÔ∏è *–û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê:*
‚Ä¢ –ñ–ö: {property_title}
{f"‚Ä¢ –†–∞–π–æ–Ω: {property_district}" if property_district else ''}
{f"‚Ä¢ –°—Å—ã–ª–∫–∞: {property_url}" if property_url else ''}

üîç *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –°—Ç—Ä–∞–Ω–∏—Ü–∞ –ñ–ö –Ω–∞ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –ü–æ–∫–∞–∑–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –≤ –ñ–ö
3Ô∏è‚É£ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫—ç—à–±–µ–∫ –∏ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ö–ª–∏–µ–Ω—Ç –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –ñ–ö!"""
            else:
                telegram_message = f"""üè† *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ü–û–î–ë–û–† –ö–í–ê–†–¢–ò–†–´*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üîç *–ö–†–ò–¢–ï–†–ò–ò –ü–û–ò–°–ö–ê:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–õ—é–±–æ–π'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –§–æ—Ä–º–∞ –Ω–∞ —Å–∞–π—Ç–µ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –£—Ç–æ—á–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è
3Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø–æ–¥–±–æ—Ä–∫—É –æ–±—ä–µ–∫—Ç–æ–≤
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è –ø–æ–≤—ã—à–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏—é!"""
            
            send_telegram_message('730764738', telegram_message)
            
        except Exception as notify_error:
            print(f"Notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏.'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Application error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏'})

@app.route('/api/callback-request', methods=['POST'])
def api_callback_request():
    """Submit callback request"""
    from models import CallbackRequest, Manager
    data = request.get_json()
    
    try:
        # Extract data
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        email = data.get('email', '').strip()
        preferred_time = data.get('preferred_time', '')
        notes = data.get('notes', '').strip()
        
        # Quiz responses
        district = data.get('district', '').strip()
        interest = data.get('interest', '')
        budget = data.get('budget', '')
        timing = data.get('timing', '')
        
        # Validation
        if not name or not phone:
            return jsonify({'success': False, 'error': '–ò–º—è –∏ —Ç–µ–ª–µ—Ñ–æ–Ω –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è'})
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–≥—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–∞–π–æ–Ω–∞, –¥–µ–ª–∞–µ–º optional
        if not district:
            district = '–ù–µ —É–∫–∞–∑–∞–Ω'
        
        # Create callback request
        callback_req = CallbackRequest(
            name=name,
            phone=phone,
            email=email or None,
            preferred_time=preferred_time,
            notes=notes,
            interest=interest,
            budget=budget,
            timing=timing
        )
        
        # Auto-assign to first available manager
        available_manager = Manager.query.filter_by(is_active=True).first()
        if available_manager:
            callback_req.assigned_manager_id = available_manager.id
        
        db.session.add(callback_req)
        db.session.commit()
        
        # Send notifications
        try:
            send_callback_notification_email(callback_req, available_manager)
            send_callback_notification_telegram(callback_req, available_manager)
        except Exception as e:
            print(f"Failed to send callback notifications: {e}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Callback request error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.'})

@app.route('/api/booking', methods=['POST'])
def api_booking_request():
    """Submit booking request for property"""
    from models import BookingRequest, Manager, ExcelProperty
    
    try:
        data = request.get_json()
        
        # Validate required fields
        property_id = data.get('property_id')
        client_name = data.get('client_name')
        client_phone = data.get('client_phone')
        presentation_id = data.get('presentation_id')
        
        if not all([property_id, client_name, client_phone]):
            return jsonify({'success': False, 'error': '–ù–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω—ã'}), 400
        
        # Find property details
        property_detail = ExcelProperty.query.filter_by(inner_id=int(property_id)).first()
        if not property_detail:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Create booking request
        booking = BookingRequest()
        booking.property_id = property_id
        booking.client_name = client_name
        booking.client_phone = client_phone
        booking.client_email = data.get('client_email')
        booking.comment = data.get('comment')
        booking.presentation_id = presentation_id
        booking.property_price = property_detail.price
        booking.property_address = property_detail.address_display_name
        booking.complex_name = property_detail.complex_name
        booking.rooms_count = property_detail.object_rooms
        booking.area = property_detail.area
        booking.status = 'new'
        
        db.session.add(booking)
        db.session.commit()
        
        # Notify managers
        try:
            send_booking_notifications(booking, property_detail)
        except Exception as notification_error:
            print(f"Notification error: {notification_error}")
            # Don't fail the booking if notifications fail
        
        return jsonify({
            'success': True, 
            'message': '–ó–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!',
            'booking_id': booking.id
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Booking request error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.'}), 500

def send_booking_notifications(booking, property_detail):
    """Send notifications to managers about new booking request"""
    from models import Manager
    
    # Get all active managers
    managers = Manager.query.filter_by(is_active=True).all()
    
    # Email notification (if configured)
    try:
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        subject = f"üè† –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ - {property_detail.complex_name}"
        
        # Prepare property details
        rooms_text = "–°—Ç—É–¥–∏—è" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è"
        
        body = f"""
üè† –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã

üìã –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–õ–ò–ï–ù–¢–ï:
üë§ –ò–º—è: {booking.client_name}
üì± –¢–µ–ª–µ—Ñ–æ–Ω: {booking.client_phone}
üìß Email: {booking.client_email or '–Ω–µ —É–∫–∞–∑–∞–Ω'}
üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {booking.comment or '–Ω–µ—Ç'}

üè¢ –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–í–ê–†–¢–ò–†–ï:
üè† –ñ–ö: {property_detail.complex_name}
üè† –¢–∏–ø: {rooms_text} –∫–≤–∞—Ä—Ç–∏—Ä–∞
üìê –ü–ª–æ—â–∞–¥—å: {property_detail.area} –º¬≤
üè¢ –≠—Ç–∞–∂: {property_detail.floor}/{property_detail.total_floors}
üí∞ –¶–µ–Ω–∞: {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ‚ÇΩ
üìç –ê–¥—Ä–µ—Å: {property_detail.address_display_name}
üèóÔ∏è –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: {property_detail.developer_name}
üîó ID –æ–±—ä–µ–∫—Ç–∞: {booking.property_id}

üìÖ –î–∞—Ç–∞ –∑–∞—è–≤–∫–∏: {booking.created_at.strftime('%d.%m.%Y %H:%M')}
üÜî ID –∑–∞—è–≤–∫–∏: {booking.id}

‚è∞ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç!
        """.strip()
        
        for manager in managers:
            if manager.email:
                try:
                    send_email_notification(manager.email, subject, body)
                except Exception as email_error:
                    print(f"Failed to send email to {manager.email}: {email_error}")
                    
    except Exception as e:
        print(f"Email notification error: {e}")
    
    # Telegram notification (if bot configured)
    try:
        send_telegram_booking_notification(booking, property_detail, managers)
    except Exception as e:
        print(f"Telegram notification error: {e}")

def send_email_notification(email, subject, body):
    """Send email notification"""
    import smtplib
    from email.mime.text import MIMEText
    
    # Simple email sending (would need proper SMTP configuration in production)
    print(f"üìß Would send email to {email}: {subject}")
    print(f"Body: {body[:100]}...")

def send_telegram_booking_notification(booking, property_detail, managers):
    """Send Telegram notification to managers"""
    try:
        import requests
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            print("Telegram bot token not configured")
            return
        
        rooms_text = "–°—Ç—É–¥–∏—è" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è"
        
        message = f"""
üè† <b>–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï</b>

üë§ <b>–ö–ª–∏–µ–Ω—Ç:</b> {booking.client_name}
üì± <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> {booking.client_phone}
üìß <b>Email:</b> {booking.client_email or '–Ω–µ —É–∫–∞–∑–∞–Ω'}

üè¢ <b>–ö–≤–∞—Ä—Ç–∏—Ä–∞:</b> {rooms_text}, {property_detail.area} –º¬≤
üè† <b>–ñ–ö:</b> {property_detail.complex_name}
üí∞ <b>–¶–µ–Ω–∞:</b> {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ‚ÇΩ
üìç <b>–ê–¥—Ä–µ—Å:</b> {property_detail.address_display_name}

üí¨ <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {booking.comment or '–Ω–µ—Ç'}
üÜî <b>ID –∑–∞—è–≤–∫–∏:</b> {booking.id}

‚è∞ <b>–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–≤—è–∑–∞—Ç—å—Å—è –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç!</b>
        """.strip()
        
        # Send to managers with telegram_chat_id
        for manager in managers:
            if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
                try:
                    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                    payload = {
                        'chat_id': manager.telegram_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    requests.post(url, data=payload, timeout=5)
                    print(f"üì± Telegram notification sent to manager {manager.name}")
                except Exception as telegram_error:
                    print(f"Failed to send Telegram to manager {manager.name}: {telegram_error}")
                    
    except Exception as e:
        print(f"Telegram notification setup error: {e}")

@app.route('/forgot-password', methods=['POST'])
def forgot_password():
    """Password reset request"""
    email = request.form.get('email')
    
    if not email:
        flash('–í–≤–µ–¥–∏—Ç–µ email –∞–¥—Ä–µ—Å', 'error')
        return redirect(url_for('login'))
    
    from models import User
    user = User.query.filter_by(email=email).first()
    
    if user:
        # Generate reset token and send email
        token = user.generate_verification_token()
        db.session.commit()
        
        try:
            from email_service import send_password_reset_email
            send_password_reset_email(user, token)
        except Exception as e:
            print(f"Error sending password reset email: {e}")
        
        flash('–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é –ø–∞—Ä–æ–ª—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ –≤–∞—à email', 'success')
    else:
        # Don't reveal that user doesn't exist
        flash('–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é –ø–∞—Ä–æ–ª—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ –≤–∞—à email', 'success')
    
    return redirect(url_for('login'))

# API endpoints for dashboard functionality
@app.route('/api/cashback-application', methods=['POST'])
@login_required
def create_cashback_application():
    """Create new cashback application"""
    from models import CashbackApplication
    data = request.get_json()
    
    try:
        app = CashbackApplication(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            cashback_amount=int(data['cashback_amount']),
            cashback_percent=float(data['cashback_percent'])
        )
        db.session.add(app)
        db.session.commit()
        
        return jsonify({'success': True, 'application_id': app.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/contact-manager', methods=['POST'])
@csrf.exempt  # CSRF disabled - –æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–æ–∫
def contact_manager():
    """API endpoint for contacting manager"""
    try:
        from models import Application
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['name', 'phone']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Field {field} is required'}), 400
        
        # Get current user if logged in
        user_id = session.get('user_id')
        
        # Create application with required fields
        application = Application(
            user_id=user_id,
            contact_name=data.get('name'),
            contact_email=data.get('email'),
            contact_phone=data.get('phone'),
            property_name=data.get('property_name', '–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∂–∏–ª—å—è'),
            complex_name=data.get('complex_name', '–ü–æ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º –∫–ª–∏–µ–Ω—Ç–∞'),
            status='new',
            message=data.get('message', f"–†–∞–π–æ–Ω: {data.get('district', '')}, –ö–æ–º–Ω–∞—Ç: {data.get('rooms', '')}, –ó–∞—Å–µ–ª–µ–Ω–∏–µ: {data.get('completion', '')}, –û–ø–ª–∞—Ç–∞: {data.get('payment', '')}"),
            preferred_contact=data.get('preferred_contact', 'phone')
        )
        
        db.session.add(application)
        db.session.commit()
        
        # Send notification to manager (email and Telegram)
        try:
            from email_service import send_manager_notification
            send_manager_notification(
                name=data.get('name'),
                phone=data.get('phone'),
                email=data.get('email'),
                message=data.get('message', ''),
                application_id=application.id
            )
        except Exception as e:
            print(f"Failed to send manager notification email: {e}")
            
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Check if this is for a specific property
            is_specific_property = data.get('property_id') and data.get('property_name')
            
            # Prepare Telegram message with quiz data or property info
            if is_specific_property:
                message_parts = [
                    "üè† *–ó–ê–Ø–í–ö–ê –ù–ê –ü–†–û–°–ú–û–¢–† –ö–û–ù–ö–†–ï–¢–ù–û–ô –ö–í–ê–†–¢–ò–†–´*",
                    "",
                    "üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*",
                    f"‚Ä¢ –ò–º—è: {data.get('name')}",
                    f"‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"‚Ä¢ Email: {data.get('email')}")
                    
                message_parts.extend([
                    "",
                    "üè¢ *–ò–ù–¢–ï–†–ï–°–£–Æ–©–ê–Ø –ö–í–ê–†–¢–ò–†–ê:*",
                    f"‚Ä¢ –û–±—ä–µ–∫—Ç: {data.get('property_name')}",
                ])
                
                if data.get('complex_name'):
                    message_parts.append(f"‚Ä¢ –ñ–ö: {data.get('complex_name')}")
                if data.get('property_price'):
                    price_formatted = f"{int(float(data.get('property_price'))):,}".replace(',', ' ')
                    message_parts.append(f"‚Ä¢ –¶–µ–Ω–∞: {price_formatted} —Ä—É–±.")
                if data.get('property_area'):
                    message_parts.append(f"‚Ä¢ –ü–ª–æ—â–∞–¥—å: {data.get('property_area')} –º¬≤")
                if data.get('property_floor'):
                    message_parts.append(f"‚Ä¢ –≠—Ç–∞–∂: {data.get('property_floor')}")
                if data.get('property_district'):
                    message_parts.append(f"‚Ä¢ –†–∞–π–æ–Ω: {data.get('property_district')}")
                if data.get('property_address'):
                    message_parts.append(f"‚Ä¢ –ê–¥—Ä–µ—Å: {data.get('property_address')}")
                    
                # Calculate potential cashback
                if data.get('property_price'):
                    try:
                        price = float(data.get('property_price'))
                        cashback = price * 0.03  # 3% cashback
                        cashback_formatted = f"{int(cashback):,}".replace(',', ' ')
                        message_parts.append(f"üí∞ –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫: {cashback_formatted} —Ä—É–±. (3%)")
                    except:
                        pass
                        
                # Add property URL if available
                if data.get('property_url'):
                    message_parts.extend([
                        "",
                        f"üîó *–°–°–´–õ–ö–ê –ù–ê –ö–í–ê–†–¢–ò–†–£:*",
                        f"{data.get('property_url')}"
                    ])
            else:
                message_parts = [
                    "üè† *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ü–û–î–ë–û–† –ñ–ò–õ–¨–Ø*",
                    "",
                    "üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*",
                    f"‚Ä¢ –ò–º—è: {data.get('name')}",
                    f"‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"‚Ä¢ Email: {data.get('email')}")
                    
                # Add quiz preferences if available
                if data.get('district'):
                    message_parts.extend([
                        "",
                        "üèòÔ∏è *–ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø –ö–õ–ò–ï–ù–¢–ê:*",
                        f"‚Ä¢ –†–∞–π–æ–Ω: {data.get('district')}"
                    ])
                    
                if data.get('rooms'):
                    message_parts.append(f"‚Ä¢ –ö–æ–º–Ω–∞—Ç: {data.get('rooms')}")
                    
                if data.get('completion'):
                    message_parts.append(f"‚Ä¢ –°—Ä–æ–∫ –∑–∞—Å–µ–ª–µ–Ω–∏—è: {data.get('completion')}")
                    
                if data.get('payment'):
                    message_parts.append(f"‚Ä¢ –°–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã: {data.get('payment')}")
                
            message_parts.extend([
                "",
                f"üìù *ID –∑–∞—è–≤–∫–∏:* #{application.id}",
                f"üìÖ *–í—Ä–µ–º—è:* {datetime.now().strftime('%d.%m.%Y %H:%M')}",
                "",
                "‚ö° *–í–ê–ñ–ù–û:* –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è –ø–æ–≤—ã—à–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏—é!"
            ])
            
            telegram_message = "\n".join(message_parts)
            
            # Send to all manager telegram IDs from environment variable
            manager_telegram_ids = os.environ.get('MANAGER_TELEGRAM_IDS', '').split(',')
            for manager_id in manager_telegram_ids:
                manager_id = manager_id.strip()
                if manager_id:
                    send_telegram_message(manager_id, telegram_message)
            
        except Exception as notify_error:
            print(f"Telegram notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.',
            'application_id': application.id
        })
        
    except Exception as e:
        print(f"Error creating manager contact application: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Internal server error'}), 500

@app.route('/api/favorites', methods=['POST'])
@login_required  
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def add_to_favorites():
    """Add property to favorites"""
    from models import FavoriteProperty
    data = request.get_json()
    
    # Check if already in favorites
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_name=data['property_name']
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–£–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'})
    
    try:
        favorite = FavoriteProperty(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            property_image=data.get('property_image'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0))
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/favorites/<property_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # ‚úÖ FIXED: CSRF protection removed for delete action as requested
def remove_from_favorites(property_id):
    """Remove property from favorites"""
    from models import FavoriteProperty
    
    favorite = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    else:
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404

def send_view_notification_to_manager(presentation, view):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä—É –æ –Ω–æ–≤–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    try:
        manager = presentation.created_by
        if not manager:
            print(f"Manager not found for presentation {presentation.id}")
            return
            
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ
        client_info = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∏–µ–Ω—Ç"
        if presentation.client_name:
            client_info = presentation.client_name
        elif presentation.client_phone:
            client_info = presentation.client_phone
            
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        notification_text = f"""üìä –ù–æ–≤—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏!

üìã "{presentation.title}"
üë§ –ö–ª–∏–µ–Ω—Ç: {client_info}
üî¢ –í—Å–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤: {presentation.view_count}
‚è∞ –í—Ä–µ–º—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {view.viewed_at.strftime('%d.%m.%Y %H:%M')}
üåê IP: {view.view_ip}
üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {view.user_agent[:50] + '...' if view.user_agent and len(view.user_agent) > 50 else view.user_agent or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}

üëÄ –°—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é: {request.url_root}presentation/modern/{presentation.unique_url}
üéØ –ü–∞–Ω–µ–ª—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {request.url_root}manager/dashboard"""

        # TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram Bot API
        # if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
        #     send_telegram_notification(manager.telegram_chat_id, notification_text)
        
        # TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Email
        # if manager.email:
        #     send_email_notification(manager.email, f"–ù–æ–≤—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä: {presentation.title}", notification_text)
        
        # –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        print(f"üìß NOTIFICATION TO MANAGER {manager.email}:")
        print(notification_text)
        print("-" * 50)
        
        # –û—Ç–º–µ—á–∞–µ–º —á—Ç–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
        view.notification_sent = True
        db.session.commit()
        
    except Exception as e:
        print(f"Error in send_view_notification_to_manager: {e}")

@app.route('/presentation/<string:unique_url>')
def redirect_old_presentation_url(unique_url):
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ URL –Ω–∞ –Ω–æ–≤—ã–π –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
    return redirect(url_for('view_presentation', unique_id=unique_url), code=301)

@app.route('/presentation/view/<string:unique_id>')
def view_presentation(unique_id):
    """–ü—É–±–ª–∏—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ"""
    print(f"üî• ROUTE HIT: /presentation/view/{unique_id}")
    print(f"üî• CLIENT IP: {request.remote_addr}")
    print(f"üî• USER AGENT: {request.headers.get('User-Agent', 'Unknown')}")
    from models import Collection, CollectionProperty, PresentationView
    
    # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ
    presentation = Collection.query.filter_by(
        unique_url=unique_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return render_template('error.html', 
                             error="–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 
                             message="–í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞ –∏–ª–∏ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞"), 404
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä
    try:
        view = PresentationView(
            collection_id=presentation.id,
            view_ip=request.remote_addr,
            user_agent=request.headers.get('User-Agent'),
            referer=request.headers.get('Referer')
        )
        db.session.add(view)
        
        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤ (–±–µ–∑ –∞–≤—Ç–æ–∫–æ–º–º–∏—Ç–∞)
        presentation.increment_view_count()
        db.session.commit()  # –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –Ω–∞ —É—Ä–æ–≤–Ω–µ view
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä—É –æ –Ω–æ–≤–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ
        try:
            send_view_notification_to_manager(presentation, view)
        except Exception as e:
            print(f"Error sending view notification: {e}")
        
    except Exception as e:
        db.session.rollback()
        print(f"Error recording presentation view: {e}")
    
    print("DEBUG: Starting data loading phase...")
    
    # Load properties data to enrich the collection properties
    try:
        print("DEBUG: Loading properties data...")
        properties_data = load_properties()
        print(f"DEBUG: Loaded {len(properties_data)} properties")
        
        print("DEBUG: Loading complexes data...")
        complexes_data = load_residential_complexes()
        print(f"DEBUG: Loaded {len(complexes_data) if complexes_data else 0} complexes")
    except Exception as e:
        print(f"ERROR: Failed to load data: {e}")
        import traceback
        traceback.print_exc()
        # Instead of returning 500, use empty data to allow page to render
        print("FALLBACK: Using empty data to allow page rendering")
        properties_data = []
        complexes_data = []
    
    # Enrich collection properties with full property data (same logic as manager version)
    enriched_properties = []
    for prop in presentation.properties:
        # Find the property in the main properties data
        property_data = None
        for p in properties_data:
            if str(p.get('id')) == str(prop.property_id):
                property_data = p
                break
        
        if property_data:
            # Get complex name from property_data
            complex_name = property_data.get('complex_name', prop.complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω')
            
            # Extract images
            images = []
            main_image = '/static/images/no-photo.jpg'
            
            # Parse photos/gallery field (check multiple possible field names)
            photos_raw = property_data.get('photos') or property_data.get('gallery') or property_data.get('images')
            if photos_raw:
                try:
                    import json
                    if isinstance(photos_raw, str) and photos_raw.startswith('['):
                        images = json.loads(photos_raw)
                    elif isinstance(photos_raw, list):
                        images = photos_raw
                    elif isinstance(photos_raw, str):
                        # Single image URL
                        images = [photos_raw]
                except:
                    pass
            
            # If no photos found, try the main image field
            if not images:
                main_img = property_data.get('image') or property_data.get('main_image')
                if main_img:
                    images = [main_img]
            
            if images and len(images) > 0:
                main_image = images[0]
            
            # Parse coordinates
            latitude = property_data.get('address_position_lat') or property_data.get('lat') or 0
            longitude = property_data.get('address_position_lon') or property_data.get('lon') or 0
            
            # Get full property details from the database
            try:
                from models import ExcelProperty
                property_detail = ExcelProperty.query.filter_by(inner_id=str(prop.property_id)).first()
                
                # Enhanced property data with full details
                enhanced_images = images
                enhanced_main_image = main_image
                enhanced_layout = property_data.get('layout_image')
                enhanced_address = property_data.get('address_display_name', '')
                enhanced_description = property_data.get('description', '')
                enhanced_features = property_data.get('features', [])
                enhanced_developer = property_data.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω')
                
                # Use property_detail database data if available for richer content
                if property_detail:
                    enhanced_address = property_detail.address_display_name or enhanced_address
                    enhanced_developer = property_detail.developer_name or enhanced_developer
                    
                    # Get photos from database
                    if property_detail.photos:
                        try:
                            import json
                            if property_detail.photos.startswith('['):
                                db_images = json.loads(property_detail.photos)
                                if db_images and isinstance(db_images, list):
                                    enhanced_images = db_images
                                    enhanced_main_image = db_images[0] if db_images else enhanced_main_image
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                
            except Exception as e:
                print(f"Warning: Could not load enhanced property data for {prop.property_id}: {e}")
            
            # Find complex data for this property
            complex_info = None
            for complex_data in complexes_data:
                if complex_data.get('name') == complex_name or complex_data.get('id') == property_data.get('complex_id'):
                    complex_info = complex_data
                    break
            
            # If no complex found, create basic complex info
            if not complex_info:
                complex_info = {
                    'id': property_data.get('complex_id', 0),
                    'name': complex_name,
                    'developer': enhanced_developer,
                    'address': enhanced_address,
                    'description': f'–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å {complex_name}',
                    'photos': [],
                    'amenities': [],
                    'completion_date': '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
                }
            
            # Enhanced property data with all details from property page
            enriched_property = {
                'id': prop.property_id,
                'name': prop.property_name,
                'complex_name': complex_name,
                'price': prop.property_price,
                'size': prop.property_size,
                'type': prop.property_type,
                'manager_note': prop.manager_note,
                'order_index': prop.order_index,
                'images': enhanced_images,
                'main_image': enhanced_main_image,
                'layout_image': enhanced_layout,
                'address': enhanced_address,
                'latitude': latitude,
                'longitude': longitude,
                'description': enhanced_description,
                'features': enhanced_features,
                'developer': enhanced_developer,
                'district': property_data.get('parsed_district', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'cashback': property_data.get('cashback', 0),
                'cashback_available': property_data.get('cashback_available', True),
                'price_per_sqm': property_data.get('price_per_sqm', 0),
                'status': property_data.get('status', 'available'),
                'title': property_data.get('title', f"{property_data.get('object_rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"),
                'url': property_data.get('url', f"/object/{property_data.get('id')}"),
                # Enhanced with complex data and full property details
                'property_info': property_data,
                'complex_info': complex_info,
                # Additional detailed fields for presentation
                'floor': property_data.get('floor', 0),
                'total_floors': property_data.get('total_floors', 0),
                'apartment_number': property_data.get('apartment_number', ''),
                'balcony': property_data.get('balcony', False),
                'finishing': property_data.get('finishing', '–ù–µ —É–∫–∞–∑–∞–Ω–∞'),
                'completion_date': property_data.get('completion_date', '–ù–µ —É–∫–∞–∑–∞–Ω–∞'),
                'building': property_data.get('building', ''),
                'windows_direction': property_data.get('windows_direction', ''),
                'view': property_data.get('view', ''),
                'ceiling_height': property_data.get('ceiling_height', 0),
                'kitchen_area': property_data.get('kitchen_area', 0),
                'living_area': property_data.get('living_area', 0),
                'rooms': property_data.get('rooms', 0)
            }
            enriched_properties.append(enriched_property)
    
    # Sort by order_index (handle None values)
    enriched_properties.sort(key=lambda x: x['order_index'] if x['order_index'] is not None else 999)
    
    print(f"DEBUG: About to render template with {len(enriched_properties)} enriched properties")
    print(f"DEBUG: Presentation object: {presentation}")
    print(f"DEBUG: First property sample: {enriched_properties[0] if enriched_properties else 'No properties'}")
    
    # Format presentation data for template (same structure as manager version)
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        print(f"üî• RENDERING: presentation_view.html with {len(enriched_properties)} properties")
        print(f"üî• PRESENTATION: {presentation_data['title']}")
        print(f"üî• VIEW COUNT: {presentation_data['view_count']}")
        
        template_result = render_template('presentation_view.html', 
                                        presentation=presentation_data,
                                        properties=enriched_properties,
                                        manager=presentation.created_by)
        print("üî• TEMPLATE RENDERED: presentation_view.html success!")
        return template_result
    except Exception as e:
        print(f"ERROR in view_presentation template rendering: {e}")
        import traceback
        traceback.print_exc()
        return f"Template rendering error: {str(e)}", 500

@app.route('/presentation/modern/<string:unique_id>')
def view_modern_presentation(unique_id):
    """–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    from models import Collection, CollectionProperty, PresentationView, ExcelProperty, ManagerNotification
    
    # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ
    presentation = Collection.query.filter_by(
        unique_url=unique_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return render_template('error.html', 
                             error="–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 
                             message="–í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞ –∏–ª–∏ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞"), 404
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä
    try:
        view = PresentationView(
            collection_id=presentation.id,
            view_ip=request.remote_addr,
            user_agent=request.headers.get('User-Agent'),
            referer=request.headers.get('Referer')
        )
        db.session.add(view)
        presentation.increment_view_count()
        
        # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        manager_id = presentation.created_by_manager_id
        client_name = presentation.client_name or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∏–µ–Ω—Ç'
        presentation_title = presentation.title or '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è'
        view_ip = request.remote_addr or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π IP'
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        notification_title = f"–ü—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏: {presentation_title}"
        notification_message = f"–ö–ª–∏–µ–Ω—Ç {client_name} –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é \"{presentation_title}\". IP –∞–¥—Ä–µ—Å: {view_ip}"
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ JSON
        extra_data = {
            'client_name': client_name,
            'presentation_title': presentation_title,
            'view_ip': view_ip,
            'user_agent': request.headers.get('User-Agent', ''),
            'referer': request.headers.get('Referer', ''),
            'presentation_url': f"/presentation/modern/{presentation.unique_url}",
            'view_count': presentation.view_count + 1  # +1 —Ç–∞–∫ –∫–∞–∫ –µ—â–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏
        }
        
        # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        notification = ManagerNotification(
            manager_id=manager_id,
            title=notification_title,
            message=notification_message,
            notification_type='presentation_view',
            presentation_id=presentation.id
        )
        notification.set_extra_data(extra_data)
        
        db.session.add(notification)
        db.session.commit()
        
        print(f"‚úÖ Created notification for manager {manager_id}: {notification_title}")
        
    except Exception as e:
        db.session.rollback()
        print(f"Error recording presentation view or creating notification: {e}")
        import traceback
        traceback.print_exc()
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    enriched_properties = []
    all_complexes = {}  # –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ñ–ö
    
    for prop in presentation.properties:
        # –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–∞ —Å –∫—ç—à–±–µ–∫–æ–º –æ—Ç –ñ–ö
        from sqlalchemy import text
        property_query = text("""
            SELECT ep.*, COALESCE(rc.cashback_rate, 5.0) as cashback_rate
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON ep.complex_name = rc.name
            WHERE ep.inner_id = :property_id
        """)
        result = db.session.execute(property_query, {'property_id': int(prop.property_id)})
        property_row = result.fetchone()
        
        if property_row:
            property_detail = property_row
            cashback_rate = property_detail.cashback_rate or 5.0
            # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
            photos = []
            if property_detail.photos:
                try:
                    import json
                    if property_detail.photos.startswith('['):
                        photos = json.loads(property_detail.photos)
                    elif property_detail.photos.startswith('http'):
                        # –ï—Å–ª–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∑–∞–ø—è—Ç—ã–º–∏
                        photos = [url.strip() for url in property_detail.photos.split(',') if url.strip()]
                except Exception as e:
                    photos = []
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –æ–±—ä–µ–∫—Ç–∞
            rooms_text = ""
            if property_detail.object_rooms == 0:
                rooms_text = "–°—Ç—É–¥–∏—è"
            elif property_detail.object_rooms:
                rooms_text = f"{property_detail.object_rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
            else:
                rooms_text = "–ö–≤–∞—Ä—Ç–∏—Ä–∞"
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫—ç—à–±–µ–∫
            cashback_amount = int((property_detail.price or 0) * cashback_rate / 100)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –¥–ª—è —à–∞–±–ª–æ–Ω–∞
            property_obj = {
                'property_id': property_detail.inner_id,
                'title': rooms_text,
                'rooms': property_detail.object_rooms or 0,
                'area': property_detail.object_area or 0,
                'price': property_detail.price or 0,
                'floor': property_detail.object_min_floor or 1,
                'total_floors': property_detail.object_max_floor or property_detail.object_min_floor or 1,
                'address': property_detail.address_display_name or '',
                'images': photos,
                'complex_name': property_detail.complex_name or '',
                'developer_name': property_detail.developer_name or '',
                'deadline': '',
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ç–¥–µ–ª–∫–µ, –∫–ª–∞—Å—Å–µ –∂–∏–ª—å—è
                'renovation_type': property_detail.renovation_display_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'housing_class': property_detail.complex_object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –æ—Ç –ñ–ö
                'cashback_percent': cashback_rate,
                'cashback_amount': cashback_amount,
                # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä–∞
                'manager_note': prop.manager_note if hasattr(prop, 'manager_note') else None
            }
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ä–æ–∫ —Å–¥–∞—á–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            if property_detail.complex_end_build_year and property_detail.complex_end_build_quarter:
                quarters = ['I', 'II', 'III', 'IV']
                quarter_text = quarters[property_detail.complex_end_build_quarter - 1] if property_detail.complex_end_build_quarter <= 4 else 'IV'
                property_obj['deadline'] = f"{quarter_text} –∫–≤. {property_detail.complex_end_build_year} –≥."
            
            enriched_properties.append(property_obj)
            
            # –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—Å–µ—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ñ–ö
            if property_detail.complex_name:
                complex_key = property_detail.complex_name
                if complex_key not in all_complexes:
                    all_complexes[complex_key] = {
                        'name': property_detail.complex_name,
                        'developer': property_detail.developer_name,
                        'address': property_detail.address_display_name,
                        'end_year': property_detail.complex_end_build_year,
                        'end_quarter': property_detail.complex_end_build_quarter,
                        'photos': [],  # –ë—É–¥–µ–º —Å–æ–±–∏—Ä–∞—Ç—å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ—Ç–¥–µ–ª—å–Ω–æ
                        'lat': float(property_detail.address_position_lat) if property_detail.address_position_lat else None,
                        'lon': float(property_detail.address_position_lon) if property_detail.address_position_lon else None,
                        'cashback_rate': cashback_rate
                    }
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–ª–µ–∫—Å–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    for complex_name in all_complexes.keys():
        # –ù–∞—Ö–æ–¥–∏–º –æ–±—ä–µ–∫—Ç—ã —ç—Ç–æ–≥–æ –∫–æ–º–ø–ª–µ–∫—Å–∞ —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏
        complex_photos = []
        complex_properties = ExcelProperty.query.filter_by(complex_name=complex_name).limit(10).all()
        
        for prop in complex_properties:
            if prop.photos:
                try:
                    import json
                    prop_photos = []
                    if prop.photos.startswith('['):
                        prop_photos = json.loads(prop.photos)
                    elif prop.photos.startswith('http'):
                        prop_photos = [url.strip() for url in prop.photos.split(',') if url.strip()]
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
                    for photo in prop_photos:
                        if photo not in complex_photos:
                            complex_photos.append(photo)
                            if len(complex_photos) >= 10:  # –ú–∞–∫—Å–∏–º—É–º 10 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å
                                break
                    
                    if len(complex_photos) >= 10:
                        break
                        
                except Exception as e:
                    continue
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∫–æ–º–ø–ª–µ–∫—Å–∞
        all_complexes[complex_name]['photos'] = complex_photos
    
    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–≤–æ–¥–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    total_complexes = len(all_complexes)
    complex_names = list(all_complexes.keys())
    
    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∞–±–ª–æ–Ω–∞
    presentation_data = {
        'title': presentation.title,
        'client_name': presentation.client_name,
        'description': presentation.description,
        'created_at': presentation.created_at,
        'properties': enriched_properties,
        'total_objects': len(enriched_properties),
        'total_complexes': total_complexes,
        'complex_names': complex_names,
        'all_complexes': all_complexes
    }
    
    return render_template('modern_presentation_view.html', presentation=presentation_data)

@app.route('/api/manager/presentation/<int:presentation_id>/share', methods=['POST'])
@manager_required
def share_presentation(presentation_id):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection
    from flask_login import current_user
    import urllib.parse
    
    print(f"DEBUG: share_presentation - presentation_id: {presentation_id}")
    print(f"DEBUG: share_presentation - current_user: {current_user}")
    print(f"DEBUG: share_presentation - session manager_id: {session.get('manager_id')}")
    print(f"DEBUG: share_presentation - request.method: {request.method}")
    print(f"DEBUG: share_presentation - request.content_type: {request.content_type}")
    
    try:
        data = request.get_json() or {}  # –ü—É—Å—Ç–æ–π JSON –≤–∞–ª–∏–¥–µ–Ω
        print(f"DEBUG: share_presentation - request data: {data}")
    except Exception as e:
        print(f"DEBUG: share_presentation - JSON parsing error: {e}")
        return jsonify({'success': False, 'error': f'Invalid JSON: {str(e)}'}), 400
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π —á–µ—Ä–µ–∑ Flask-Login –∏ session
    manager_id = session.get('manager_id')
    if not manager_id:
        print(f"DEBUG: share_presentation - No manager_id in session")
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∫–∞–∫ –º–µ–Ω–µ–¥–∂–µ—Ä'}), 401
    
    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
    print(f"DEBUG: share_presentation - current_user.email: {getattr(current_user, 'email', 'Not authenticated')}")
    
    print(f"DEBUG: share_presentation - Looking for presentation {presentation_id} by manager {manager_id}")
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    print(f"DEBUG: share_presentation - Found presentation: {presentation}")
    
    if not presentation:
        # Try to find presentation regardless of owner for debugging
        any_presentation = Collection.query.filter_by(
            id=presentation_id,
            collection_type='presentation'
        ).first()
        print(f"DEBUG: share_presentation - Any presentation with this ID: {any_presentation}")
        if any_presentation:
            print(f"DEBUG: share_presentation - Presentation exists but belongs to manager {any_presentation.created_by_manager_id}")
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    client_name = data.get('client_name', presentation.client_name)
    print(f"DEBUG: share_presentation - Client name: {client_name}")
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –∫–ª–∏–µ–Ω—Ç–∞ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ
    if client_name and client_name != presentation.client_name:
        print(f"DEBUG: share_presentation - Updating client name from '{presentation.client_name}' to '{client_name}'")
        presentation.client_name = client_name
        db.session.commit()
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É
    base_url = request.url_root.rstrip('/')
    presentation_url = f"{base_url}/presentation/modern/{presentation.unique_url}"
    print(f"DEBUG: share_presentation - Presentation URL: {presentation_url}")
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    properties_count = len(presentation.properties) if presentation.properties else 0
    print(f"DEBUG: share_presentation - Properties count: {properties_count}")
    
    message_text = f"""üè† –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack

üìã {presentation.title}
{f'üë§ –î–ª—è: {client_name}' if client_name else ''}

üî¢ –ü–æ–¥–æ–±—Ä–∞–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {properties_count}
üìÖ –°–æ–∑–¥–∞–Ω–æ: {presentation.created_at.strftime('%d.%m.%Y')}

üëÄ –°–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é:
{presentation_url}

üí¨ –ï—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã? –°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏!
üìû +7 (XXX) XXX-XX-XX"""
    
    response_data = {
        'success': True,
        'share_data': {
            'presentation_url': presentation_url,
            'message_text': message_text,
            'whatsapp_url': f"https://wa.me/?text={urllib.parse.quote(message_text)}",
            'telegram_url': f"https://t.me/share/url?url={presentation_url}&text={urllib.parse.quote(presentation.title)}",
            'client_name': client_name or '–ö–ª–∏–µ–Ω—Ç',
            'properties_count': properties_count
        }
    }
    
    print(f"DEBUG: share_presentation - Returning response: {response_data}")
    return jsonify(response_data)

@app.route('/api/favorites/toggle', methods=['POST'])
@login_required
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def toggle_favorite():
    """Toggle favorite status for property"""
    from models import FavoriteProperty
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    print(f"DEBUG: Favorites toggle called by user {getattr(current_user, 'id', 'not_authenticated')} for property {property_id}")
    print(f"DEBUG: Request data: {data}")
    
    # Check if already in favorites
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False})
        else:
            # Add to favorites
            favorite = FavoriteProperty(
                user_id=current_user.id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0))
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400



@app.route('/api/collections', methods=['POST'])
@login_required
def create_collection():
    """Create new property collection"""
    from models import Collection
    data = request.get_json()
    
    try:
        collection = Collection(
            user_id=current_user.id,
            title=data['name'],
            description=data.get('description'),
            image_url=data.get('image_url'),
            category=data.get('category')
        )
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/collections/<int:collection_id>', methods=['DELETE'])
@login_required
def delete_collection(collection_id):
    """Delete a collection"""
    from models import Collection
    collection = Collection.query.filter_by(
        id=collection_id,
        user_id=current_user.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/upload', methods=['POST'])
@login_required
def upload_documents():
    """Upload documents"""
    from models import Document
    import os
    from werkzeug.utils import secure_filename
    from datetime import datetime
    
    if 'files' not in request.files:
        return jsonify({'success': False, 'error': '–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏'}), 400
    
    files = request.files.getlist('files')
    uploaded_files = []
    
    # Create uploads directory if it doesn't exist
    upload_dir = 'instance/uploads'
    os.makedirs(upload_dir, exist_ok=True)
    
    for file in files:
        if file.filename == '':
            continue
        
        if file and file.filename and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # Add timestamp to avoid conflicts
            timestamp = str(int(datetime.utcnow().timestamp()))
            filename = f"{timestamp}_{filename}"
            file_path = os.path.join(upload_dir, filename)
            
            try:
                file.save(file_path)
                file_size = os.path.getsize(file_path)
                file_ext = filename.rsplit('.', 1)[1].lower()
                
                # Create document record
                document = Document(
                    user_id=current_user.id,
                    original_filename=secure_filename(file.filename) if file.filename else 'unknown',
                    stored_filename=filename,
                    file_path=file_path,
                    file_size=file_size,
                    file_type=file_ext,
                    document_type=determine_document_type(file.filename),
                    status='–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
                )
                db.session.add(document)
                uploaded_files.append({
                    'filename': file.filename,
                    'size': file_size
                })
            except Exception as e:
                return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ {file.filename}: {str(e)}'}), 400
    
    try:
        db.session.commit()
        return jsonify({'success': True, 'uploaded_files': uploaded_files})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/<int:document_id>', methods=['DELETE'])
@login_required
def delete_document(document_id):
    """Delete a document"""
    from models import Document
    import os
    
    document = Document.query.filter_by(
        id=document_id,
        user_id=current_user.id
    ).first()
    
    if not document:
        return jsonify({'success': False, 'error': '–î–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        # Delete physical file
        if os.path.exists(document.file_path):
            os.remove(document.file_path)
        
        # Delete database record
        db.session.delete(document)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def allowed_file(filename):
    ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'jpg', 'jpeg', 'png'}
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def determine_document_type(filename):
    """Determine document type from filename"""
    filename_lower = filename.lower()
    if any(word in filename_lower for word in ['–ø–∞—Å–ø–æ—Ä—Ç', 'passport']):
        return '–ü–∞—Å–ø–æ—Ä—Ç'
    elif any(word in filename_lower for word in ['—Å–ø—Ä–∞–≤–∫–∞', '–¥–æ—Ö–æ–¥—ã', 'income']):
        return '–°–ø—Ä–∞–≤–∫–∞ –æ –¥–æ—Ö–æ–¥–∞—Ö'
    elif any(word in filename_lower for word in ['–¥–æ–≥–æ–≤–æ—Ä', 'contract']):
        return '–î–æ–≥–æ–≤–æ—Ä'
    elif any(word in filename_lower for word in ['—Å–Ω–∏–ª—Å', '—Å–Ω–∏–ª—Å']):
        return '–°–ù–ò–õ–°'
    elif any(word in filename_lower for word in ['–∏–Ω–Ω', 'inn']):
        return '–ò–ù–ù'
    else:
        return '–î—Ä—É–≥–æ–µ'

# Manager authentication and dashboard routes
@app.route('/manager/logout')
def manager_logout():
    """Manager logout"""
    session.pop('manager_id', None)
    session.pop('is_manager', None)
    flash('–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã', 'success')
    return redirect(url_for('manager_login'))

@app.route('/switch-to-client')
def switch_to_client():
    """Switch from manager to client mode"""
    session.pop('manager_id', None)
    session.pop('is_manager', None)
    flash('–ü–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –≤ —Ä–µ–∂–∏–º –∫–ª–∏–µ–Ω—Ç–∞', 'info')
    return redirect(url_for('index'))

@app.route('/manager/login', methods=['GET', 'POST'])
@csrf.exempt  # CSRF disabled  # Temporarily disable CSRF for login
def manager_login():
    """Simplified manager login with step-by-step error isolation"""
    if request.method == 'POST':
        # Step 1: Import and basic validation
        try:
            print("STEP 1: Starting manager login process")
            email = request.form.get('email')
            password = request.form.get('password')
            print(f"STEP 1: Got email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                print("STEP 1: Missing credentials")
                flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
                return render_template('auth/manager_login.html')
            print("STEP 1: Basic validation passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 1: {e}")
            flash('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 2: Database query
        try:
            print("STEP 2: Importing Manager model")
            from models import Manager
            print("STEP 2: Manager model imported successfully")
            
            print("STEP 2: Querying database for manager")
            manager = Manager.query.filter_by(email=email, is_active=True).first()
            print(f"STEP 2: Database query result: {manager is not None}")
            
            if not manager:
                print("STEP 2: Manager not found")
                flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
                return render_template('auth/manager_login.html')
            
            print(f"STEP 2: Manager found - ID: {manager.id}, Email: {manager.email}")
            
        except Exception as e:
            print(f"ERROR IN STEP 2: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 3: Password verification
        try:
            print("STEP 3: Checking password")
            password_valid = manager.check_password(password)
            print(f"STEP 3: Password check result: {password_valid}")
            
            if not password_valid:
                print("STEP 3: Password invalid")
                flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
                return render_template('auth/manager_login.html')
            
            print("STEP 3: Password verification passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 3: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä–æ–ª—è', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 4: Session setup
        try:
            print("STEP 4: Setting up session")
            session.permanent = True
            session['manager_id'] = manager.id
            session['is_manager'] = True
            print(f"STEP 4: Session configured: manager_id={session.get('manager_id')}, is_manager={session.get('is_manager')}")
            
        except Exception as e:
            print(f"ERROR IN STEP 4: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Å—Å–∏–∏', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 5: Database update
        try:
            print("STEP 5: Updating last login time")
            from datetime import datetime
            manager.last_login = datetime.utcnow()
            db.session.commit()
            print("STEP 5: Database commit successful")
            
        except Exception as e:
            print(f"ERROR IN STEP 5: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 6: Success redirect
        try:
            print("STEP 6: Preparing success response")
            flash('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º—É!', 'success')
            print(f"STEP 6: Login successful for manager {manager.email}")
            return redirect(url_for('manager_dashboard'))
            
        except Exception as e:
            print(f"ERROR IN STEP 6: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è', 'error')
            return render_template('auth/manager_login.html')
    
    # GET request - show login form
    return render_template('auth/manager_login.html')



# Manager Comparison Routes
@app.route('/manager/property-comparison')
@manager_required
def manager_property_comparison():
    """Manager property comparison page"""
    from models import Manager
    
    # Get current manager from session
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    return render_template('auth/manager_property_comparison.html', current_manager=manager)

@app.route('/manager/complex-comparison')
@manager_required
def manager_complex_comparison():
    """Manager complex comparison page"""
    from models import Manager
    
    # Get current manager from session
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    return render_template('auth/manager_complex_comparison.html', current_manager=manager)

@app.route('/api/manager/favorites-properties')
@manager_required
def get_manager_favorite_properties():
    """Get properties with full characteristics for comparison"""
    try:
        # Check if specific IDs are requested for server-side filtering
        from flask import request
        requested_ids = request.args.get('ids', '')
        filter_ids_str = [id.strip() for id in requested_ids.split(',') if id.strip()] if requested_ids else []
        
        # Convert string IDs to integers for PostgreSQL filtering
        filter_ids = []
        for id_str in filter_ids_str:
            try:
                filter_ids.append(int(id_str))
            except (ValueError, TypeError):
                continue  # Skip invalid IDs
        
        # Load properties from PostgreSQL using direct SQL to avoid ORM issues
        import psycopg2
        import os
        import json
        
        # Connect to database directly
        try:
            conn = psycopg2.connect(os.environ.get("DATABASE_URL"))
            cur = conn.cursor()
            
            # Build SQL query based on filter_ids
            if filter_ids:
                placeholders = ','.join(['%s'] * len(filter_ids))
                sql_query = f"""
                SELECT inner_id, complex_name, developer_name, object_rooms, object_area, 
                       price, address_display_name, photos, complex_object_class_display_name,
                       address_locality_display_name, object_min_floor, object_max_floor,
                       square_price, renovation_display_name,
                       complex_building_end_build_year, complex_building_name,
                       renovation_type, deal_type, complex_has_green_mortgage
                FROM excel_properties 
                WHERE inner_id IN ({placeholders})
                LIMIT 10
                """
                cur.execute(sql_query, filter_ids)
            else:
                sql_query = """
                SELECT inner_id, complex_name, developer_name, object_rooms, object_area, 
                       price, address_display_name, photos, complex_object_class_display_name,
                       address_locality_display_name, object_min_floor, object_max_floor,
                       square_price, renovation_display_name,
                       complex_building_end_build_year, complex_building_name,
                       renovation_type, deal_type, complex_has_green_mortgage
                FROM excel_properties 
                LIMIT 100
                """
                cur.execute(sql_query)
            
            rows = cur.fetchall()
            properties_data = []
            
            for row in rows:
                # Unpack row data (19 values to match SELECT order)  
                (inner_id, complex_name, developer_name, object_rooms, object_area, 
                 price, address_display_name, photos, complex_object_class_display_name,
                 address_locality_display_name, object_min_floor, object_max_floor,
                 square_price, renovation_display_name,
                 complex_building_end_build_year, complex_building_name,
                 renovation_type, deal_type, complex_has_green_mortgage) = row
                
                # Handle photos from JSON string to first image
                photos_data = []
                if photos:
                    try:
                        photos_data = json.loads(photos) if isinstance(photos, str) else photos
                    except:
                        photos_data = []
                
                first_image = photos_data[0] if photos_data else '/static/images/no-photo.jpg'
                
                # Format room text for display
                rooms_count = object_rooms or 0
                area_value = object_area or 0
                rooms_text = "–°—Ç—É–¥–∏—è" if rooms_count == 0 else f"{rooms_count}"
                
                # Format property name correctly
                if rooms_count == 0:
                    property_name = f"–°—Ç—É–¥–∏—è, {area_value} –º¬≤"
                else:
                    property_name = f"{rooms_count} –∫–æ–º–Ω, {area_value} –º¬≤"
                
                # Calculate cashback using the complex name
                cashback_value = calculate_cashback(price or 0, complex_name=complex_name)
                
                property_data = {
                    'property_id': str(inner_id or ''),
                    'property_name': property_name,
                    'property_type': complex_object_class_display_name or '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                    'property_size': float(object_area or 0),
                    'property_price': int(price or 0),
                    'complex_name': complex_name or '',
                    'developer_name': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'property_image': first_image,
                    'property_url': f'/object/{inner_id}' if inner_id else None,
                    'district': address_locality_display_name or '',
                    'address': address_display_name or '',
                    'floor': str(object_min_floor or ''),
                    'total_floors': str(object_max_floor or ''),
                    'floors_total': str(object_max_floor or ''),
                    'rooms': str(rooms_count),
                    'living_area': '',  # Not available in database
                    'kitchen_area': '',  # Not available in database
                    'price_per_sqm': int(square_price or 0),
                    'condition': renovation_display_name or '',
                    'ceiling_height': '',  # Not available in current schema
                    'furniture': '',  # Not available in current schema
                    'balcony': '',  # Not available in current schema
                    'view_from_windows': '',  # Not available in current schema
                    'parking': '',  # Not available in current schema
                    'metro_distance': '',  # Not available in current schema
                    'year_built': str(complex_building_end_build_year or ''),
                    'building_type': complex_building_name or '',
                    'decoration': renovation_type or 'no_renovation',
                    'deal_type': deal_type or 'sale',
                    'mortgage_available': '–î–∞' if complex_has_green_mortgage else '–ù–µ—Ç',
                    'added_at': '–ó–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ PostgreSQL',
                    'cashback_amount': cashback_value,
                    'cashback': cashback_value
                }
                properties_data.append(property_data)
            
            return jsonify({
                'success': True,
                'properties': properties_data,
                'count': len(properties_data)
            })
            
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 500
        finally:
            if 'cur' in locals():
                cur.close()
            if 'conn' in locals():
                conn.close()
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/favorites-complexes')
@manager_required
def get_manager_favorite_complexes():
    """Get manager's favorite complexes for comparison"""
    from models import ManagerFavoriteComplex
    
    try:
        manager_id = session.get('manager_id')
        
        # Get all favorite complexes for this manager
        favorites = ManagerFavoriteComplex.query.filter_by(
            manager_id=manager_id
        ).order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        complexes_data = []
        for fav in favorites:
            complexes_data.append({
                'id': fav.id,
                'complex_id': fav.complex_id,
                'complex_name': fav.complex_name,
                'developer_name': fav.developer_name,
                'complex_address': fav.complex_address,
                'district': fav.district,
                'min_price': fav.min_price,
                'max_price': fav.max_price,
                'complex_image': fav.complex_image,
                'complex_url': fav.complex_url,
                'added_at': fav.created_at.strftime('%d.%m.%Y %H:%M')
            })
        
        return jsonify({
            'success': True,
            'complexes': complexes_data,
            'count': len(complexes_data)
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/manager/dashboard')
@manager_required
def manager_dashboard():
    from models import Manager, User, CashbackApplication, Document
    
    manager_id = session.get('manager_id')
    print(f"DEBUG: Manager dashboard - manager_id: {manager_id}")
    current_manager = Manager.query.get(manager_id)
    print(f"DEBUG: Manager dashboard - current_manager: {current_manager}")
    
    if not current_manager:
        print("DEBUG: Manager not found, redirecting to login")
        return redirect(url_for('manager_login'))
    
    # Get statistics
    total_clients = User.query.filter_by(assigned_manager_id=manager_id).count()
    new_clients_count = User.query.filter_by(
        assigned_manager_id=manager_id, 
        client_status='–ù–æ–≤—ã–π'
    ).count()
    
    pending_applications_count = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == manager_id,
        CashbackApplication.status == '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏'
    ).count()
    
    pending_documents_count = Document.query.join(User).filter(
        User.assigned_manager_id == manager_id,
        Document.status == '–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
    ).count()
    
    # Calculate total approved cashback
    total_approved_cashback = 0
    try:
        from models import CashbackApplication, User
        approved_apps = CashbackApplication.query.join(User).filter(
            User.assigned_manager_id == manager_id,
            CashbackApplication.status == '–û–¥–æ–±—Ä–µ–Ω–∞'
        ).all()
        total_approved_cashback = sum(app.cashback_amount for app in approved_apps)
    except Exception as e:
        print(f"Error calculating cashback: {e}")
        total_approved_cashback = 0
    
    # Recent activities (mock data for now)
    recent_activities = [
        {
            'message': '–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è',
            'time_ago': '5 –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥',
            'color': 'blue',
            'icon': 'user-plus'
        },
        {
            'message': '–ó–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ –æ—Ç –ê–Ω–Ω—ã –°–∏–¥–æ—Ä–æ–≤–æ–π —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏',
            'time_ago': '1 —á–∞—Å –Ω–∞–∑–∞–¥',
            'color': 'yellow',
            'icon': 'file-alt'
        }
    ]
    
    # Get collections statistics  
    from models import Collection
    collections_count = Collection.query.filter_by(created_by_manager_id=manager_id).count()
    recent_collections = Collection.query.filter_by(created_by_manager_id=manager_id).order_by(Collection.created_at.desc()).limit(5).all()
    
    # Get presentations statistics
    presentations_count = Collection.query.filter_by(
        created_by_manager_id=manager_id, 
        collection_type='presentation'
    ).count()
    
    # Get deals statistics
    from models import Deal
    deals_count = Deal.query.filter_by(manager_id=manager_id).count()
    
    # Load data for manager filters
    districts = get_districts_list()
    developers = get_developers_list()
    
    print(f"DEBUG: Rendering dashboard with manager: {current_manager.full_name}")
    try:
        response = make_response(render_template('auth/manager_dashboard.html',
                             current_manager=current_manager,
                             total_clients=total_clients,
                             new_clients_count=new_clients_count,
                             pending_applications_count=pending_applications_count,
                             pending_documents_count=pending_documents_count,
                             total_approved_cashback=total_approved_cashback,
                             recent_activities=recent_activities,
                             pending_notifications=pending_applications_count + pending_documents_count,
                             collections_count=collections_count,
                             presentations_count=presentations_count,
                             deals_count=deals_count,
                             recent_collections=recent_collections,
                             districts=districts,
                             developers=developers))
        # Add anti-cache headers
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        print(f"DEBUG: Error rendering dashboard: {e}")
        import traceback
        traceback.print_exc()
        return f"Error rendering dashboard: {e}", 500


@app.route('/manager/favorites')
@manager_required
def manager_favorites():
    """Manager favorites page - separate page like user favorites"""
    from models import Manager
    
    manager_id = session.get('manager_id')
    current_manager = Manager.query.get(manager_id)
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    return render_template('manager/favorites.html', current_manager=current_manager)


@app.route('/manager/presentation/<int:presentation_id>')
@manager_required
def manager_presentation_view(presentation_id):
    """View presentation page inside manager dashboard"""
    from models import Collection, CollectionProperty, Manager
    
    manager_id = session.get('manager_id')
    print(f"DEBUG: Presentation view - manager_id: {manager_id}, presentation_id: {presentation_id}")
    
    current_manager = Manager.query.get(manager_id)
    if not current_manager:
        print("DEBUG: Manager not found, redirecting to login")
        return redirect(url_for('manager_login'))
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        print(f"DEBUG: Presentation {presentation_id} not found or access denied")
        flash('–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –Ω–µ–π', 'error')
        return redirect(url_for('manager_dashboard'))
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # Load properties data to enrich the collection properties
    properties_data = load_properties()  # This function already exists in the app
    complexes_data = load_residential_complexes()  # This function already exists in the app
    
    # Enrich collection properties with full property data
    enriched_properties = []
    for cp in collection_properties:
        # Find the property in the main properties data
        property_data = None
        for prop in properties_data:
            if str(prop.get('id')) == str(cp.property_id):
                property_data = prop
                break
        
        if property_data:
            # Get complex name directly from property_data (load_properties already includes it)
            complex_name = property_data.get('residential_complex', property_data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω'))
            
            # Get coordinates from the coordinates object
            coordinates = property_data.get('coordinates', {})
            latitude = coordinates.get('lat') if coordinates else None
            longitude = coordinates.get('lng') if coordinates else None
            
            # Prepare main image - load_properties returns 'main_image', not 'images'
            main_image = property_data.get('main_image', '/static/images/no-photo.jpg')
            images = [main_image] if main_image and main_image != '/static/images/no-photo.jpg' else []
            
            enriched_property = {
                'id': property_data.get('id'),
                'property_id': cp.property_id,
                'manager_note': cp.manager_note,
                'order_index': cp.order_index,
                'rooms': property_data.get('rooms', 0),
                'price': property_data.get('price', 0),
                'area': property_data.get('area', 0),
                'floor': property_data.get('floor', 0),
                'total_floors': property_data.get('total_floors', 0),
                'complex_name': complex_name,
                'property_type': property_data.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
                'images': images,
                'main_image': main_image,
                'layout_image': property_data.get('layout_image'),  # May not exist in load_properties
                'address': property_data.get('address', ''),
                'latitude': latitude,
                'longitude': longitude,
                'description': property_data.get('description', ''),
                'features': property_data.get('features', []),
                # Add additional fields from load_properties for full compatibility
                'developer': property_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'district': property_data.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'cashback': property_data.get('cashback', 0),
                'cashback_available': property_data.get('cashback_available', True),
                'price_per_sqm': property_data.get('price_per_sqm', 0),
                'status': property_data.get('status', 'available'),
                'title': property_data.get('title', f"{property_data.get('rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"),
                'url': property_data.get('url', f"/object/{property_data.get('id')}")
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in main data")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties")
    
    # Format presentation data for template
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        return render_template('manager/presentation_view.html',
                             manager=current_manager,
                             presentation=presentation_data)
    except Exception as e:
        print(f"DEBUG: Error rendering presentation view: {e}")
        import traceback
        traceback.print_exc()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏', 'error')
        return redirect(url_for('manager_dashboard'))


# API routes for manager actions
@app.route('/api/manager/clients')
@manager_required
def get_manager_clients_unified():
    """Get ONLY assigned clients for this manager"""
    # Get manager ID from session (already verified by manager_required decorator)
    manager_id = session.get('manager_id')
    
    try:
        print(f"DEBUG: Getting clients for manager {manager_id}")
        # Get ALL users assigned to this manager (regardless of role)
        clients = User.query.filter_by(assigned_manager_id=manager_id).all()
        print(f"DEBUG: Found {len(clients)} assigned clients for manager {manager_id}")
        clients_data = []
        
        for client in clients:
            # Get latest search as preference indicator
            latest_search = SavedSearch.query.filter_by(user_id=client.id).order_by(SavedSearch.last_used.desc()).first()
            
            client_data = {
                'id': client.id,
                'full_name': client.full_name,
                'email': client.email,
                'phone': client.phone or '',
                'created_at': client.created_at.isoformat() if client.created_at else None,
                'search_preferences': None,
                'status': 'active'  # Default status
            }
            
            if latest_search:
                # Create readable search description
                prefs = []
                if latest_search.property_type:
                    prefs.append(latest_search.property_type)
                if latest_search.location:
                    prefs.append(f"—Ä–∞–π–æ–Ω {latest_search.location}")
                if latest_search.price_min or latest_search.price_max:
                    price_range = []
                    if latest_search.price_min:
                        price_range.append(f"–æ—Ç {latest_search.price_min:,} ‚ÇΩ")
                    if latest_search.price_max:
                        price_range.append(f"–¥–æ {latest_search.price_max:,} ‚ÇΩ")
                    prefs.append(" ".join(price_range))
                
                client_data['search_preferences'] = ", ".join(prefs) if prefs else "–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω"
            
            clients_data.append(client_data)
        
        print(f"DEBUG: Returning {len(clients_data)} clients data")
        return jsonify({
            'success': True,
            'clients': clients_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/update_client_status', methods=['POST'])
@manager_required
def update_client_status():
    from models import User
    
    data = request.get_json()
    client_id = data.get('client_id')
    new_status = data.get('status')
    notes = data.get('notes', '')
    
    client = User.query.get(client_id)
    if not client or client.assigned_manager_id != session.get('manager_id'):
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        client.client_status = new_status
        if notes:
            client.client_notes = notes
        client.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/approve_cashback', methods=['POST'])
@manager_required
def approve_cashback():
    from models import CashbackApplication, Manager
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    manager_notes = data.get('manager_notes', '')
    
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    application = CashbackApplication.query.get(application_id)
    if not application:
        return jsonify({'success': False, 'error': '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != manager_id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞—è–≤–∫–µ'}), 403
    
    try:
        if action == 'approve':
            # Check approval limits
            if manager and manager.max_cashback_approval and application.cashback_amount > manager.max_cashback_approval:
                return jsonify({
                    'success': False, 
                    'error': f'–°—É–º–º–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –≤–∞—à –ª–∏–º–∏—Ç –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ ({manager.max_cashback_approval:,} ‚ÇΩ)'
                }), 400
            
            application.status = '–û–¥–æ–±—Ä–µ–Ω–∞'
            application.approved_date = datetime.utcnow()
            application.approved_by_manager_id = manager_id
            
        elif action == 'reject':
            application.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
        
        if manager_notes:
            application.manager_notes = manager_notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/contact-requests')
@manager_required  
def get_manager_contact_requests():
    """Get contact manager applications for current manager"""
    try:
        from models import Application
        
        # Get all manager contact applications
        applications = Application.query.filter_by(
            application_type='manager_contact'
        ).order_by(Application.created_at.desc()).all()
        
        result = []
        for app in applications:
            result.append({
                'id': app.id,
                'contact_name': app.contact_name,
                'contact_email': app.contact_email,
                'contact_phone': app.contact_phone,
                'message': app.message,
                'preferred_contact_time': app.preferred_contact_time,
                'status': app.status,
                'created_at': app.created_at.isoformat() if app.created_at else None,
                'updated_at': app.updated_at.isoformat() if app.updated_at else None,
                # Property context if available
                'property_id': app.property_id,
                'property_type': app.property_type,
                'budget_min': app.budget_min,
                'budget_max': app.budget_max
            })
        
        return jsonify({
            'success': True,
            'applications': result,
            'total': len(result)
        })
        
    except Exception as e:
        print(f"Error getting manager contact requests: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/applications')
@manager_required
def get_manager_applications():
    from models import CashbackApplication, User
    manager_id = session.get('manager_id')
    
    applications = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == manager_id,
        CashbackApplication.status == '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏'
    ).all()
    
    applications_data = []
    for app in applications:
        applications_data.append({
            'id': app.id,
            'client_name': app.user.full_name,
            'client_email': app.user.email,
            'property_name': app.property_name,
            'complex_name': app.complex_name,
            'cashback_amount': app.cashback_amount,
            'cashback_percent': app.cashback_percent,
            'application_date': app.application_date.strftime('%d.%m.%Y'),
            'status': app.status
        })
    
    return jsonify({'applications': applications_data})

@app.route('/api/manager/documents')
@manager_required
def get_manager_documents():
    from models import Document, User
    manager_id = session.get('manager_id')
    
    documents = Document.query.join(User).filter(
        User.assigned_manager_id == manager_id,
        Document.status == '–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
    ).all()
    
    documents_data = []
    for doc in documents:
        documents_data.append({
            'id': doc.id,
            'client_name': doc.user.full_name,
            'client_email': doc.user.email,
            'document_type': doc.document_type or '–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω',
            'original_filename': doc.original_filename,
            'file_size': doc.file_size,
            'created_at': doc.created_at.strftime('%d.%m.%Y %H:%M'),
            'status': doc.status
        })
    
    return jsonify({'documents': documents_data})

@app.route('/api/manager/document_action', methods=['POST'])
@manager_required
def manager_document_action():
    from models import Document, Manager
    
    data = request.get_json()
    document_id = data.get('document_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    manager_id = session.get('manager_id')
    document = Document.query.get(document_id)
    
    if not document:
        return jsonify({'success': False, 'error': '–î–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    # Check if client is assigned to this manager
    if document.user.assigned_manager_id != manager_id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –¥–æ–∫—É–º–µ–Ω—Ç—É'}), 403
    
    try:
        if action == 'approve':
            document.status = '–ü—Ä–æ–≤–µ—Ä–µ–Ω'
        elif action == 'reject':
            document.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω'
        
        document.reviewed_by_manager_id = manager_id
        document.reviewed_at = datetime.utcnow()
        if notes:
            document.reviewer_notes = notes
        
        document.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/application_action', methods=['POST'])
@manager_required
def manager_application_action():
    from models import CashbackApplication, Manager, User
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    manager_id = session.get('manager_id')
    application = CashbackApplication.query.get(application_id)
    
    if not application:
        return jsonify({'success': False, 'error': '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != manager_id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞—è–≤–∫–µ'}), 403
    
    try:
        if action == 'approve':
            application.status = '–û–¥–æ–±—Ä–µ–Ω–∞'
            # Add cashback to user's balance
            user = application.user
            user.total_cashback = (user.total_cashback or 0) + application.cashback_amount
        elif action == 'reject':
            application.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
        
        application.reviewed_by_manager_id = manager_id
        application.reviewed_at = datetime.utcnow()
        if notes:
            application.manager_notes = notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections')
@manager_required
def get_manager_collections():
    from models import Collection, User
    manager_id = session.get('manager_id')
    
    collections = Collection.query.filter_by(created_by_manager_id=manager_id).all()
    
    collections_data = []
    for collection in collections:
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'assigned_to_name': collection.assigned_to.full_name if collection.assigned_to else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–æ',
            'assigned_to_id': collection.assigned_to_user_id,
            'properties_count': len(collection.properties),
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/manager/collection/create', methods=['POST'])
@manager_required
def api_create_collection():
    from models import Collection, User
    
    data = request.get_json()
    title = data.get('title')
    description = data.get('description', '')
    assigned_to_user_id = data.get('assigned_to_user_id')
    tags = data.get('tags', '')
    
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    manager_id = session.get('manager_id')
    
    try:
        collection = Collection()
        collection.title = title
        collection.description = description
        collection.created_by_manager_id = manager_id
        collection.assigned_to_user_id = assigned_to_user_id if assigned_to_user_id else None
        collection.tags = tags
        collection.status = '–ß–µ—Ä–Ω–æ–≤–∏–∫'
        
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/properties')
@manager_required
def get_collection_properties(collection_id):
    from models import Collection, CollectionProperty
    manager_id = session.get('manager_id')
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=manager_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    properties_data = []
    for prop in collection.properties:
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'order_index': prop.order_index
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: x['order_index'])
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status
        },
        'properties': properties_data
    })



@app.route('/api/searches/save', methods=['POST'])
@login_required
def api_save_search():
    """Save a search with filters"""
    from models import SavedSearch
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    
    if not name:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        search = SavedSearch()
        search.name = name
        search.filters = json.dumps(filters)
        search.user_id = current_user.id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        return jsonify({'success': True, 'search_id': search.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/searches', methods=['POST'])
@manager_required
def api_manager_save_search():
    """Save a search for a manager"""
    from models import ManagerSavedSearch, Manager, SentSearch
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    client_email = data.get('client_email', '')
    
    if not name:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        # Create saved search
        search = ManagerSavedSearch()
        search.name = name
        search.filters = json.dumps(filters)
        search.manager_id = manager_id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        # If client email provided, also create sent search record and send notification
        if client_email:
            sent_search = SentSearch()
            sent_search.saved_search_id = search.id
            sent_search.recipient_email = client_email
            sent_search.sent_at = datetime.utcnow()
            sent_search.manager_id = manager_id
            
            db.session.add(sent_search)
            db.session.commit()
            
            # Send notification to client
            manager = Manager.query.get(manager_id)
            manager_name = manager.name if manager else "–ú–µ–Ω–µ–¥–∂–µ—Ä"
            
            try:
                send_notification(
                    recipient_email=client_email,
                    subject=f"–ù–æ–≤—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç {manager_name}",
                    message=f"–ú–µ–Ω–µ–¥–∂–µ—Ä {manager_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ '{name}'. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞ —Å–∞–π—Ç–µ InBack.ru",
                    notification_type='saved_search',
                    user_id=None,
                    manager_id=manager_id
                )
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': True})
            except Exception as email_error:
                print(f"Failed to send email notification: {email_error}")
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
        return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send_recommendation', methods=['POST'])
def api_manager_send_recommendation():
    """Send a recommendation (property or complex) to a client"""
    from models import Recommendation, Manager, User, RecommendationCategory
    from datetime import datetime
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    data = request.get_json()
    title = data.get('title', '').strip()
    client_id = data.get('client_id')  # Now using client_id instead of email
    client_email = data.get('client_email', '').strip()
    recommendation_type = data.get('recommendation_type')  # 'property' or 'complex'
    item_id = data.get('item_id')
    item_name = data.get('item_name', '').strip()
    description = data.get('description', '').strip()
    manager_notes = data.get('manager_notes', '').strip()
    highlighted_features = data.get('highlighted_features', [])
    priority_level = data.get('priority_level', 'normal')
    category_id = data.get('category_id')  # New field for category
    category_name = data.get('category_name', '').strip()  # For creating new category
    
    # Debug logging (removing verbose logs for production)
    print(f"DEBUG: Recommendation sent - type={recommendation_type}, item_id={item_id}, client_id={client_id}")
    
    # Validation
    missing_fields = []
    if not title:
        missing_fields.append('–∑–∞–≥–æ–ª–æ–≤–æ–∫')
    if not client_id:
        missing_fields.append('–∫–ª–∏–µ–Ω—Ç')
    if not recommendation_type:
        missing_fields.append('—Ç–∏–ø —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏')
    if not item_id:
        missing_fields.append('ID –æ–±—ä–µ–∫—Ç–∞')
    if not item_name:
        missing_fields.append('–Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞')
    
    if missing_fields:
        return jsonify({'success': False, 'error': f'–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: {", ".join(missing_fields)}'}), 400
    
    if recommendation_type not in ['property', 'complex']:
        return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏'}), 400
    
    try:
        # Find client by ID
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 400
        
        # Handle category
        category = None
        if category_id == 'new' and category_name:
            # Create new category
            category = RecommendationCategory(
                name=category_name,
                manager_id=manager_id,
                client_id=client_id
            )
            db.session.add(category)
            db.session.flush()  # To get the ID
        elif category_id and category_id != 'new':
            # Use existing category
            category = RecommendationCategory.query.filter_by(
                id=category_id,
                manager_id=manager_id,
                client_id=client_id,
                is_active=True
            ).first()
        
        # Create recommendation
        recommendation = Recommendation()
        recommendation.manager_id = manager_id
        recommendation.client_id = client.id
        recommendation.title = title
        recommendation.description = description
        recommendation.recommendation_type = recommendation_type
        recommendation.item_id = item_id
        recommendation.item_name = item_name
        recommendation.manager_notes = manager_notes
        recommendation.highlighted_features = json.dumps(highlighted_features) if highlighted_features else None
        recommendation.priority_level = priority_level
        recommendation.item_data = json.dumps(data.get('item_data', {}))  # Store full item details
        recommendation.category_id = category.id if category else None
        
        db.session.add(recommendation)
        
        # Update category statistics
        if category:
            category.recommendations_count += 1
            category.last_used = datetime.utcnow()
        
        db.session.commit()
        
        # Send notification to client
        manager = Manager.query.get(manager_id)
        manager_name = manager.name if manager else "–ú–µ–Ω–µ–¥–∂–µ—Ä"
        
        try:
            # Get priority text for notifications
            priority_texts = {
                'urgent': '–°—Ä–æ—á–Ω–æ',
                'high': '–í—ã—Å–æ–∫–∏–π', 
                'normal': '–û–±—ã—á–Ω—ã–π'
            }
            priority_text = priority_texts.get(priority_level, '–û–±—ã—á–Ω—ã–π')
            
            send_notification(
                recipient_email=client_email,
                subject=f"–ù–æ–≤–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –æ—Ç {manager_name}",
                message=f"–ú–µ–Ω–µ–¥–∂–µ—Ä {manager_name} —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –≤–∞–º: {title}",
                notification_type='recommendation',
                user_id=client.id,
                manager_id=manager_id,
                title=title,
                item_id=item_id,
                item_name=item_name,
                description=description,
                manager_name=manager_name,
                priority_text=priority_text,
                recommendation_type=recommendation_type
            )
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': True})
        except Exception as email_error:
            print(f"Failed to send email notification: {email_error}")
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
    except Exception as e:
        db.session.rollback()
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error creating recommendation: {str(e)}")
        print(f"Full traceback: {error_trace}")
        return jsonify({'success': False, 'error': str(e), 'traceback': error_trace}), 400

@app.route('/api/manager/recommendations', methods=['GET'])
def api_manager_get_recommendations():
    """Get manager's sent recommendations with filters"""
    from models import Recommendation
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        # Start with base query
        query = Recommendation.query.filter_by(manager_id=manager_id)
        
        # Apply filters from request params
        client_id = request.args.get('client_id')
        status = request.args.get('status')
        rec_type = request.args.get('type')
        priority = request.args.get('priority')
        
        if client_id:
            query = query.filter(Recommendation.client_id == client_id)
        if status:
            query = query.filter(Recommendation.status == status)
        if rec_type:
            query = query.filter(Recommendation.item_type == rec_type)
        if priority:
            query = query.filter(Recommendation.priority == priority)
        
        recommendations = query.order_by(Recommendation.sent_at.desc()).all()
        
        recommendations_data = []
        stats = {'sent': 0, 'viewed': 0, 'interested': 0, 'scheduled': 0}
        
        for rec in recommendations:
            rec_dict = rec.to_dict()
            rec_dict['client_email'] = rec.client.email
            rec_dict['client_name'] = rec.client.full_name
            recommendations_data.append(rec_dict)
            
            # Update stats
            stats['sent'] += 1
            if rec.status == 'viewed':
                stats['viewed'] += 1
            elif rec.status == 'interested':
                stats['interested'] += 1
            elif rec.status == 'scheduled_viewing':
                stats['scheduled'] += 1
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data,
            'stats': stats
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendations/<int:recommendation_id>', methods=['DELETE'])
@manager_required  
def api_manager_delete_recommendation(recommendation_id):
    """Delete a recommendation"""
    from models import Recommendation
    
    manager_id = session.get('manager_id')
    
    try:
        # Find recommendation that belongs to this manager
        recommendation = Recommendation.query.filter_by(
            id=recommendation_id, 
            manager_id=manager_id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        db.session.delete(recommendation)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/clients-list', methods=['GET'])
@manager_required
def api_manager_get_clients_list():
    """Get manager's clients for filters"""
    from models import User
    
    manager_id = session.get('manager_id')
    
    try:
        # Get clients assigned to this manager or all buyers
        clients = User.query.filter_by(role='buyer').order_by(User.full_name).all()
        
        clients_data = []
        for client in clients:
            clients_data.append({
                'id': client.id,
                'full_name': client.full_name or '–ë–µ–∑ –∏–º–µ–Ω–∏',
                'email': client.email
            })
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/properties/search', methods=['POST'])
@login_required
def api_search_properties():
    """Search properties with filters from dashboard"""
    data = request.get_json()
    filters = data.get('filters', {})
    
    try:
        # Convert collection filters to property filters
        property_filters = {}
        
        if filters.get('priceFrom'):
            property_filters['price_min'] = filters['priceFrom']
        if filters.get('priceTo'):
            property_filters['price_max'] = filters['priceTo']
        if filters.get('rooms'):
            property_filters['rooms'] = filters['rooms']
        if filters.get('districts') and filters['districts']:
            property_filters['district'] = filters['districts'][0]
        if filters.get('developers') and filters['developers']:
            property_filters['developer'] = filters['developers'][0]
        if filters.get('areaFrom'):
            property_filters['area_min'] = filters['areaFrom']
        if filters.get('areaTo'):
            property_filters['area_max'] = filters['areaTo']
        
        # Get filtered properties
        filtered_properties = get_filtered_properties(property_filters)
        
        # Add cashback to each property
        for prop in filtered_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # Sort by price ascending
        filtered_properties = sort_properties(filtered_properties, 'price_asc')
        
        return jsonify({
            'success': True,
            'properties': filtered_properties[:50],  # Limit to 50 results
            'total_count': len(filtered_properties)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@manager_required
def api_send_property_to_client():
    """Send saved search results to client via email"""
    from models import SavedSearch, User, ClientPropertyRecommendation
    
    data = request.get_json()
    client_id = data.get('client_id')
    search_id = data.get('search_id')
    message = data.get('message', '')
    
    if not client_id or not search_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –∏ –ø–æ–∏—Å–∫ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}), 400
    
    try:
        # Get the search
        search = SavedSearch.query.get(search_id)
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get the client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get search filters
        filters = json.loads(search.filters) if search.filters else {}
        
        # Filter properties based on search criteria
        properties = load_properties()
        filtered_properties = filter_properties(properties, filters)
        
        # Create recommendation record
        recommendation = ClientPropertyRecommendation()
        recommendation.client_id = client_id
        recommendation.manager_id = session.get('manager_id')
        recommendation.search_name = search.name
        recommendation.search_filters = search.filters
        recommendation.message = message
        recommendation.properties_count = len(filtered_properties)
        recommendation.sent_at = datetime.utcnow()
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send email with property recommendations
        send_property_email(client, search.name, filtered_properties, message)
        
        return jsonify({'success': True, 'properties_sent': len(filtered_properties)})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def filter_properties(properties, filters):
    """Filter properties based on search criteria"""
    filtered = []
    
    for prop in properties:
        # Price filter
        if filters.get('priceFrom'):
            try:
                if prop.get('price', 0) < int(filters['priceFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('priceTo'):
            try:
                if prop.get('price', 0) > int(filters['priceTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Rooms filter
        if filters.get('rooms'):
            prop_rooms = str(prop.get('rooms', ''))
            if filters['rooms'] == 'studio' and prop_rooms != 'studio':
                continue
            elif filters['rooms'] != 'studio' and prop_rooms != str(filters['rooms']):
                continue
        
        # District filter
        if filters.get('districts') and len(filters['districts']) > 0:
            prop_district = prop.get('district', '')
            if prop_district not in filters['districts']:
                continue
        
        # Area filter
        if filters.get('areaFrom'):
            try:
                if prop.get('area', 0) < int(filters['areaFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('areaTo'):
            try:
                if prop.get('area', 0) > int(filters['areaTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Developer filter
        if filters.get('developers') and len(filters['developers']) > 0:
            prop_developer = prop.get('developer', '')
            if prop_developer not in filters['developers']:
                continue
        
        filtered.append(prop)
    
    return filtered

def send_property_email(client, search_name, properties, message):
    """Send email with property recommendations"""
    try:
        subject = f"–ù–æ–≤–∞—è –ø–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {search_name}"
        
        properties_html = ""
        for prop in properties[:10]:  # Limit to first 10 properties
            properties_html += f"""
            <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #1f2937;">{prop.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}</h3>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–ñ–ö: {prop.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')}</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–¶–µ–Ω–∞: {prop.get('price', 0):,} ‚ÇΩ</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–ü–ª–æ—â–∞–¥—å: {prop.get('area', 0)} –º¬≤</p>
                <p style="margin: 0 0 8px 0; color: #6b7280;">–ö–æ–º–Ω–∞—Ç: {prop.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</p>
                <a href="https://inback.ru/properties/{prop.get('id', '')}" style="color: #0088cc; text-decoration: none;">–ü–æ–¥—Ä–æ–±–Ω–µ–µ ‚Üí</a>
            </div>
            """
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h2 style="color: #0088cc;">–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏</h2>
                
                <p>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!</p>
                
                <p>–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: <strong>{search_name}</strong></p>
                
                {f'<div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;"><p style="margin: 0; font-style: italic;">"{message}"</p></div>' if message else ''}
                
                <h3>–ù–∞–π–¥–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã ({len(properties)} –æ–±—ä–µ–∫—Ç–æ–≤):</h3>
                
                {properties_html}
                
                {f'<p style="color: #6b7280;">–ò –µ—â–µ {len(properties) - 10} –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø–æ–ª–Ω–æ–º –∫–∞—Ç–∞–ª–æ–≥–µ...</p>' if len(properties) > 10 else ''}
                
                <div style="margin-top: 32px; padding: 20px; background: #f9fafb; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0 0 8px 0;">–ù—É–∂–Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è?</h3>
                    <p style="margin: 0 0 16px 0;">–°–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º</p>
                    <a href="mailto:manager@inback.ru" style="background: #0088cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">–ù–∞–ø–∏—Å–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä—É</a>
                </div>
                
                <div style="margin-top: 20px; text-align: center; color: #6b7280; font-size: 14px;">
                    <p>–° —É–≤–∞–∂–µ–Ω–∏–µ–º,<br>–ö–æ–º–∞–Ω–¥–∞ InBack.ru</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        return send_notification(
            client.email,
            subject,
            html_content,
            notification_type="property_recommendation",
            user_id=client.id
        )
    except Exception as e:
        print(f"Error sending property email: {e}")
        return False

@app.route('/api/manager/collection/<int:collection_id>/add_property', methods=['POST'])
@manager_required
def add_property_to_collection(collection_id):
    from models import Collection, CollectionProperty
    import json
    
    data = request.get_json()
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    manager_id = session.get('manager_id')
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=manager_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Load property data from JSON
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        property_info = None
        for prop in properties_data:
            if str(prop['id']) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Check if property already in collection
        existing = CollectionProperty.query.filter_by(
            collection_id=collection_id,
            property_id=str(property_id)
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø–æ–¥–±–æ—Ä–∫—É'}), 400
        
        # Get max order_index
        max_order = db.session.query(db.func.max(CollectionProperty.order_index)).filter_by(
            collection_id=collection_id
        ).scalar() or 0
        
        collection_property = CollectionProperty()
        collection_property.collection_id = collection_id
        collection_property.property_id = str(property_id)
        collection_property.property_name = property_info['title']
        collection_property.property_price = property_info['price']
        collection_property.complex_name = property_info.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω')
        collection_property.property_type = f"{property_info['rooms']}-–∫–æ–º–Ω"
        collection_property.property_size = property_info['area']
        collection_property.manager_note = manager_note
        collection_property.order_index = max_order + 1
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def send_collection(collection_id):
    from models import Collection
    
    manager_id = session.get('manager_id')
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=manager_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
    
    if len(collection.properties) == 0:
        return jsonify({'success': False, 'error': '–í –ø–æ–¥–±–æ—Ä–∫–µ –Ω–µ—Ç –∫–≤–∞—Ä—Ç–∏—Ä'}), 400
    
    try:
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/properties/search')
@manager_required
def search_properties():
    import json
    
    query = request.args.get('q', '').lower()
    limit = int(request.args.get('limit', 20))
    
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        filtered_properties = []
        for prop in properties_data:
            prop_type = f"{prop['rooms']}-–∫–æ–º–Ω"
            complex_name = prop.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω')
            
            property_title = f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤"
            if (query in property_title.lower() or 
                query in complex_name.lower() or 
                query in prop_type.lower() or
                query in prop.get('developer', '').lower() or
                query in prop.get('district', '').lower()):
                filtered_properties.append({
                    'id': prop['id'],
                    'title': f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤",
                    'price': prop['price'],
                    'complex': complex_name,
                    'type': prop_type,
                    'size': prop['area'],
                    'image': prop.get('image', '/static/images/property-placeholder.jpg')
                })
            
            if len(filtered_properties) >= limit:
                break
        
        return jsonify({'properties': filtered_properties})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/client/collections')
@login_required
def get_client_collections():
    """Get collections assigned to current user"""
    from models import Collection, CollectionProperty
    from datetime import datetime
    
    user_id = current_user.id
    
    collections = Collection.query.filter_by(assigned_to_user_id=user_id).all()
    
    collections_data = []
    for collection in collections:
        properties_count = len(collection.properties)
        
        # Mark as viewed if not already
        if collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
            collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
            collection.viewed_at = datetime.utcnow()
            db.session.commit()
        
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'created_by_manager_name': collection.created_by.full_name,
            'properties_count': properties_count,
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None,
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/client/collection/<int:collection_id>/properties')
@login_required
def get_client_collection_properties(collection_id):
    """Get properties in a collection for client view"""
    from models import Collection, CollectionProperty
    
    user_id = current_user.id
    
    collection = Collection.query.filter_by(
        id=collection_id,
        assigned_to_user_id=user_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    properties_data = []
    for prop in collection.properties:
        # Calculate potential cashback (example: 2% of price)
        cashback_percent = 2.0
        cashback_amount = int(prop.property_price * cashback_percent / 100)
        
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'cashback_amount': cashback_amount,
            'cashback_percent': cashback_percent
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: collection.properties[0].order_index if collection.properties else 0)
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'manager_name': collection.created_by.full_name,
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None
        },
        'properties': properties_data
    })

@app.route('/dashboard')
@login_required
def dashboard():
    """User dashboard"""
    try:
        from models import CashbackApplication, FavoriteProperty, Document, Collection, Recommendation, SentSearch, SavedSearch, UserActivity, Deal
        
        # Get user's data for dashboard
        cashback_apps = CashbackApplication.query.filter_by(user_id=current_user.id).all()
        favorites = FavoriteProperty.query.filter_by(user_id=current_user.id).all()
        documents = Document.query.filter_by(user_id=current_user.id).all()
        collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
        
        # Get user's deals (—Å–¥–µ–ª–∫–∏ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞)
        deals = Deal.query.filter_by(client_id=current_user.id).order_by(Deal.created_at.desc()).all()
        
        # Get recommendations from managers (exclude dismissed) with categories
        recommendations = Recommendation.query.filter(
            Recommendation.client_id == current_user.id,
            Recommendation.status != 'dismissed'
        ).options(db.joinedload(Recommendation.category)).order_by(Recommendation.created_at.desc()).all()
        
        # Get unique categories for the client (import here to avoid circular imports)
        from models import RecommendationCategory
        categories = RecommendationCategory.query.filter_by(client_id=current_user.id, is_active=True).all()
        
        # Load properties and complexes ONCE for all recommendations (optimization)
        properties = load_properties() if recommendations else []
        complexes = load_residential_complexes() if recommendations else []
        
        # Enrich recommendations with property details
        for rec in recommendations:
            if rec.recommendation_type == 'property' and rec.item_id:
                try:
                    property_data = next((p for p in properties if str(p.get('id')) == str(rec.item_id)), None)
                    if property_data:
                        # Create a simple object to store property details
                        class PropertyDetails:
                            def __init__(self, data, complexes):
                                for key, value in data.items():
                                    setattr(self, key, value)
                                
                                # Add residential complex name - try multiple sources
                                self.residential_complex = None
                                
                                # First try complex_name field (direct from expanded data)
                                if data.get('complex_name'):
                                    self.residential_complex = data.get('complex_name')
                                # Then try complex_id lookup
                                elif data.get('complex_id'):
                                    complex_data = next((c for c in complexes if c.get('id') == data.get('complex_id')), None)
                                    if complex_data:
                                        self.residential_complex = complex_data.get('name')
                                # Legacy support for residential_complex_id
                                elif data.get('residential_complex_id'):
                                    complex_data = next((c for c in complexes if c.get('id') == data.get('residential_complex_id')), None)
                                    if complex_data:
                                        self.residential_complex = complex_data.get('name')
                                
                                # Map property type from Russian to English for template logic
                                type_mapping = {
                                    '–ö–≤–∞—Ä—Ç–∏—Ä–∞': 'apartment',
                                    '–¢–∞—É–Ω—Ö–∞—É—Å': 'townhouse', 
                                    '–î–æ–º': 'house'
                                }
                                original_type = data.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞')
                                self.property_type = type_mapping.get(original_type, 'apartment')
                                self.property_type_ru = original_type
                        
                        rec.property_details = PropertyDetails(property_data, complexes)
                        complex_name = rec.property_details.residential_complex or '–ù–µ —É–∫–∞–∑–∞–Ω'
                        print(f"Loaded property {rec.item_id}: {property_data.get('rooms')} –∫–æ–º–Ω, –ñ–ö {complex_name}")
                    else:
                        print(f"Property {rec.item_id} not found in data files")
                        rec.property_details = None
                except Exception as e:
                    print(f"Error loading property details for recommendation {rec.id}: {e}")
                    rec.property_details = None
        
        # Get sent searches from managers
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Get user's saved searches
        saved_searches = SavedSearch.query.filter_by(user_id=current_user.id).order_by(SavedSearch.created_at.desc()).all()
        
        # Calculate totals
        total_cashback = sum(app.cashback_amount for app in cashback_apps if app.status == '–í—ã–ø–ª–∞—á–µ–Ω–∞')
        pending_cashback = sum(app.cashback_amount for app in cashback_apps if app.status == '–û–¥–æ–±—Ä–µ–Ω–∞')
        active_apps = len([app for app in cashback_apps if app.status in ['–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏', '–¢—Ä–µ–±—É—é—Ç—Å—è –¥–æ–∫—É–º–µ–Ω—Ç—ã']])
        
        # Get developer appointments
        from models import DeveloperAppointment
        appointments = DeveloperAppointment.query.filter_by(user_id=current_user.id).order_by(DeveloperAppointment.appointment_date.desc()).limit(3).all()
        
        # Load data for manager filters
        districts = get_districts_list()
        developers = get_developers_list()
        
        # Get recent user activities
        recent_activities = UserActivity.get_recent_activities(current_user.id, limit=5)
        
        return render_template('auth/dashboard.html', 
                             cashback_applications=cashback_apps,
                             favorites=favorites,
                             documents=documents,
                             collections=collections,
                             appointments=appointments,
                             recommendations=recommendations,
                             categories=categories,
                             sent_searches=sent_searches,
                             saved_searches=saved_searches,
                             deals=deals,
                             total_cashback=total_cashback,
                             pending_cashback=pending_cashback,
                             active_apps=active_apps,
                             districts=districts,
                             developers=developers,
                             recent_activities=recent_activities)
    except Exception as e:
        print(f"Dashboard error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return basic dashboard on error
        districts = get_districts_list()
        developers = get_developers_list()
        
        return render_template('auth/dashboard.html', 
                             cashback_applications=[],
                             favorites=[],
                             documents=[],
                             collections=[],
                             appointments=[],
                             recommendations=[],
                             sent_searches=[],
                             saved_searches=[],
                             deals=[],
                             total_cashback=0,
                             pending_cashback=0,
                             active_apps=0,
                             districts=districts,
                             developers=developers,
                             recent_activities=[])

@app.route('/logout')
@login_required
def logout():
    """Logout user"""
    logout_user()
    flash('–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã', 'success')
    return redirect(url_for('index'))

@app.route('/profile', methods=['GET', 'POST'])
@login_required
def profile():
    """User profile page"""
    from models import Manager
    
    if request.method == 'POST':
        try:
            # Update profile information
            current_user.full_name = request.form.get('full_name', current_user.full_name)
            current_user.phone = request.form.get('phone', current_user.phone)
            current_user.email = request.form.get('email', current_user.email)
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_user.password_hash = generate_password_hash(new_password)
                    flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω', 'success')
                else:
                    flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
                    return redirect(url_for('profile'))
            
            db.session.commit()
            flash('–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('profile'))
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è: {str(e)}', 'error')
            return redirect(url_for('profile'))
    
    # Get assigned manager info
    assigned_manager = None
    if current_user.assigned_manager_id:
        assigned_manager = Manager.query.get(current_user.assigned_manager_id)
    
    return render_template('auth/profile.html', 
                         user=current_user,
                         assigned_manager=assigned_manager)

@app.route('/manager/profile', methods=['GET', 'POST'])
@manager_required
def manager_profile():
    """Manager profile page"""
    from models import Manager
    
    manager_id = session.get('manager_id')
    current_manager = Manager.query.get(manager_id)
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    if request.method == 'POST':
        try:
            # Update profile information
            full_name = request.form.get('full_name', '')
            if full_name:
                name_parts = full_name.strip().split(maxsplit=1)
                current_manager.first_name = name_parts[0] if len(name_parts) > 0 else current_manager.first_name
                current_manager.last_name = name_parts[1] if len(name_parts) > 1 else current_manager.last_name
            
            current_manager.phone = request.form.get('phone', current_manager.phone)
            current_manager.email = request.form.get('email', current_manager.email)
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_manager.password_hash = generate_password_hash(new_password)
                    flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω', 'success')
                else:
                    flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
                    return redirect(url_for('manager_profile'))
            
            db.session.commit()
            flash('–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('manager_profile'))
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è: {str(e)}', 'error')
            return redirect(url_for('manager_profile'))
    
    return render_template('auth/manager_profile.html', 
                         manager=current_manager)

@app.route('/profile/upload-avatar', methods=['POST'])
@login_required
def upload_user_avatar():
    """Upload user avatar"""
    import os
    from werkzeug.utils import secure_filename
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"user_{current_user.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update user profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_user.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: {str(e)}'}), 500

@app.route('/manager/profile/upload-avatar', methods=['POST'])
@manager_required
def upload_manager_avatar():
    """Upload manager avatar"""
    import os
    from werkzeug.utils import secure_filename
    from models import Manager
    
    manager_id = session.get('manager_id')
    current_manager = Manager.query.get(manager_id)
    
    if not current_manager:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"manager_{current_manager.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update manager profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_manager.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: {str(e)}'}), 500

@app.route('/api/search')
def api_search():
    """API endpoint for global search"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify([])
    
    results = search_global(query)
    return jsonify(results)

@app.route('/search')
def search_results():
    """Search results page"""
    query = request.args.get('q', '').strip()
    search_type = request.args.get('type', 'all')  # all, residential_complex, district, developer, street
    
    results = []
    if query:
        results = search_global(query)
        
        # Filter by type if specified
        if search_type != 'all':
            results = [r for r in results if r['type'] == search_type]
    
    return render_template('search_results.html', 
                         query=query, 
                         results=results,
                         search_type=search_type)


@app.route('/api/smart-search-suggestions')
def smart_search_suggestions():
    """API endpoint for search suggestions with intelligent keyword matching"""
    query = request.args.get('q', '').strip().lower()
    if not query or len(query) < 1:
        return jsonify({'suggestions': []})
    
    suggestions = []
    
    try:
        # Intelligent room type matching patterns
        room_patterns = {
            # Single room patterns
            ('1', '1-', '1-–∫', '1-–∫–æ', '1-–∫–æ–º', '1 –∫', '1 –∫–æ', '1 –∫–æ–º', '–æ–¥–Ω', '–æ–¥–Ω–æ', '–æ–¥–Ω–æ–∫', '–æ–¥–Ω–æ–∫–æ–º–Ω', '–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç', '–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç–Ω', '–æ–¥–∏–Ω', '–æ–¥–Ω–æ–π'): ('1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '1'),
            # Two room patterns  
            ('2', '2-', '2-–∫', '2-–∫–æ', '2-–∫–æ–º', '2 –∫', '2 –∫–æ', '2 –∫–æ–º', '–¥–≤—É—Ö', '–¥–≤—É—Ö–∫', '–¥–≤—É—Ö–∫–æ–º', '–¥–≤—É—Ö–∫–æ–º–Ω', '–¥–≤—É—Ö–∫–æ–º–Ω–∞—Ç', '–¥–≤–∞', '–¥–≤–æ–π', '–¥–≤–æ–π–Ω'): ('2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '2'),
            # Three room patterns
            ('3', '3-', '3-–∫', '3-–∫–æ', '3-–∫–æ–º', '3 –∫', '3 –∫–æ', '3 –∫–æ–º', '—Ç—Ä–µ—Ö', '—Ç—Ä—ë—Ö', '—Ç—Ä–µ—Ö–∫', '—Ç—Ä—ë—Ö–∫', '—Ç—Ä–µ—Ö–∫–æ–º', '—Ç—Ä—ë—Ö–∫–æ–º', '—Ç—Ä–∏', '—Ç—Ä–æ–π'): ('3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '3'),
            # Four room patterns
            ('4', '4-', '4-–∫', '4-–∫–æ', '4-–∫–æ–º', '4 –∫', '4 –∫–æ', '4 –∫–æ–º', '—á–µ—Ç—ã—Ä', '—á–µ—Ç—ã—Ä–µ—Ö', '—á–µ—Ç—ã—Ä—ë—Ö', '—á–µ—Ç—ã—Ä–µ—Ö–∫', '—á–µ—Ç—ã—Ä—ë—Ö–∫', '—á–µ—Ç—ã—Ä–µ'): ('4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '4'),
            # Studio patterns
            ('—Å—Ç—É–¥', 'studio', '—Å—Ç—É–¥–∏–π', '—Å—Ç—É–¥–∏—è'): ('–°—Ç—É–¥–∏—è', 'rooms', 'studio'),
        }
        
        # Check room type patterns first
        for patterns, (room_text, type_val, value) in room_patterns.items():
            for pattern in patterns:
                if query.startswith(pattern) or pattern in query:
                    suggestions.append({
                        'text': room_text,
                        'type': type_val,
                        'value': value,
                        'category': '–¢–∏–ø –∫–≤–∞—Ä—Ç–∏—Ä—ã'
                    })
                    break
        
        # Search in regional data first (regions and cities)
        from models import Region, City
        
        # Search regions
        regions = Region.query.filter(Region.name.ilike(f'%{query}%')).limit(5).all()
        for region in regions:
            suggestions.append({
                'text': region.name,
                'type': 'region',
                'value': region.slug,
                'category': '–†–µ–≥–∏–æ–Ω'
            })
        
        # Search cities
        cities = City.query.filter(City.name.ilike(f'%{query}%')).limit(5).all()
        for city in cities:
            suggestions.append({
                'text': f"{city.name} ({city.region.name if city.region else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–≥–∏–æ–Ω'})",
                'type': 'city',
                'value': city.slug,
                'category': '–ì–æ—Ä–æ–¥'
            })

        # Search in database categories (districts, developers, complexes)
        cursor = db.session.execute(text("""
            SELECT name, category_type, slug 
            FROM search_categories 
            WHERE LOWER(name) LIKE :query 
            ORDER BY 
                CASE 
                    WHEN LOWER(name) LIKE :exact_start THEN 1
                    WHEN LOWER(name) LIKE :word_start THEN 2
                    ELSE 3
                END,
                LENGTH(name)
            LIMIT 10
        """), {
            'query': f'%{query}%',
            'exact_start': f'{query}%',
            'word_start': f'% {query}%'
        })
        
        category_names = {
            'district': '–†–∞–π–æ–Ω',
            'developer': '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫', 
            'complex': '–ñ–ö',
            'rooms': '–¢–∏–ø –∫–≤–∞—Ä—Ç–∏—Ä—ã',
            'region': '–†–µ–≥–∏–æ–Ω',
            'city': '–ì–æ—Ä–æ–¥'
        }
        
        for row in cursor:
            name, category_type, slug = row
            suggestions.append({
                'text': name,
                'type': category_type,
                'value': slug,
                'category': category_names.get(category_type, category_type.title())
            })
        
        # Remove duplicates while preserving order
        seen = set()
        unique_suggestions = []
        for s in suggestions:
            key = (s['text'], s['type'])
            if key not in seen:
                seen.add(key)
                unique_suggestions.append(s)
        
        return jsonify({'suggestions': unique_suggestions[:12]})
        
    except Exception as e:
        app.logger.error(f"Smart search error: {e}")
        return jsonify({'suggestions': []})

def init_search_data():
    """Initialize search data in database"""
    from models import District, Developer, ResidentialComplex, Street, RoomType
    
    # Districts
    districts_data = [
        ('–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π', 'tsentralnyy'), ('–ó–∞–ø–∞–¥–Ω—ã–π', 'zapadny'), 
        ('–ö–∞—Ä–∞—Å—É–Ω—Å–∫–∏–π', 'karasunsky'), ('–ü—Ä–∏–∫—É–±–∞–Ω—Å–∫–∏–π', 'prikubansky'),
        ('–§–µ—Å—Ç–∏–≤–∞–ª—å–Ω—ã–π', 'festivalny'), ('–Æ–±–∏–ª–µ–π–Ω—ã–π', 'yubileynyy'),
        ('–ì–∏–¥—Ä–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–µ–π', 'gidrostroitelei'), ('–°–æ–ª–Ω–µ—á–Ω—ã–π', 'solnechny'),
        ('–ü–∞–Ω–æ—Ä–∞–º–∞', 'panorama'), ('–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π', 'muzykalnyy')
    ]
    
    for name, slug in districts_data:
        if not District.query.filter_by(slug=slug).first():
            district = District(name=name, slug=slug)
            db.session.add(district)
    
    # Room types
    room_types_data = [
        ('–°—Ç—É–¥–∏—è', 0), ('1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 1), 
        ('2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 2), ('3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 3), 
        ('4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 4), ('–ü–µ–Ω—Ç—Ö–∞—É—Å', 5)
    ]
    
    for name, rooms_count in room_types_data:
        if not RoomType.query.filter_by(name=name).first():
            room_type = RoomType(name=name, rooms_count=rooms_count)
            db.session.add(room_type)
    
    # Developers
    developers_data = [
        ('–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –ò–Ω–≤–µ—Å—Ç', 'krasnodar-invest'),
        ('–Æ–≥–°—Ç—Ä–æ–π–ò–Ω–≤–µ—Å—Ç', 'yugstroyinvest'),
        ('–§–ª–∞–≥–º–∞–Ω', 'flagman'),
        ('–°–æ–ª–Ω–µ—á–Ω—ã–π –≥–æ—Ä–æ–¥', 'solnechny-gorod'),
        ('–ü—Ä–µ–º—å–µ—Ä', 'premier')
    ]
    
    for name, slug in developers_data:
        if not Developer.query.filter_by(slug=slug).first():
            developer = Developer(name=name, slug=slug)
            db.session.add(developer)
    
    # Residential complexes
    complexes_data = [
        ('–°–æ–ª–Ω–µ—á–Ω—ã–π', 'solnechny', 1, 1),
        ('–ü–∞–Ω–æ—Ä–∞–º–∞', 'panorama', 1, 2),
        ('–ì–∞—Ä–º–æ–Ω–∏—è', 'garmoniya', 2, 3),
        ('–ï–≤—Ä–æ–ø–µ–π—Å–∫–∏–π –∫–≤–∞—Ä—Ç–∞–ª', 'evropeyskiy-kvartal', 3, 1),
        ('–§–ª–∞–≥–º–∞–Ω', 'flagman', 4, 4)
    ]
    
    for name, slug, district_id, developer_id in complexes_data:
        if not ResidentialComplex.query.filter_by(slug=slug).first():
            complex = ResidentialComplex(name=name, slug=slug, district_id=district_id, developer_id=developer_id)
            db.session.add(complex)
    
    db.session.commit()


# ==================== ADMIN ROUTES ====================

@app.route('/admin/login', methods=['GET', 'POST'])
@csrf.exempt  # Exempt admin login from CSRF protection
def admin_login():
    """Admin login page"""
    if request.method == 'POST':
        from models import Admin
        email = request.form.get('email')
        password = request.form.get('password')
        
        admin = Admin.query.filter_by(email=email, is_active=True).first()
        
        if admin and admin.check_password(password):
            session.permanent = True
            session['admin_id'] = admin.id
            session['is_admin'] = True
            admin.last_login = datetime.utcnow()
            db.session.commit()
            flash('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!', 'success')
            return redirect(url_for('admin_dashboard'))
        else:
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å', 'error')
    
    return render_template('admin/admin_login.html')

@app.route('/admin/logout')
def admin_logout():
    """Admin logout"""
    session.pop('admin_id', None)
    session.pop('is_admin', None)
    flash('–í—ã –≤—ã—à–ª–∏ –∏–∑ –ø–∞–Ω–µ–ª–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞', 'info')
    return redirect(url_for('admin_login'))

def admin_required(f):
    """Decorator to require admin authentication"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('is_admin') or not session.get('admin_id'):
            return redirect(url_for('admin_login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/admin')
def admin_base():
    """Base admin route - redirects to dashboard or login"""
    admin_id = session.get('admin_id')
    if admin_id:
        return redirect(url_for('admin_dashboard'))
    return redirect(url_for('admin_login'))

@app.route('/admin/client-management')
@admin_required
def admin_client_management():
    """Separate page for client-manager assignment"""
    try:
        from models import Admin
        
        admin_id = session.get('admin_id')
        if not admin_id:
            flash('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', 'error')
            return redirect(url_for('admin_login'))
            
        current_admin = Admin.query.get(admin_id)
        if not current_admin:
            flash('–ê–¥–º–∏–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('admin_login'))
        
        return render_template('admin/client_management.html', admin=current_admin)
        
    except Exception as e:
        print(f"ERROR in admin_client_management: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/dashboard')
@admin_required
def admin_dashboard():
    """Admin dashboard with analytics"""
    from models import Admin, User, Manager, CashbackApplication, CallbackRequest
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    # Analytics data
    stats = {
        'total_users': User.query.count(),
        'total_managers': Manager.query.count(),
        'total_applications': CashbackApplication.query.count(),
        'pending_applications': CashbackApplication.query.filter_by(status='–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏').count(),
        'approved_applications': CashbackApplication.query.filter_by(status='–û–¥–æ–±—Ä–µ–Ω–∞').count(),
        'paid_applications': CashbackApplication.query.filter_by(status='–í—ã–ø–ª–∞—á–µ–Ω–∞').count(),
        'total_cashback_approved': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='–û–¥–æ–±—Ä–µ–Ω–∞').all()),
        'total_cashback_paid': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='–í—ã–ø–ª–∞—á–µ–Ω–∞').all()),
        'active_users': User.query.filter_by(is_active=True).count(),
        'active_managers': Manager.query.filter_by(is_active=True).count(),
        'cashback_requests': CallbackRequest.query.filter(CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')).count(),
        'new_requests': CallbackRequest.query.filter_by(status='–ù–æ–≤–∞—è').count(),
    }
    
    # Recent activity
    recent_applications = CashbackApplication.query.order_by(CashbackApplication.created_at.desc()).limit(10).all()
    recent_users = User.query.order_by(User.created_at.desc()).limit(10).all()
    recent_cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')
    ).order_by(CallbackRequest.created_at.desc()).limit(5).all()
    
    return render_template('admin/dashboard.html',
                         admin=current_admin,
                         stats=stats,
                         recent_applications=recent_applications,
                         recent_users=recent_users,
                         recent_cashback_requests=recent_cashback_requests,
                         current_date=datetime.now())

@app.route('/admin/cashback-requests')
@admin_required
def admin_cashback_requests():
    """View all cashback requests"""
    from models import CallbackRequest
    
    # Get page number
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Filter cashback requests
    cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')
    ).order_by(CallbackRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/cashback_requests.html',
                         requests=cashback_requests)

@app.route('/admin/callback-request/<int:request_id>/status', methods=['POST'])
@admin_required
def update_callback_request_status(request_id):
    """Update callback request status"""
    from models import CallbackRequest
    
    try:
        data = request.get_json()
        new_status = data.get('status')
        
        callback_request = CallbackRequest.query.get_or_404(request_id)
        callback_request.status = new_status
        
        if new_status == '–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞':
            callback_request.processed_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/count', methods=['GET'])
@login_required  
def get_favorites_count():
    """Get count of user's favorites"""
    from models import FavoriteProperty, FavoriteComplex
    
    try:
        properties_count = FavoriteProperty.query.filter_by(user_id=current_user.id).count()
        complexes_count = FavoriteComplex.query.filter_by(user_id=current_user.id).count()
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/list', methods=['GET'])
@login_required  
def get_favorites_list():
    """Get user's favorite properties with full details"""
    from models import FavoriteProperty
    
    try:
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        print(f"Found {len(favorites)} favorites in database for user {current_user.id}")
        
        # Load properties data
        properties_data = load_properties()
        print(f"Loaded {len(properties_data)} properties from database")
        
        # Debug: show first few property IDs
        if properties_data:
            ids = [str(p.get('id')) for p in properties_data[:5]]
            print(f"First 5 property IDs from JSON: {ids}")
        
        favorites_list = []
        for fav in favorites:
            # ‚úÖ FIXED: Safe comparison - handle None, empty string, and invalid values
            if not fav.property_id:
                print(f"Skipping favorite with empty property_id")
                continue
                
            print(f"Looking for property_id {fav.property_id} (type: {type(fav.property_id)})")
            
            # Get property data from JSON files - compare as strings to avoid type errors
            property_data = None
            for prop in properties_data:
                try:
                    # Safe comparison using string conversion
                    if str(prop.get('id', '')).strip() == str(fav.property_id).strip():
                        property_data = prop
                        break
                except (ValueError, AttributeError) as e:
                    print(f"Error comparing property IDs: {e}")
                    continue
            
            if property_data:
                print(f"Found property data for ID {fav.property_id}")
                # Add to favorites list with complete data including timestamp
                favorites_list.append({
                    'id': property_data.get('id'),
                    'title': property_data.get('title', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
                    'complex': property_data.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'),
                    'district': property_data.get('district', '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'),
                    'price': property_data.get('price', 0),
                    'image': property_data.get('main_image', '/static/images/no-photo.jpg'),
                    'cashback_amount': calculate_cashback(
                        property_data.get('price', 0),
                        complex_id=property_data.get('complex_id'),
                        complex_name=property_data.get('residential_complex')
                    ),
                    'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ',
                    'viewed': fav.viewed if hasattr(fav, 'viewed') else False
                })
            else:
                print(f"No property data found for ID {fav.property_id}")
                # Create fallback entry with minimal data
                favorites_list.append({
                    'id': fav.property_id,
                    'title': f'–û–±—ä–µ–∫—Ç #{fav.property_id}',
                    'complex': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω',
                    'district': '–î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è...',
                    'price': 0,
                    'image': '/static/images/no-photo.jpg',
                    'cashback_amount': 0
                })
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        print(f"Error in get_favorites_list: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/mark-viewed/<property_id>', methods=['POST'])
@login_required
@csrf.exempt
def mark_favorite_viewed(property_id):
    """Mark favorite property as viewed"""
    from models import FavoriteProperty
    
    try:
        favorite = FavoriteProperty.query.filter_by(
            user_id=current_user.id,
            property_id=str(property_id)
        ).first()
        
        if favorite:
            favorite.viewed = True
            db.session.commit()
            return jsonify({'success': True})
        
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Complex Favorites API
@app.route('/api/complexes/favorites', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def add_complex_to_favorites():
    """Add residential complex to favorites"""
    from models import FavoriteComplex
    data = request.get_json()
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', '–ñ–ö')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = FavoriteComplex(
            user_id=current_user.id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            address_display_name=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/<complex_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # Disable CSRF for API endpoint
def remove_complex_from_favorites(complex_id):
    """Remove residential complex from favorites"""
    from models import FavoriteComplex
    
    favorite = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/toggle', methods=['POST'])
@login_required
@csrf.exempt  # Disable CSRF for API endpoint
def toggle_complex_favorite():
    """Toggle favorite status for residential complex"""
    from models import FavoriteComplex
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    try:
        existing = FavoriteComplex.query.filter_by(
            user_id=current_user.id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # Add to favorites
            favorite = FavoriteComplex(
                user_id=current_user.id,
                complex_id=str(complex_id),
                complex_name=data.get('complex_name', '–ñ–ö'),
                developer_name=data.get('developer_name', ''),
                complex_address=data.get('address', ''),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: complex_address –≤–º–µ—Å—Ç–æ address_display_name
                district=data.get('district', ''),
                min_price=data.get('min_price'),
                max_price=data.get('max_price'),
                complex_image=data.get('image', ''),
                complex_url=data.get('url', ''),
                status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/list', methods=['GET'])
@login_required  
def get_complex_favorites_list():
    """Get user's favorite complexes with full details"""
    from models import FavoriteComplex
    
    try:
        favorites = db.session.query(FavoriteComplex).filter_by(user_id=current_user.id).order_by(FavoriteComplex.created_at.desc()).all()
        
        favorites_list = []
        for fav in favorites:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ excel_properties –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ—Ç –∂–µ SQL —á—Ç–æ –∏ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
            real_complex_name = fav.complex_name or '–ñ–ö'
            real_developer_name = fav.developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            real_address = fav.complex_address or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            real_district = fav.district or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'  
            real_min_price = fav.min_price or 0
            real_max_price = fav.max_price or 0
            real_image = fav.complex_image or ''
            
            print(f"DEBUG: Searching for user complex with fav.complex_id: {fav.complex_id}")
            
            if fav.complex_id:
                try:
                    # ‚úÖ –ù–û–í–û–ï: –ò—â–µ–º –≤ excel_properties –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ—Ç –∂–µ SQL —á—Ç–æ –∏ /residential-complexes
                    excel_complex_query = db.session.execute(text("""
                        SELECT 
                            ep.complex_name,
                            COUNT(*) as apartments_count,
                            MIN(ep.price) as price_from,
                            MAX(ep.price) as price_to,
                            MAX(ep.developer_name) as developer_name,
                            MAX(ep.address_display_name) as address_display_name,
                            COALESCE(rc.id, ROW_NUMBER() OVER (ORDER BY ep.complex_name) + 1000) as real_id,
                            COALESCE(rc.cashback_rate, 5.0) as cashback_rate,
                            (SELECT photos FROM excel_properties p2 
                             WHERE p2.complex_name = ep.complex_name 
                             AND p2.photos IS NOT NULL 
                             ORDER BY p2.price DESC LIMIT 1) as photos
                        FROM excel_properties ep
                        LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
                        GROUP BY ep.complex_name, rc.id, rc.cashback_rate
                        ORDER BY ep.complex_name
                    """))
                    
                    # –ù–∞—Ö–æ–¥–∏–º –∫–æ–º–ø–ª–µ–∫—Å —Å –Ω—É–∂–Ω—ã–º ID
                    target_id = int(fav.complex_id)
                    real_cashback_rate = 5.0  # Default
                    for row in excel_complex_query:
                        if int(row.real_id) == target_id:
                            real_complex_name = row.complex_name
                            real_developer_name = row.developer_name or real_developer_name
                            real_address = row.address_display_name or real_address
                            real_min_price = int(row.price_from) if row.price_from else 0
                            real_max_price = int(row.price_to) if row.price_to else 0
                            real_cashback_rate = float(row.cashback_rate) if row.cashback_rate else 5.0
                            
                            # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ
                            if row.photos:
                                try:
                                    import json
                                    photos = json.loads(row.photos) if isinstance(row.photos, str) else row.photos
                                    if photos and isinstance(photos, list) and len(photos) > 0:
                                        real_image = photos[0]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ
                                except Exception as photo_error:
                                    print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                            
                            print(f"DEBUG: ‚úÖ Found user complex in excel_properties: {real_complex_name}")
                            break
                    else:
                        print(f"DEBUG: ‚ùå User complex with ID {fav.complex_id} not found in excel_properties")
                
                except Exception as e:
                    print(f"DEBUG: Error searching user excel_properties: {e}")
            
            favorites_list.append({
                'id': fav.complex_id,
                'name': real_complex_name,
                'developer': real_developer_name,
                'address': real_address,
                'district': real_district,
                'min_price': real_min_price,
                'max_price': real_max_price,
                'cashback_rate': real_cashback_rate if fav.complex_id else 5.0,
                'image': real_image,
                'url': fav.complex_url,
                'status': fav.status,
                'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
            })
        
        return jsonify({
            'success': True,
            'complexes': favorites_list
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_favorites():
    """Clear all user's favorite properties"""
    from models import FavoriteProperty
    
    try:
        # Delete all favorites for current user
        deleted_count = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –∫–≤–∞—Ä—Ç–∏—Ä',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_complex_favorites():
    """Clear all user's favorite complexes"""
    from models import FavoriteComplex
    
    try:
        # Delete all complex favorites for current user
        deleted_count = db.session.query(FavoriteComplex).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ñ–ö',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Favorites API - Properties
@app.route('/api/manager/favorites', methods=['POST'])
@manager_required  
def manager_add_to_favorites():
    """Add property to manager's favorites"""
    from models import ManagerFavoriteProperty
    data = request.get_json()
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=manager_id,
        property_id=data.get('property_id')
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–£–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'})
    
    try:
        favorite = ManagerFavoriteProperty(
            manager_id=manager_id,
            property_id=data.get('property_id'),
            property_name=data.get('property_name', ''),
            property_type=data.get('property_type', ''),
            property_size=float(data.get('property_size', 0)),
            property_price=int(data.get('property_price', 0)),
            complex_name=data.get('complex_name', ''),
            developer_name=data.get('developer_name', ''),
            property_image=data.get('property_image'),
            property_url=data.get('property_url'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0)),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/<property_id>', methods=['DELETE'])
@manager_required
def manager_remove_from_favorites(property_id):
    """Remove property from manager's favorites"""
    from models import ManagerFavoriteProperty
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    favorite = ManagerFavoriteProperty.query.filter_by(
        manager_id=manager_id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True, 'message': '–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    
    return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'}), 404

@app.route('/api/manager/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_favorite():
    """Toggle favorite status for property"""
    from models import ManagerFavoriteProperty
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    print(f"DEBUG: Manager favorites toggle called by manager {manager_id} for property {property_id}")
    print(f"DEBUG: Request data: {data}")
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=manager_id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False, 'message': '–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # Add to favorites
            favorite = ManagerFavoriteProperty(
                manager_id=manager_id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                property_url=data.get('property_url'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0)),
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True, 'message': '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/count', methods=['GET'])
@manager_required  
def manager_get_favorites_count():
    """Get count of manager's favorites"""
    from models import ManagerFavoriteProperty, ManagerFavoriteComplex
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    try:
        properties_count = ManagerFavoriteProperty.query.filter_by(manager_id=manager_id).count()
        complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=manager_id).count()
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Note: Manager Complex Favorites endpoints already exist below - no duplicates needed

@app.route('/api/manager/favorites/list', methods=['GET'])
@manager_required  
def manager_get_favorites_list():
    """Get manager's favorite properties with full details - OPTIMIZED"""
    from models import ManagerFavoriteProperty, ExcelProperty
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    try:
        favorites = db.session.query(ManagerFavoriteProperty).filter_by(manager_id=manager_id).order_by(ManagerFavoriteProperty.created_at.desc()).all()
        print(f"Found {len(favorites)} favorites in database for manager {manager_id}")
        
        if not favorites:
            return jsonify({'success': True, 'favorites': []})
        
        # ‚úÖ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –ø–æ ID –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        favorite_ids = [fav.property_id for fav in favorites if fav.property_id]
        if not favorite_ids:
            return jsonify({'success': True, 'favorites': []})
        
        # ‚úÖ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ò—Å–ø–æ–ª—å–∑—É–µ–º SQL –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        from sqlalchemy import text
        placeholders = ','.join([':id_{}'.format(i) for i in range(len(favorite_ids))])
        params = {'id_{}'.format(i): favorite_ids[i] for i in range(len(favorite_ids))}
        
        query = text(f"""
            SELECT ep.inner_id, ep.price, ep.object_area, ep.object_rooms, ep.object_min_floor, ep.object_max_floor,
                   ep.address_display_name, ep.renovation_display_name, ep.photos, ep.developer_name, ep.complex_name,
                   ep.address_position_lat, ep.address_position_lon, ep.description, ep.address_locality_name,
                   ep.complex_object_class_display_name, COALESCE(rc.cashback_rate, 5.0) as cashback_rate
            FROM excel_properties ep
            LEFT JOIN residential_complexes rc ON ep.complex_name = rc.name
            WHERE ep.inner_id IN ({placeholders})
        """)
        
        result = db.session.execute(query, params)
        excel_properties = result.fetchall()
        
        # –°–æ–∑–¥–∞–µ–º –±—ã—Å—Ç—Ä—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–æ–∏—Å–∫–∞
        properties_dict = {}
        for row in excel_properties:
            inner_id, price, area, rooms, min_floor, max_floor, address, renovation, photos, developer_name, complex_name, lat, lon, description, district_name, housing_class, cashback_rate = row
            properties_dict[str(inner_id)] = {
                'id': inner_id,
                'price': price or 0,
                'area': area or 0,
                'rooms': rooms or 0,
                'min_floor': min_floor or 1,
                'max_floor': max_floor or min_floor,
                'address': address,
                'renovation': renovation,
                'photos': photos,
                'developer_name': developer_name,
                'complex_name': complex_name,
                'lat': lat,
                'lon': lon,
                'description': description,
                'district': district_name,
                'housing_class': housing_class or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'cashback_percent': cashback_rate or 5.0  # –†–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –æ—Ç –ñ–ö –∏–∑ –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏
            }
        
        favorites_list = []
        for fav in favorites:
            property_data = properties_dict.get(str(fav.property_id))
            if not property_data:
                continue
            
            if property_data:
                print(f"Found property data for ID {fav.property_id}")
                # Add to favorites list with complete data including timestamp and manager fields
                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô MAPPING: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–∑ SQL query
                rooms_text = ""
                if property_data.get('rooms') == 0:
                    rooms_text = "–°—Ç—É–¥–∏—è"
                elif property_data.get('rooms'):
                    rooms_text = f"{property_data.get('rooms')}-–∫–æ–º–Ω."
                
                area_text = f"{property_data.get('area')} –º¬≤" if property_data.get('area') else ""
                floor_text = f"{property_data.get('min_floor')}-{property_data.get('max_floor')} —ç—Ç." if property_data.get('min_floor') and property_data.get('max_floor') else ""
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º title –∫–∞–∫ –≤ –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç—è—Ö —Å–∏—Å—Ç–µ–º—ã
                title_parts = [rooms_text, area_text, floor_text]
                title = ", ".join([part for part in title_parts if part]) or '–ö–≤–∞—Ä—Ç–∏—Ä–∞'
                
                # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ –∏–∑ JSON —Å—Ç—Ä–æ–∫–∏
                photos_list = []
                if property_data.get('photos'):
                    try:
                        import json
                        photos_list = json.loads(property_data.get('photos')) if isinstance(property_data.get('photos'), str) else property_data.get('photos')
                    except:
                        photos_list = []
                
                main_image = photos_list[0] if photos_list and isinstance(photos_list, list) else '/static/images/no-photo.jpg'
                
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫
                cashback_percent = property_data.get('cashback_percent', 5.0)
                cashback_amount = int(property_data.get('price', 0) * cashback_percent / 100)
                
                favorites_list.append({
                    'id': property_data.get('id'),
                    'title': title,
                    'complex': property_data.get('complex_name') or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',  # ‚úÖ complex_name –∏–∑ SQL
                    'district': property_data.get('address') or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',  # ‚úÖ –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–¥—Ä–µ—Å –∫–≤–∞—Ä—Ç–∏—Ä—ã
                    'price': property_data.get('price', 0),
                    'image': main_image,  # ‚úÖ –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ –∏–∑ photos array
                    'cashback_amount': cashback_amount,  # ‚úÖ –†–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                    'cashback_percent': cashback_percent,  # ‚úÖ –ü—Ä–æ—Ü–µ–Ω—Ç –∫—ç—à–±–µ–∫–∞
                    'notes': fav.notes,
                    'recommended_for': fav.recommended_for,
                    'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ',
                    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã
                    'area': property_data.get('area'),
                    'rooms': property_data.get('rooms'),
                    'floor': property_data.get('min_floor'),
                    'address': property_data.get('address'),
                    'developer': property_data.get('developer_name'),
                    'housing_class': property_data.get('housing_class')  # ‚úÖ –ö–ª–∞—Å—Å –∂–∏–ª—å—è
                })
            else:
                print(f"No property data found for ID {fav.property_id}")
                # Create fallback entry with minimal data
                favorites_list.append({
                    'id': fav.property_id,
                    'title': f'–û–±—ä–µ–∫—Ç #{fav.property_id}',
                    'complex': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω',
                    'district': '–î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è...',
                    'price': 0,
                    'image': '/static/images/no-photo.jpg',
                    'cashback_amount': 0,
                    'notes': fav.notes,
                    'recommended_for': fav.recommended_for,
                    'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
                })
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        import traceback
        print(f"‚ùå ERROR in manager_get_favorites_list: {str(e)}")
        print(f"‚ùå Traceback: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Favorites API - Complexes
@app.route('/api/manager/complexes/favorites', methods=['POST'])
@manager_required  
def manager_add_complex_to_favorites():
    """Add residential complex to manager's favorites"""
    from models import ManagerFavoriteComplex
    data = request.get_json()
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', '–ñ–ö')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = ManagerFavoriteComplex.query.filter_by(
        manager_id=manager_id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = ManagerFavoriteComplex(
            manager_id=manager_id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            complex_address=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ'),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/<complex_id>', methods=['DELETE'])
@manager_required
def manager_remove_complex_from_favorites(complex_id):
    """Remove residential complex from manager's favorites"""
    from models import ManagerFavoriteComplex
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    favorite = ManagerFavoriteComplex.query.filter_by(
        manager_id=manager_id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_complex_favorite():
    """Toggle favorite status for residential complex"""
    from models import ManagerFavoriteComplex
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
    
    try:
        existing = ManagerFavoriteComplex.query.filter_by(
            manager_id=manager_id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            real_complex_name = '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'
            real_developer_name = '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_address = '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_district = '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = '–í –ø—Ä–æ–¥–∞–∂–µ'
            
            try:
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ excel_properties –ø–æ complex_id
                from sqlalchemy import text
                complex_query = text("""
                    SELECT 
                        complex_name,
                        developer_name,
                        address_display_name,
                        address_locality_name,
                        MIN(price) as min_price,
                        MAX(price) as max_price,
                        (SELECT photos FROM excel_properties ep2 
                         WHERE ep2.complex_id = :complex_id 
                         AND ep2.photos IS NOT NULL 
                         ORDER BY ep2.price DESC LIMIT 1) as photos
                    FROM excel_properties 
                    WHERE complex_id = :complex_id OR inner_id = :complex_id
                    GROUP BY complex_name, developer_name, address_display_name, address_locality_name
                    LIMIT 1
                """)
                
                result = db.session.execute(complex_query, {'complex_id': str(complex_id)})
                row = result.fetchone()
                
                if row:
                    real_complex_name = row[0] or real_complex_name
                    real_developer_name = row[1] or real_developer_name  
                    real_address = row[2] or real_address
                    real_district = row[3] or real_district
                    real_min_price = int(row[4]) if row[4] else 0
                    real_max_price = int(row[5]) if row[5] else 0
                    
                    # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ –∏–∑ JSON
                    if row[6]:
                        try:
                            import json
                            photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                            if photos and isinstance(photos, list) and len(photos) > 0:
                                real_image = photos[0]  # –ü–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–µ
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ –≥–æ–¥—É —Å–¥–∞—á–∏
                    from datetime import datetime
                    current_year = datetime.now().year
                    
                    try:
                        status_query = text("""
                            SELECT complex_building_end_build_year 
                            FROM excel_properties 
                            WHERE (complex_id = :complex_id OR inner_id = :complex_id)
                            AND complex_building_end_build_year IS NOT NULL
                            ORDER BY complex_building_end_build_year ASC LIMIT 1
                        """)
                        status_result = db.session.execute(status_query, {'complex_id': str(complex_id)})
                        status_row = status_result.fetchone()
                        
                        if status_row and status_row[0]:
                            build_year = int(status_row[0])
                            real_status = '–°–¥–∞–Ω' if build_year <= current_year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                    except:
                        pass
                        
            except Exception as e:
                print(f"Error loading real complex data for {complex_id}: {e}")
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å fallback –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                pass
            
            # Add to favorites with REAL DATA
            favorite = ManagerFavoriteComplex(
                manager_id=manager_id,
                complex_id=str(complex_id),
                complex_name=real_complex_name,
                developer_name=real_developer_name,
                complex_address=real_address,
                district=real_district,
                min_price=real_min_price,
                max_price=real_max_price,
                complex_image=real_image,
                complex_url=data.get('url', f'/zk/{complex_id}'),
                status=real_status,
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/list', methods=['GET'])
@manager_required
def manager_get_complex_favorites_list():
    """Get manager's favorite complexes with full details"""
    from models import ManagerFavoriteComplex, ResidentialComplex, Developer, District
    from sqlalchemy.orm import joinedload, selectinload
    from sqlalchemy import or_
    
    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    manager_id = session.get('manager_id')
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–±—Ä–∞–Ω–Ω–æ–µ –±–µ–∑ broken relationship
        favorites = db.session.query(ManagerFavoriteComplex)\
            .filter_by(manager_id=manager_id)\
            .order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        # –°–æ–±–∏—Ä–∞–µ–º ID –∫–æ–º–ø–ª–µ–∫—Å–æ–≤ –¥–ª—è batch-–∑–∞–≥—Ä—É–∑–∫–∏
        complex_ids_str = [fav.complex_id for fav in favorites if fav.complex_id]
        complex_ids_int = []
        for cid in complex_ids_str:
            try:
                complex_ids_int.append(int(cid))
            except (ValueError, TypeError):
                pass
        
        # BYPASSING broken favorites data - use direct ResidentialComplex lookup since FK is broken
        # Get complex names from ResidentialComplex table using favorites complex_id (if exists)
        complex_names = []
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name:
                        complex_names.append(rc.name)
                except (ValueError, TypeError):
                    pass
        
        # Fallback: If no matches found, use all residential complexes for demo
        if not complex_names:
            all_complexes = ResidentialComplex.query.limit(10).all()
            complex_names = [rc.name for rc in all_complexes if rc.name]
        
        # ENSURE we include ALL favorite complex names even if not in excel_data
        # This prevents missing complexes in comparison
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name and rc.name not in complex_names:
                        complex_names.append(rc.name)
                        print(f"DEBUG: Added missing favorite complex to search: {rc.name}")
                except (ValueError, TypeError):
                    pass
        excel_data = {}
        
        if complex_names:
            # SQL aggregation with proper expanding bind and name normalization
            from sqlalchemy import text, bindparam
            
            # Normalize names for matching
            normalized_names = tuple({n.strip().lower().replace('¬´','"').replace('¬ª','"') 
                                    for n in complex_names if n})
            
            stmt = text("""
            SELECT 
                complex_name,
                MIN(price) as min_price,
                MAX(price) as max_price,
                COUNT(*) as apartments_count,
                MIN(address_display_name) as sample_address,
                MAX(photos) as photos
            FROM excel_properties 
            WHERE lower(complex_name) IN :names
            GROUP BY complex_name
            """).bindparams(bindparam('names', expanding=True))
            
            result = db.session.execute(stmt, {'names': normalized_names})
            for row in result:
                # Store with original complex name for mapping
                for original_name in complex_names:
                    if original_name and original_name.strip().lower().replace('¬´','"').replace('¬ª','"') == row.complex_name.lower():
                        excel_data[original_name] = {
                            'min_price': int(row.min_price) if row.min_price else 0,
                            'max_price': int(row.max_price) if row.max_price else 0,
                            'apartments_count': int(row.apartments_count) if row.apartments_count else 0,
                            'sample_address': row.sample_address or '',
                            'photos': row.photos
                        }
                        break
            
            print(f"DEBUG: Searched {len(normalized_names)} names, found {len(excel_data)} matches")
            print(f"DEBUG: excel_data keys: {list(excel_data.keys())[:2]}")  # First 2 keys
        
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –∫–æ–º–ø–ª–µ–∫—Å—ã —Å—Ä–∞–∑—É —Å joined –¥–∞–Ω–Ω—ã–º–∏  
        complexes_data = {}
        if complex_ids_str:
            complexes_query = db.session.query(ResidentialComplex)\
                .options(
                    joinedload(ResidentialComplex.developer), 
                    joinedload(ResidentialComplex.district),
                    selectinload(ResidentialComplex.buildings)
                )\
                .filter(or_(
                    ResidentialComplex.id.in_(complex_ids_int),
                    ResidentialComplex.complex_id.in_(complex_ids_str)
                ))
            
            for complex_data in complexes_query:
                complexes_data[str(complex_data.id)] = complex_data
                if complex_data.complex_id:
                    complexes_data[str(complex_data.complex_id)] = complex_data
        
        favorites_list = []
        for fav in favorites:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ ResidentialComplex —Ç–∞–±–ª–∏—Ü–µ –∏ excel_properties
            real_complex_name = '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'
            real_developer_name = '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_address = '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_district = '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = '–í –ø—Ä–æ–¥–∞–∂–µ'
            real_apartments_count = 0
            real_buildings_count = 1
            real_delivery_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            
                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ SQL —á—Ç–æ –∏ /residential-complexes –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º ID
            try:
                complex_db = None
                print(f"DEBUG: Searching for complex with fav.complex_id: {fav.complex_id}")
                
                if fav.complex_id:
                    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –≤ residential_complexes (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π)
                    try:
                        complex_int_id = int(fav.complex_id)
                        complex_db = ResidentialComplex.query.get(complex_int_id)
                        print(f"DEBUG: Found by id {complex_int_id}: {complex_db.name if complex_db else 'None'}")
                    except (ValueError, TypeError):
                        pass
                
                if complex_db and complex_db.name:
                    # –ù–∞–π–¥–µ–Ω–æ –≤ residential_complexes - –∏—Å–ø–æ–ª—å–∑—É–µ–º —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ
                    real_complex_name = complex_db.name
                    real_developer_name = complex_db.developer.name if complex_db.developer else real_developer_name
                    real_district = complex_db.district.name if complex_db.district else real_district
                    # –ê–¥—Ä–µ—Å –±–µ—Ä–µ–º –∏–∑ sales_address –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º placeholder –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ excel_properties
                    real_address = complex_db.sales_address if hasattr(complex_db, 'sales_address') and complex_db.sales_address else real_address
                    real_image = complex_db.main_image if hasattr(complex_db, 'main_image') and complex_db.main_image else real_image
                    print(f"DEBUG: ‚úÖ Using residential_complexes data: {real_complex_name}")
                else:
                    # ‚úÖ –ù–û–í–û–ï: –ò—â–µ–º –≤ excel_properties –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ—Ç –∂–µ SQL —á—Ç–æ –∏ /residential-complexes
                    print(f"DEBUG: Searching in excel_properties for ID {fav.complex_id}")
                    try:
                        # –í–æ—Å—Å–æ–∑–¥–∞–µ–º —Ç–æ—Ç –∂–µ –∑–∞–ø—Ä–æ—Å —á—Ç–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç ID –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ /residential-complexes
                        excel_complex_query = db.session.execute(text("""
                            SELECT 
                                ep.complex_name,
                                COUNT(*) as apartments_count,
                                MIN(ep.price) as price_from,
                                MAX(ep.price) as price_to,
                                MAX(ep.developer_name) as developer_name,
                                MAX(ep.address_display_name) as address_display_name,
                                MAX(ep.address_locality_display_name) as district_name,
                                COALESCE(rc.id, ROW_NUMBER() OVER (ORDER BY ep.complex_name) + 1000) as real_id,
                                (SELECT photos FROM excel_properties p2 
                                 WHERE p2.complex_name = ep.complex_name 
                                 AND p2.photos IS NOT NULL 
                                 ORDER BY p2.price DESC LIMIT 1) as photos
                            FROM excel_properties ep
                            LEFT JOIN residential_complexes rc ON rc.name = ep.complex_name
                            GROUP BY ep.complex_name, rc.id
                            ORDER BY ep.complex_name
                        """))
                        
                        # –ù–∞—Ö–æ–¥–∏–º –∫–æ–º–ø–ª–µ–∫—Å —Å –Ω—É–∂–Ω—ã–º ID
                        target_id = int(fav.complex_id)
                        for row in excel_complex_query:
                            if int(row.real_id) == target_id:
                                real_complex_name = row.complex_name
                                real_developer_name = row.developer_name or real_developer_name
                                real_address = row.address_display_name or real_address
                                real_district = row.district_name or real_district
                                real_min_price = int(row.price_from) if row.price_from else 0
                                real_max_price = int(row.price_to) if row.price_to else 0
                                real_apartments_count = int(row.apartments_count) if row.apartments_count else 0
                                
                                # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ
                                if row.photos:
                                    try:
                                        import json
                                        photos = json.loads(row.photos) if isinstance(row.photos, str) else row.photos
                                        if photos and isinstance(photos, list) and len(photos) > 0:
                                            real_image = photos[0]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ
                                    except Exception as photo_error:
                                        print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                                
                                print(f"DEBUG: ‚úÖ Found complex in excel_properties: {real_complex_name}")
                                break
                        else:
                            print(f"DEBUG: ‚ùå Complex with ID {fav.complex_id} not found in excel_properties")
                    
                    except Exception as e:
                        print(f"DEBUG: Error searching excel_properties: {e}")
                
                # ‚úÖ –í–´–ù–ï–°–ï–ù–û –ù–ê–†–£–ñ–£: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –¥–∞–Ω–Ω—ã—Ö –≤ excel_properties –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –ñ–ö (–≤—Å–µ–≥–¥–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è)
                if real_complex_name != '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è':
                    from sqlalchemy import text
                    excel_query = text("""
                        SELECT 
                            MIN(price) as min_price,
                            MAX(price) as max_price,
                            COUNT(*) as apartments_count,
                            COUNT(DISTINCT complex_building_name) as buildings_count,
                            MAX(complex_building_end_build_year) as end_build_year,
                            MAX(complex_building_end_build_quarter) as end_build_quarter,
                            (SELECT photos FROM excel_properties ep2 
                             WHERE LOWER(ep2.complex_name) LIKE :complex_pattern
                             AND ep2.photos IS NOT NULL 
                             ORDER BY ep2.price DESC LIMIT 1) as photos,
                            MAX(address_display_name) as address_display_name,
                            MAX(address_locality_display_name) as district_name,
                            MAX(developer_name) as developer_name
                        FROM excel_properties 
                        WHERE LOWER(complex_name) LIKE :complex_pattern
                        LIMIT 1
                    """)
                    
                    clean_name = real_complex_name.strip().lower().replace('–∂–∫ ', '').replace('¬´', '').replace('¬ª', '').replace('"', '')
                    complex_pattern = f"%{clean_name}%"
                    print(f"DEBUG: Searching excel_properties with pattern: {complex_pattern} for complex: {real_complex_name}")
                    result = db.session.execute(excel_query, {'complex_pattern': complex_pattern})
                    row = result.fetchone()
                    
                    print(f"DEBUG: Excel query result - found: {row is not None}, has price: {row[0] if row else 'N/A'}")
                    if row:
                        print(f"DEBUG: Excel data - address: {row[7]}, district: {row[8]}, developer: {row[9]}")
                    
                    if row and row[0]:  # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ
                        real_min_price = int(row[0]) if row[0] else 0
                        real_max_price = int(row[1]) if row[1] else 0
                        real_apartments_count = int(row[2]) if row[2] else 0
                        real_buildings_count = max(int(row[3]) if row[3] else 1, 1)
                        
                        # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ –∏–∑ JSON
                        if row[6]:
                            try:
                                import json
                                photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                                if photos and isinstance(photos, list) and len(photos) > 0:
                                    # –ë–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö, –ø—Ä–æ–ø—É—Å–∫–∞—è –∏–Ω—Ç–µ—Ä—å–µ—Ä—ã –∫–≤–∞—Ä—Ç–∏—Ä
                                    start_index = min(len(photos) // 4, 5) if len(photos) > 8 else 1
                                    real_image = photos[start_index] if len(photos) > start_index else photos[0]
                            except Exception as photo_error:
                                print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                        
                        # –û–±–Ω–æ–≤–ª—è–µ–º –∞–¥—Ä–µ—Å, —Ä–∞–π–æ–Ω –∏ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ –∏–∑ excel_properties –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –±—ã–ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã
                        if row[7] and (not real_address or real_address == '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'):
                            real_address = row[7]
                            print(f"DEBUG: Updated address from Excel: {real_address}")
                        if row[8] and (not real_district or real_district == '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'):
                            real_district = row[8]
                            print(f"DEBUG: Updated district from Excel: {real_district}")
                        if row[9] and (not real_developer_name or real_developer_name == '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'):
                            real_developer_name = row[9]
                            print(f"DEBUG: Updated developer from Excel: {real_developer_name}")
                        
                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ –¥–∞—Ç—É —Å–¥–∞—á–∏
                        if row[4] and row[5]:  # end_build_year –∏ end_build_quarter
                            build_year = int(row[4])
                            build_quarter = int(row[5])
                            quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                            quarter = quarter_names.get(build_quarter, build_quarter)
                            real_delivery_date = f"{quarter} –∫–≤. {build_year} –≥."
                            
                            from datetime import datetime
                            current_year = datetime.now().year
                            real_status = '–°–¥–∞–Ω' if build_year <= current_year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                        elif row[4]:  # —Ç–æ–ª—å–∫–æ –≥–æ–¥
                            build_year = int(row[4])
                            real_delivery_date = f"{build_year} –≥."
                            from datetime import datetime
                            real_status = '–°–¥–∞–Ω' if build_year <= datetime.now().year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                                
            except Exception as e:
                print(f"Error loading complex data for {fav.complex_id}: {e}")
                pass
            
            # –ò—â–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö (ResidentialComplex)
            complex_data = complexes_data.get(str(fav.complex_id))
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–æ—Å–æ–± —Å–æ–∑–¥–∞–Ω–∏—è slug —Å fallback
            try:
                url = f"/zk/{create_slug(real_complex_name)}" if real_complex_name and real_complex_name != '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è' else '#'
            except:
                url = '#'
            
            # ‚úÖ –ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –∏–∑ ResidentialComplex –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            real_cashback_rate = 5.0
            real_housing_class = '–ö–æ–º—Ñ–æ—Ä—Ç'
            if complex_data:
                real_cashback_rate = complex_data.cashback_rate if complex_data.cashback_rate else 5.0
                real_housing_class = complex_data.object_class_display_name if complex_data.object_class_display_name else '–ö–æ–º—Ñ–æ—Ä—Ç'
            
            # ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –¢–û–õ–¨–ö–û –†–ï–ê–õ–¨–ù–´–ï –î–ê–ù–ù–´–ï - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ placeholder
            favorites_list.append({
                'id': str(fav.complex_id),
                'name': real_complex_name,
                'developer': real_developer_name,
                'address': real_address,
                'district': real_housing_class,  # ‚úÖ –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª–∞—Å—Å –∂–∏–ª—å—è –≤–º–µ—Å—Ç–æ —Ä–∞–π–æ–Ω–∞
                'housing_class': real_housing_class,  # ‚úÖ –ö–ª–∞—Å—Å –∂–∏–ª—å—è
                'min_price': real_min_price,
                'max_price': real_max_price,
                'apartments_count': real_apartments_count,
                'buildings_count': real_buildings_count,
                'image': real_image,
                'url': url,
                'status': real_status,
                'delivery_date': real_delivery_date,
                'notes': fav.notes or '',
                'recommended_for': fav.recommended_for or '',
                'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ',
                'cashback_rate': real_cashback_rate  # ‚úÖ –†–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            })
        
        print(f"Found {len(favorites)} favorite complexes for manager {manager_id}")
        if favorites:
            print(f"First complex: {favorites_list[0]}")
        
        return jsonify({
            'success': True,
            'complexes': favorites_list,
            'favorite_complexes': favorites_list,  # –¥–æ–±–∞–≤–∏—Ç—å alias
            'favorites': favorites_list  # –¥–æ–±–∞–≤–∏—Ç—å alias
        })
    
    except Exception as e:
        print(f"Error loading favorite complexes: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# User Management Routes
@app.route('/admin/users')
@admin_required
def admin_users():
    """User management page"""
    try:
        from models import Admin, User
        
        admin_id = session.get('admin_id')
        if not admin_id:
            flash('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', 'error')
            return redirect(url_for('admin_login'))
            
        current_admin = Admin.query.get(admin_id)
        if not current_admin:
            flash('–ê–¥–º–∏–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('admin_login'))
        
        page = request.args.get('page', 1, type=int)
        search = request.args.get('search', '', type=str)
        status = request.args.get('status', '', type=str)
        
        query = User.query
        
        if search:
            query = query.filter(User.email.contains(search) | User.full_name.contains(search))
        
        if status == 'active':
            query = query.filter_by(is_active=True)
        elif status == 'inactive':
            query = query.filter_by(is_active=False)
        elif status == 'verified':
            query = query.filter_by(is_verified=True)
        elif status == 'unverified':
            query = query.filter_by(is_verified=False)
        
        users = query.order_by(User.created_at.desc()).paginate(
            page=page, per_page=20, error_out=False
        )
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–∞—Ç
        from datetime import datetime
        for user in users.items:
            if user.created_at is None:
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ –¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è
                user.created_at = datetime.now()
        
        print(f"DEBUG: Loading admin_users page - Found {users.total} users")
        
        return render_template('admin/users.html', 
                             admin=current_admin, 
                             users=users,
                             search=search,
                             status=status)
                             
    except Exception as e:
        print(f"ERROR in admin_users: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/users/<int:user_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_user(user_id):
    """Edit user details"""
    from models import Admin, User, Manager
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    user = User.query.get_or_404(user_id)
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        user.email = request.form.get('email')
        user.full_name = request.form.get('full_name')
        user.phone = request.form.get('phone')
        user.client_status = request.form.get('client_status')
        user.client_notes = request.form.get('client_notes')
        user.is_active = 'is_active' in request.form
        user.is_verified = 'is_verified' in request.form
        
        assigned_manager_id = request.form.get('assigned_manager_id')
        if assigned_manager_id and assigned_manager_id.isdigit():
            user.assigned_manager_id = int(assigned_manager_id)
        else:
            user.assigned_manager_id = None
        
        try:
            db.session.commit()
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_users'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
    
    return render_template('admin/edit_user.html', 
                         admin=current_admin, 
                         user=user,
                         managers=managers)

@app.route('/admin/users/<int:user_id>/delete', methods=['POST'])
@admin_required
def admin_delete_user(user_id):
    """Delete user"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    
    try:
        db.session.delete(user)
        db.session.commit()
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/reset-password', methods=['POST'])
@admin_required
def admin_reset_user_password(user_id):
    """Admin reset user password - sends reset email"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    
    try:
        # Generate reset token and send email
        token = user.generate_verification_token()
        db.session.commit()
        
        try:
            from email_service import send_password_reset_email
            send_password_reset_email(user, token)
            flash(f'–ü–∏—Å—å–º–æ —Å–±—Ä–æ—Å–∞ –ø–∞—Ä–æ–ª—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ {user.email}', 'success')
        except Exception as e:
            print(f"Error sending password reset email: {e}")
            flash(f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∏—Å—å–º–∞: {str(e)}', 'error')
            
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/toggle-role', methods=['POST'])
@admin_required 
def admin_toggle_user_role(user_id):
    """Admin change user role"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    new_role = request.form.get('role')
    
    # Validate role
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role == '':
        new_role = None
    
    if new_role not in valid_roles:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        old_role = user.role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        user.role = new_role
        db.session.commit()
        
        new_role_display = new_role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        flash(f'–†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.email} –∏–∑–º–µ–Ω–µ–Ω–∞ —Å "{old_role}" –Ω–∞ "{new_role_display}"', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–æ–ª–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-role', methods=['POST'])
@admin_required
def admin_bulk_assign_role():
    """Bulk assign role to users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    new_role = request.form.get('role')
    
    if new_role == '':
        new_role = None
    
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role not in valid_roles:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
        return redirect(url_for('admin_users'))
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        role_display = new_role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        updated_count = 0
        
        for user in users:
            user.role = new_role
            updated_count += 1
        
        db.session.commit()
        flash(f'–†–æ–ª—å "{role_display}" –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –¥–ª—è {updated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ —Ä–æ–ª–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-status', methods=['POST'])
@admin_required
def admin_bulk_toggle_status():
    """Bulk toggle user status"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        activated_count = 0
        deactivated_count = 0
        
        for user in users:
            if user.is_active:
                user.is_active = False
                deactivated_count += 1
            else:
                user.is_active = True
                activated_count += 1
        
        db.session.commit()
        
        if activated_count > 0 and deactivated_count > 0:
            flash(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ: {activated_count}, –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ: {deactivated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        elif activated_count > 0:
            flash(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ {activated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        else:
            flash(f'–î–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ {deactivated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-delete', methods=['POST'])
@admin_required
def admin_bulk_delete_users():
    """Bulk delete users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        deleted_count = len(users)
        
        for user in users:
            db.session.delete(user)
        
        db.session.commit()
        flash(f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º —É–¥–∞–ª–µ–Ω–∏–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/create', methods=['GET', 'POST'])
@admin_required
def admin_create_user():
    """Create new user by admin"""
    from models import Admin, User, Manager
    import re
    import secrets
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        try:
            # Validate required fields
            full_name = request.form.get('full_name', '').strip()
            email = request.form.get('email', '').strip().lower()
            phone = request.form.get('phone', '').strip()
            
            if not all([full_name, email, phone]):
                flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Validate email format
            if not re.match(r'^[^\s@]+@[^\s@]+\.[^\s@]+$', email):
                flash('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Check if user already exists
            existing_user = User.query.filter(
                (User.email == email) | (User.phone == phone)
            ).first()
            
            if existing_user:
                flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Clean phone number
            phone_clean = re.sub(r'[^\d]', '', phone)
            if len(phone_clean) == 11 and phone_clean.startswith('8'):
                phone_clean = '7' + phone_clean[1:]
            elif len(phone_clean) == 10:
                phone_clean = '7' + phone_clean
            
            if len(phone_clean) != 11 or not phone_clean.startswith('7'):
                flash('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Generate temporary password
            temp_password = secrets.token_urlsafe(12)
            
            # Create user
            user = User(
                email=email,
                full_name=full_name,
                phone=phone_clean,
                client_status=request.form.get('client_status', '–ù–æ–≤—ã–π'),
                client_notes=request.form.get('client_notes', ''),
                is_active='is_active' in request.form,
                is_verified='is_verified' in request.form,
                temp_password_hash=temp_password,  # Store temp password for sending
                created_by_admin=True
            )
            
            # Set assigned manager
            assigned_manager_id = request.form.get('assigned_manager_id')
            if assigned_manager_id and assigned_manager_id.isdigit():
                user.assigned_manager_id = int(assigned_manager_id)
            
            # Set temporary password
            user.set_password(temp_password)
            
            db.session.add(user)
            db.session.commit()
            
            print(f"DEBUG: Successfully created user {user.id}: {user.full_name} by admin")
            
            # Send credentials if requested
            if 'send_credentials' in request.form:
                try:
                    from email_service import send_email_smtp
                    from sms_service import send_sms
                    
                    # Prepare email content
                    subject = "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω –≤ InBack.ru - –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞"
                    email_content = f"""–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {full_name}!

–î–ª—è –≤–∞—Å —Å–æ–∑–¥–∞–Ω –∞–∫–∫–∞—É–Ω—Ç –≤ —Å–∏—Å—Ç–µ–º–µ InBack.ru.

–î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞:
‚Ä¢ Email: {email}
‚Ä¢ –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å: {temp_password}

–í–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É –ø–æ –∞–¥—Ä–µ—Å—É: https://inback.ru/login
–ü—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—Ö–æ–¥–µ –≤–∞–º –±—É–¥–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru"""
                    
                    # Send email using HTML template
                    send_email_smtp(
                        to_email=email,
                        subject=subject,
                        template_name='emails/user_credentials.html',
                        user_name=full_name,
                        email=email,
                        temp_password=temp_password,
                        login_url='https://inback.ru/login'
                    )
                    
                    # Send SMS
                    sms_message = f"InBack.ru: –í–∞—à –∞–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω. –õ–æ–≥–∏–Ω: {email}, –ü–∞—Ä–æ–ª—å: {temp_password}. –í–æ–π—Ç–∏: https://inback.ru/login"
                    send_sms(phone_clean, sms_message)
                    
                    flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {full_name} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω. –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ email –∏ SMS.', 'success')
                    
                except Exception as e:
                    print(f"Error sending credentials: {str(e)}")
                    flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞: {str(e)}', 'warning')
            else:
                flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {full_name} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω.', 'success')
            
            return redirect(url_for('admin_users'))
            
        except Exception as e:
            db.session.rollback()
            print(f"Error creating user: {str(e)}")
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
            return render_template('admin/create_user.html', 
                                 admin=current_admin, 
                                 managers=managers)
    
    return render_template('admin/create_user.html', 
                         admin=current_admin, 
                         managers=managers)

@app.route('/admin/users/<int:user_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_user_status(user_id):
    """Toggle user active status"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    user.is_active = not user.is_active
    
    try:
        db.session.commit()
        status = '–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω' if user.is_active else '–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω'
        flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {status}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/verify', methods=['POST'])
@admin_required
def admin_verify_user(user_id):
    """Verify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω
        if user.is_verified:
            flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.full_name} —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('admin_users'))
        
        # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user.is_verified = True
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∞–¥–º–∏–Ω–∞
        admin_id = session.get('admin_id')
        current_admin = Admin.query.get(admin_id)
        admin_name = current_admin.full_name if current_admin else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–¥–º–∏–Ω'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {admin_id}) verified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'–ê–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'success')
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ AJAX –∑–∞–ø—Ä–æ—Å–æ–≤
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'–ê–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω',
                'user_id': user.id,
                'verified': True
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}'
        print(f"Error verifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/unverify', methods=['POST'])
@admin_required 
def admin_unverify_user(user_id):
    """Unverify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω
        if not user.is_verified:
            flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.full_name} —É–∂–µ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('admin_users'))
        
        # –û—Ç–º–µ–Ω—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        user.is_verified = False
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∞–¥–º–∏–Ω–∞
        admin_id = session.get('admin_id')
        current_admin = Admin.query.get(admin_id)
        admin_name = current_admin.full_name if current_admin else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–¥–º–∏–Ω'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {admin_id}) unverified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} –æ—Ç–º–µ–Ω–µ–Ω–æ', 'warning')
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ AJAX –∑–∞–ø—Ä–æ—Å–æ–≤
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ {user.full_name} –æ—Ç–º–µ–Ω–µ–Ω–æ',
                'user_id': user.id,
                'verified': False
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {str(e)}'
        print(f"Error unverifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))

# Manager Management Routes
@app.route('/admin/managers')
@admin_required
def admin_managers():
    """Manager management page"""
    from models import Admin, Manager
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    
    query = Manager.query
    
    if search:
        query = query.filter(Manager.email.contains(search) | Manager.first_name.contains(search) | Manager.last_name.contains(search))
    
    if status == 'active':
        query = query.filter_by(is_active=True)
    elif status == 'inactive':
        query = query.filter_by(is_active=False)
    
    managers = query.order_by(Manager.created_at.desc()).paginate(
        page=page, per_page=20, error_out=False
    )
    
    return render_template('admin/managers.html', 
                         admin=current_admin, 
                         managers=managers,
                         search=search,
                         status=status)

@app.route('/admin/managers/<int:manager_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_manager(manager_id):
    """Edit manager details"""
    from models import Admin, Manager
    
    try:
        admin_id = session.get('admin_id')
        current_admin = Admin.query.get(admin_id)
        manager = Manager.query.get(manager_id)
        
        if not manager:
            flash(f'–ú–µ–Ω–µ–¥–∂–µ—Ä —Å ID {manager_id} –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('admin_managers'))
            
        print(f"DEBUG: Found manager {manager_id}: {manager.email}")
    except Exception as e:
        print(f"ERROR in admin_edit_manager: {e}")
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
        return redirect(url_for('admin_managers'))
    
    if request.method == 'POST':
        manager.email = request.form.get('email')
        manager.first_name = request.form.get('first_name')
        manager.last_name = request.form.get('last_name')
        manager.phone = request.form.get('phone')
        manager.position = request.form.get('position')
        manager.is_active = 'is_active' in request.form
        
        new_password = request.form.get('new_password')
        if new_password:
            manager.set_password(new_password)
        
        try:
            db.session.commit()
            flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    from datetime import datetime
    
    return render_template('admin/edit_manager.html', 
                         admin=current_admin, 
                         manager=manager,
                         current_date=datetime.utcnow())



# Blog Management Routes
@app.route('/admin/blog')
@admin_required
def admin_blog():
    """Blog management page"""
    from models import Admin, BlogPost
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    category_id = request.args.get('category_id', '', type=str)
    
    query = BlogPost.query
    
    if search:
        query = query.filter(BlogPost.title.contains(search) | BlogPost.content.contains(search))
    
    if status:
        query = query.filter_by(status=status)
    
    if category_id:
        query = query.filter_by(category_id=int(category_id))
    
    posts = query.order_by(BlogPost.created_at.desc()).paginate(
        page=page, per_page=10, error_out=False
    )
    
    # Get categories for filter from Category table
    from models import Category
    categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
    
    return render_template('admin/blog.html', 
                         admin=current_admin, 
                         posts=posts,
                         search=search,
                         status=status,
                         category_id=category_id,
                         categories=categories)

@app.route('/admin/blog/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º CSRF –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
def admin_create_post():
    """Create new blog post with full TinyMCE integration"""
    from models import Admin, BlogPost, Category
    from datetime import datetime
    import re
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    if request.method == 'GET':
        # Load categories for the form
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/create_article.html', admin=current_admin, categories=categories)
    
    if request.method == 'POST':
        try:
            title = request.form.get('title')
            content = request.form.get('content')
            excerpt = request.form.get('excerpt')
            category_id = request.form.get('category_id')
            
            # Handle featured image upload
            featured_image_url = request.form.get('featured_image', '')
            uploaded_file = request.files.get('featured_image_file')
            
            if uploaded_file and uploaded_file.filename:
                # Secure filename and save
                from werkzeug.utils import secure_filename
                import os
                filename = secure_filename(uploaded_file.filename)
                
                # Create upload directory if it doesn't exist
                upload_dir = 'static/uploads/blog'
                os.makedirs(upload_dir, exist_ok=True)
                
                # Save file with unique name
                import uuid
                unique_filename = f"{uuid.uuid4()}_{filename}"
                file_path = os.path.join(upload_dir, unique_filename)
                uploaded_file.save(file_path)
                
                # Set the URL for the database
                featured_image_url = f"/{file_path}"
            
            if not title or not content or not category_id:
                flash('–ó–∞–≥–æ–ª–æ–≤–æ–∫, —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Get category name from category_id
            category = Category.query.get(int(category_id))
            if not category:
                flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Generate slug from title
            slug = request.form.get('slug', '')
            if not slug:
                # Auto-generate slug from title
                def transliterate(text):
                    rus_to_eng = {
                        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z',
                        '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r',
                        '—Å': 's', '—Ç': 't', '—É': 'u', '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
                    }
                    return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
                
                slug = transliterate(title.lower())
                slug = re.sub(r'[^\w\s-]', '', slug)
                slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post = BlogPost(
                title=title,
                slug=slug,
                content=content,
                excerpt=excerpt,
                meta_title=request.form.get('meta_title'),
                meta_description=request.form.get('meta_description'),
                meta_keywords=request.form.get('meta_keywords'),
                category_id=category.id,  # Store category ID for proper relation
                category=category.name,  # Store category name for compatibility
                tags=request.form.get('tags'),
                featured_image=featured_image_url,
                status=request.form.get('status', 'draft'),
                author_id=current_admin.id,
                created_at=datetime.utcnow()
            )
            
            if post.status == 'published':
                post.published_at = datetime.utcnow()
            
            db.session.add(post)
            db.session.commit()
            
            # Update category article count
            if post.status == 'published':
                category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
                db.session.commit()
            
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
            return redirect(url_for('admin_blog'))
            
        except Exception as e:
            db.session.rollback()
            print(f'ERROR creating blog post: {str(e)}')
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
            categories = Category.query.order_by(Category.name).all()
            return render_template('admin/create_article.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_post(post_id):
    """Edit blog post"""
    from models import Admin, BlogPost, Category
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        flash('–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞', 'error')
        return redirect(url_for('admin_login'))
    
    try:
        post = BlogPost.query.get_or_404(post_id)
    except Exception as e:
        flash(f'–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {str(e)}', 'error')
        return redirect(url_for('admin_blog'))
    
    if request.method == 'POST':
        post.title = request.form.get('title')
        post.content = request.form.get('content')
        post.excerpt = request.form.get('excerpt')
        post.meta_title = request.form.get('meta_title')
        post.meta_description = request.form.get('meta_description')
        post.meta_keywords = request.form.get('meta_keywords')
        post.category = request.form.get('category')
        post.tags = request.form.get('tags')
        post.featured_image = request.form.get('featured_image')
        
        old_status = post.status
        post.status = request.form.get('status', 'draft')
        
        # Handle publishing
        if post.status == 'published' and old_status != 'published':
            post.published_at = datetime.utcnow()
        elif post.status != 'published':
            post.published_at = None
        
        try:
            db.session.commit()
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    # Get categories for dropdown
    try:
        categories = Category.query.order_by(Category.name).all()
    except Exception as e:
        print(f'Error loading categories: {e}')
        categories = []
    
    return render_template('admin/blog_post_create.html', 
                         admin=current_admin, 
                         post=post, 
                         categories=categories)

@app.route('/admin/blog/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_post(post_id):
    """Delete blog post"""
    from models import BlogPost
    
    post = BlogPost.query.get_or_404(post_id)
    
    try:
        db.session.delete(post)
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))

# Analytics Routes
@app.route('/admin/analytics/cashback')
@admin_required
def admin_cashback_analytics():
    """Cashback analytics page"""
    from models import Admin, CashbackApplication
    from sqlalchemy import func
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    # Monthly cashback stats
    monthly_stats = db.session.query(
        func.date_trunc('month', CashbackApplication.created_at).label('month'),
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(func.date_trunc('month', CashbackApplication.created_at)).order_by('month').all()
    
    # Status breakdown
    status_stats = db.session.query(
        CashbackApplication.status,
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(CashbackApplication.status).all()
    
    # Recent large cashbacks
    large_cashbacks = CashbackApplication.query.filter(
        CashbackApplication.cashback_amount >= 100000
    ).order_by(CashbackApplication.created_at.desc()).limit(10).all()
    
    return render_template('admin/cashback_analytics.html',
                         admin=current_admin,
                         monthly_stats=monthly_stats,
                         status_stats=status_stats,
                         large_cashbacks=large_cashbacks)

# Admin Blog Management Routes

@app.route('/admin/blog/<int:article_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_article(article_id):
    """Edit blog article"""
    from models import Admin, BlogPost
    import re
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    article = BlogPost.query.get_or_404(article_id)
    
    if request.method == 'POST':
        article.title = request.form.get('title')
        article.slug = request.form.get('slug')
        article.content = request.form.get('content')
        article.excerpt = request.form.get('excerpt')
        article.category = request.form.get('category')
        article.tags = request.form.get('tags')
        article.featured_image = request.form.get('featured_image')
        article.meta_title = request.form.get('meta_title')
        article.meta_description = request.form.get('meta_description')
        article.meta_keywords = request.form.get('meta_keywords')
        action = request.form.get('action', 'save')
        
        # Auto-generate slug if empty
        if not article.slug:
            slug = re.sub(r'[^\w\s-]', '', article.title.lower())
            slug = re.sub(r'[\s_-]+', '-', slug)
            article.slug = slug.strip('-')
        
        # Set status based on action
        if action == 'publish':
            article.status = 'published'
            if not article.published_at:
                article.published_at = datetime.now()
        else:
            article.status = request.form.get('status', 'draft')
        
        # Handle scheduled posts
        if article.status == 'scheduled':
            scheduled_str = request.form.get('scheduled_for')
            if scheduled_str:
                try:
                    article.scheduled_for = datetime.fromisoformat(scheduled_str)
                except:
                    pass
        else:
            article.scheduled_for = None
            
        article.updated_at = datetime.now()
        
        try:
            db.session.commit()
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return render_template('admin/create_article.html', admin=current_admin, article=article)

@app.route('/admin/blog/<int:article_id>/delete', methods=['POST'])
@admin_required
def admin_delete_article(article_id):
    """Delete blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    
    try:
        db.session.delete(article)
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))

@app.route('/admin/blog/<int:article_id>/publish', methods=['POST'])
@admin_required
def admin_publish_article(article_id):
    """Publish blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    article.status = 'published'
    article.published_at = datetime.now()
    article.updated_at = datetime.now()
    
    try:
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))

# Admin Complex Cashback Management Routes
@app.route('/admin/complexes/cashback')
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def admin_complex_cashback():
    """Complex cashback management page"""
    from models import Admin, ResidentialComplex
    from flask import request
    from sqlalchemy import and_, or_
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ñ–ö –∏–∑ excel_properties
    try:
        # –ù–∞—Ö–æ–¥–∏–º –ñ–ö, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ excel_properties, –Ω–æ –Ω–µ—Ç –≤ residential_complexes
        new_complexes_query = db.session.execute(text("""
            INSERT INTO residential_complexes (name, slug, cashback_rate, is_active, created_at)
            SELECT 
                DISTINCT ep.complex_name,
                LOWER(REPLACE(REPLACE(REPLACE(REPLACE(ep.complex_name, ' ', '-'), '¬´', ''), '¬ª', ''), '"', '')) as slug,
                5.0 as cashback_rate,  -- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞ 5%
                true as is_active,
                NOW() as created_at
            FROM excel_properties ep
            WHERE ep.complex_name IS NOT NULL 
              AND ep.complex_name != ''
              AND ep.complex_name NOT IN (SELECT name FROM residential_complexes)
            ON CONFLICT (name) DO NOTHING
        """))
        db.session.commit()
    except Exception as e:
        print(f"Auto-sync error (non-critical): {e}")
        db.session.rollback()
    
    # Get filter parameters
    search = request.args.get('search', '')
    district = request.args.get('district', '')
    status = request.args.get('status', '')
    page = int(request.args.get('page', 1))
    per_page = 20
    
    # Build query
    query = ResidentialComplex.query
    
    # Apply filters
    if search:
        query = query.filter(or_(
            ResidentialComplex.name.contains(search),
            ResidentialComplex.developer.has(name=search)
        ))
    
    if district:
        query = query.filter(ResidentialComplex.district.has(name=district))
    
    if status == 'active':
        query = query.filter(ResidentialComplex.is_active == True)
    elif status == 'inactive':
        query = query.filter(ResidentialComplex.is_active == False)
    
    # Paginate results
    complexes = query.order_by(ResidentialComplex.name).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/complex_cashback.html',
                         admin=current_admin,
                         complexes=complexes,
                         search=search,
                         district=district,
                         status=status)

@app.route('/admin/complex-cashback/<int:complex_id>/update-cashback', methods=['POST'])
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def update_complex_cashback(complex_id):
    """API endpoint to update complex cashback rate"""
    from models import ResidentialComplex
    
    try:
        complex = ResidentialComplex.query.get_or_404(complex_id)
        
        data = request.get_json()
        cashback_percent = data.get('cashback_percent')
        
        if cashback_percent is None:
            return jsonify({'success': False, 'message': '–ù–µ —É–∫–∞–∑–∞–Ω –ø—Ä–æ—Ü–µ–Ω—Ç –∫–µ—à–±–µ–∫–∞'})
        
        # Validate percentage
        try:
            cashback_percent = float(cashback_percent)
            if cashback_percent < 0 or cashback_percent > 15:
                return jsonify({'success': False, 'message': '–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0% –¥–æ 15%'})
        except (ValueError, TypeError):
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞'})
        
        # Update cashback rate
        complex.cashback_rate = cashback_percent
        complex.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': '–ö–µ—à–±–µ–∫ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω',
            'cashback_percent': cashback_percent,
            'complex_name': complex.name
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating complex cashback: {e}")
        return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'})

@app.route('/admin/complexes/cashback/create', methods=['GET', 'POST'])
@admin_required
def admin_create_complex_cashback():
    """Create new complex cashback settings"""
    from models import Admin, ResidentialComplex, District, Developer
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    if request.method == 'POST':
        name = request.form.get('name')
        developer_id = request.form.get('developer_id')
        district_id = request.form.get('district_id') 
        cashback_rate = request.form.get('cashback_rate', 5.0)
        
        try:
            # Create new complex
            complex = ResidentialComplex(
                name=name,
                slug=name.lower().replace(' ', '-'),
                developer_id=int(developer_id) if developer_id else None,
                district_id=int(district_id) if district_id else None,
                cashback_rate=float(cashback_rate),
                is_active=True,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            db.session.add(complex)
            db.session.commit()
            
            flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω', 'success')
            return redirect(url_for('admin_complex_cashback'))
            
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ñ–ö', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/create_complex_cashback.html',
                         admin=current_admin,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_complex_cashback(complex_id):
    """Edit complex cashback settings"""
    from models import Admin, ResidentialComplex, District, Developer
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    if request.method == 'POST':
        complex.name = request.form.get('name')
        complex.developer_id = int(request.form.get('developer_id')) if request.form.get('developer_id') else None
        complex.district_id = int(request.form.get('district_id')) if request.form.get('district_id') else None
        complex.cashback_rate = float(request.form.get('cashback_rate', 5.0))
        complex.is_active = bool(request.form.get('is_active'))
        complex.updated_at = datetime.utcnow()
        
        try:
            db.session.commit()
            flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_complex_cashback'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ñ–ö', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/edit_complex_cashback.html',
                         admin=current_admin,
                         complex=complex,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/delete', methods=['POST'])
@admin_required
def admin_delete_complex_cashback(complex_id):
    """Delete complex cashback settings"""
    from models import ResidentialComplex
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        db.session.delete(complex)
        db.session.commit()
        flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ñ–ö', 'error')
    
    return redirect(url_for('admin_complex_cashback'))

# Admin Manager Management Routes  
@app.route('/admin/managers/create', methods=['GET', 'POST'])
@admin_required
def admin_create_manager():
    """Create new manager"""
    from models import Admin, Manager
    from werkzeug.security import generate_password_hash
    import json
    import random
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if request.method == 'POST':
        full_name = request.form.get('full_name', '')
        email = request.form.get('email')
        phone = request.form.get('phone')
        position = request.form.get('position', '–ú–µ–Ω–µ–¥–∂–µ—Ä')
        profile_image = request.form.get('profile_image')
        password = request.form.get('password', 'demo123')  # Default password
        password_confirm = request.form.get('password_confirm', 'demo123')
        is_active = request.form.get('is_active') != 'False'  # Default True
        
        # Split full name into first and last name
        name_parts = full_name.split(' ', 1)
        first_name = name_parts[0] if name_parts else '–ò–º—è'
        last_name = name_parts[1] if len(name_parts) > 1 else '–§–∞–º–∏–ª–∏—è'
        
        # Validate passwords
        if password != password_confirm:
            flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            return render_template('admin/create_manager.html', admin=current_admin)
        
        if not password:
            password = 'demo123'  # Default password
        
        # Check if email already exists
        if email:
            existing_manager = Manager.query.filter_by(email=email).first()
            if existing_manager:
                flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
                return render_template('admin/create_manager.html', admin=current_admin)
        
        # Create manager
        manager = Manager()
        manager.email = email or f'manager{random.randint(1000,9999)}@inback.ru'
        manager.first_name = first_name
        manager.last_name = last_name
        manager.phone = phone
        manager.position = position
        manager.profile_image = profile_image or 'https://randomuser.me/api/portraits/men/1.jpg'
        manager.set_password(password)
        manager.is_active = is_active
        
        try:
            db.session.add(manager)
            db.session.commit()
            flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    return render_template('admin/create_manager.html', admin=current_admin)

@app.route('/admin/managers/<int:manager_id>/delete', methods=['POST'])
@admin_required
def admin_delete_manager(manager_id):
    """Delete manager"""
    from models import Manager
    
    manager = Manager.query.get_or_404(manager_id)
    
    try:
        db.session.delete(manager)
        db.session.commit()
        flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    return redirect(url_for('admin_managers'))

@app.route('/admin/managers/<int:manager_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_manager_status(manager_id):
    """Toggle manager active status"""
    from models import Manager
    
    manager = Manager.query.get_or_404(manager_id)
    manager.is_active = not manager.is_active
    
    try:
        db.session.commit()
        status = '–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω' if manager.is_active else '–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω'
        flash(f'–ú–µ–Ω–µ–¥–∂–µ—Ä {status}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    return redirect(url_for('admin_managers'))

# Additional Pages Routes
@app.route('/careers')
def careers():
    """Careers page with dynamic data"""
    from models import Job, JobCategory, Admin
    
    try:
        # Check if current user is admin
        is_admin = False
        current_admin = None
        if 'admin_id' in session:
            admin_id = session.get('admin_id')
            current_admin = Admin.query.get(admin_id)
            is_admin = current_admin is not None
        
        # Get all active job categories
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Get all active jobs with their categories (excluding paused jobs)
        jobs = Job.query.filter(Job.is_active == True, Job.status == 'active').order_by(Job.is_featured.desc(), Job.created_at.desc()).all()
        
        return render_template('careers.html', 
                             categories=categories, 
                             jobs=jobs,
                             is_admin=is_admin,
                             admin=current_admin)
        
    except Exception as e:
        print(f"Error loading careers page: {e}")
        # Fallback to static page if database fails
        return render_template('careers.html', 
                             categories=[], 
                             jobs=[],
                             is_admin=False,
                             admin=None)

@app.route('/security')
def security():
    """Security page"""
    return render_template('security.html')


if __name__ == '__main__':
    with app.app_context():
        from models import User, Manager, SavedSearch, SentSearch, CashbackRecord, Application, Favorite, Notification, District, Developer, ResidentialComplex, Street, RoomType, Admin, BlogPost, City
        db.create_all()
        
        # Initialize cities
        try:
            init_cities()
            print("Cities initialized successfully")
        except Exception as e:
            print(f"Error initializing cities: {e}")
            db.session.rollback()
        
        # Initialize search data
        try:
            init_search_data()
            print("Search data initialized successfully")
        except Exception as e:
            print(f"Error initializing search data: {e}")
            db.session.rollback()

# Collection routes for clients
@app.route('/collections')
@login_required
def client_collections():
    """Show all collections assigned to current user"""
    from models import Collection
    collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
    return render_template('auth/client_collections.html', collections=collections)

@app.route('/collection/<int:collection_id>')
@login_required
def view_collection(collection_id):
    """View specific collection details"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if not collection:
        flash('–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('client_collections'))
    
    # Mark as viewed
    if collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
        collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    
    return render_template('auth/view_collection.html', collection=collection)

@app.route('/collection/<int:collection_id>/mark-viewed', methods=['POST'])
@login_required
def mark_collection_viewed(collection_id):
    """Mark collection as viewed"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if collection and collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
        collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    return jsonify({'success': True})

# Manager collection routes
@app.route('/manager/collections')
@manager_required
def manager_collections():
    """Manager collections list"""
    from models import Collection, Manager
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    collections = Collection.query.filter_by(created_by_manager_id=manager_id).order_by(Collection.created_at.desc()).all()
    return render_template('manager/collections.html', collections=collections, manager=manager)

@app.route('/manager/collections/new')
@manager_required
def manager_create_collection():
    """Create new collection"""
    from models import Manager, User
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    # Get all clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=manager_id).all()
    return render_template('manager/create_collection.html', manager=manager, clients=clients)

@app.route('/manager/collections/new', methods=['POST'])
@manager_required
def save_collection():
    """Save new collection"""
    from models import Collection, CollectionProperty, Manager
    
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    title = request.form.get('title')
    description = request.form.get('description', '')
    assigned_to_user_id = request.form.get('assigned_to_user_id')
    tags = request.form.get('tags', '')
    action = request.form.get('action')
    property_ids = request.form.getlist('property_ids[]')
    property_notes = request.form.getlist('property_notes[]')
    
    if not title or not assigned_to_user_id:
        flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
        return render_template('manager/create_collection.html', manager=manager)
    
    try:
        # Create collection
        collection = Collection(
            title=title,
            description=description,
            created_by_manager_id=manager_id,
            assigned_to_user_id=int(assigned_to_user_id),
            tags=tags,
            status='–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞' if action == 'send' else '–ß–µ—Ä–Ω–æ–≤–∏–∫',
            sent_at=datetime.utcnow() if action == 'send' else None
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        import json
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        properties_dict = {prop['id']: prop for prop in properties_data}
        
        for i, prop_id in enumerate(property_ids):
            if prop_id in properties_dict:
                prop_data = properties_dict[prop_id]
                note = property_notes[i] if i < len(property_notes) else ''
                
                collection_property = CollectionProperty(
                    collection_id=collection.id,
                    property_id=prop_id,
                    property_name=prop_data['title'],
                    property_price=prop_data['price'],
                    complex_name=prop_data.get('residential_complex', ''),
                    property_type=f"{prop_data['rooms']}-–∫–æ–º–Ω",
                    property_size=prop_data.get('area'),
                    manager_note=note,
                    order_index=i
                )
                db.session.add(collection_property)
        
        db.session.commit()
        
        action_text = '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç—É' if action == 'send' else '—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–∞–∫ —á–µ—Ä–Ω–æ–≤–∏–∫'
        flash(f'–ü–æ–¥–±–æ—Ä–∫–∞ "{title}" —É—Å–ø–µ—à–Ω–æ {action_text}', 'success')
        return redirect(url_for('manager_collections'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–æ–¥–±–æ—Ä–∫–∏: {str(e)}', 'error')
        return render_template('manager/create_collection.html', manager=manager)

@app.route('/manager/analytics')
@manager_required
def manager_analytics():
    """Manager analytics page"""
    from models import Manager, User, Collection, CashbackApplication
    from sqlalchemy import func
    
    manager_id = session.get('manager_id')
    current_manager = Manager.query.get(manager_id)
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    # Manager stats
    clients_count = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    collections_count = Collection.query.filter_by(created_by_manager_id=current_manager.id).count()
    sent_collections = Collection.query.filter_by(created_by_manager_id=current_manager.id, status='–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞').count()
    
    # Monthly collection stats
    monthly_collections = db.session.query(
        func.date_trunc('month', Collection.created_at).label('month'),
        func.count(Collection.id).label('count')
    ).filter_by(created_by_manager_id=current_manager.id).group_by(
        func.date_trunc('month', Collection.created_at)
    ).order_by('month').all()
    
    # Client activity stats
    client_stats = db.session.query(
        User.client_status,
        func.count(User.id).label('count')
    ).filter_by(assigned_manager_id=current_manager.id).group_by(User.client_status).all()
    
    # Recent activity
    recent_collections = Collection.query.filter_by(
        created_by_manager_id=current_manager.id
    ).order_by(Collection.created_at.desc()).limit(5).all()
    
    return render_template('manager/analytics.html',
                         manager=current_manager,
                         clients_count=clients_count,
                         collections_count=collections_count,
                         sent_collections=sent_collections,
                         monthly_collections=monthly_collections,
                         client_stats=client_stats,
                         recent_collections=recent_collections)

@app.route('/manager/search-properties', methods=['POST'])
@manager_required
def manager_search_properties():
    """Search properties for collection"""
    import json
    
    data = request.get_json()
    min_price = data.get('min_price')
    max_price = data.get('max_price')
    rooms = data.get('rooms')
    
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        filtered_properties = []
        for prop in properties_data:
            # Apply filters
            if min_price and prop['price'] < int(min_price):
                continue
            if max_price and prop['price'] > int(max_price):
                continue
            if rooms and str(prop['rooms']) != str(rooms):
                continue
                
            filtered_properties.append({
                'id': prop['id'],
                'title': f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤",
                'price': prop['price'],
                'complex_name': prop.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'),
                'rooms': prop['rooms'],
                'size': prop.get('area', 0)
            })
        
        return jsonify({'properties': filtered_properties[:50]})
    except Exception as e:
        return jsonify({'error': str(e)}), 400

# Additional API routes for collection management
@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def api_send_collection(collection_id):
    """Send collection to client"""
    from models import Collection
    
    manager_id = session.get('manager_id')
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=manager_id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
    
    try:
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/delete', methods=['DELETE'])
@manager_required 
def api_delete_collection(collection_id):
    """Delete collection"""
    from models import Collection
    
    manager_id = session.get('manager_id')
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=manager_id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Manager Saved Searches API routes
@app.route('/api/manager/saved-searches')
@manager_required
def get_manager_saved_searches():
    """Get manager's saved searches"""
    from models import ManagerSavedSearch
    
    manager_id = session.get('manager_id')
    try:
        searches = ManagerSavedSearch.query.filter_by(manager_id=manager_id).order_by(ManagerSavedSearch.last_used.desc()).all()
        searches_list = [search.to_dict() for search in searches]
        
        return jsonify({
            'success': True,
            'searches': searches_list,
            'count': len(searches_list)
        })
    except Exception as e:
        print(f"Error loading manager saved searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-searches', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def create_manager_saved_search():
    """Create a new saved search for manager"""
    from models import ManagerSavedSearch
    import json
    
    print(f"DEBUG: ===== create_manager_saved_search API CALLED =====")
    print(f"DEBUG: Method: {request.method}")
    print(f"DEBUG: Path: {request.path}")
    # Log safe headers only (no cookies/tokens)
    safe_headers = {k: v for k, v in request.headers.items() if k.lower() not in ['cookie', 'authorization']}
    print(f"DEBUG: Headers: {safe_headers}")
    
    manager_id = session.get('manager_id')
    print(f"DEBUG: Manager ID from session: {manager_id}")
    
    data = request.get_json()
    print(f"DEBUG: Raw request JSON: {data}")
    print(f"DEBUG: JSON type: {type(data)}")
    
    try:
        # Extract filters from the request
        filters = data.get('filters', {})
        print(f"DEBUG: Creating manager search with filters: {filters}")
        print(f"DEBUG: Full request data: {data}")
        print(f"DEBUG: Filters type: {type(filters)}")
        print(f"DEBUG: Filters empty check: {bool(filters)}")
        
        # Test if filters is actually empty - force some test data if needed
        if not filters or not any(filters.values()):
            print("DEBUG: Filters are empty, checking raw JSON...")
            raw_json = request.get_data(as_text=True)
            print(f"DEBUG: Raw request body: {raw_json}")
        
        filters_json = json.dumps(filters) if filters else None
        print(f"DEBUG: Filters JSON: {filters_json}")
        
        # Create new search
        search = ManagerSavedSearch(
            manager_id=manager_id,
            name=data.get('name'),
            description=data.get('description'),
            search_type=data.get('search_type', 'properties'),
            additional_filters=filters_json,
            is_template=data.get('is_template', False)
        )
        
        db.session.add(search)
        db.session.commit()
        print(f"DEBUG: Saved search with ID: {search.id}, additional_filters: {search.additional_filters}")
        
        # Verify the saved data
        db.session.refresh(search)
        print(f"DEBUG: Refreshed search additional_filters: {search.additional_filters}")
        
        return jsonify({
            'success': True,
            'search': search.to_dict(),
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error creating manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-search', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def send_search_to_client():
    """Send manager's saved search to a client"""
    from models import ManagerSavedSearch, SentSearch, User, SavedSearch, UserNotification
    from email_service import send_notification
    import json
    
    manager_id = session.get('manager_id')
    data = request.get_json()
    
    try:
        search_id = data.get('search_id')
        client_id = data.get('client_id')
        message = data.get('message', '')
        
        # Get manager search
        manager_search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=manager_id).first()
        if not manager_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        # Get client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        # Create SavedSearch for client (copy manager search to client)
        client_search = SavedSearch(
            user_id=client_id,
            name=f"–û—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}",
            description=f"{manager_search.description or ''}\n\n{message}".strip(),
            search_type=manager_search.search_type,
            additional_filters=manager_search.additional_filters,
            notify_new_matches=True
        )
        
        db.session.add(client_search)
        db.session.flush()  # Get the ID before final commit
        
        # Create sent search record
        sent_search = SentSearch(
            manager_id=manager_id,
            client_id=client_id,
            manager_search_id=search_id,
            name=manager_search.name,
            description=manager_search.description,
            additional_filters=manager_search.additional_filters,
            status='sent'
        )
        
        db.session.add(sent_search)
        db.session.flush()  # Get sent_search ID
        
        # Note: client_search is now created and linked via sent_search record
        
        # Update usage count
        manager_search.usage_count = (manager_search.usage_count or 0) + 1
        manager_search.last_used = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=client_id,
            title="–ù–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞",
            message=f"–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –ø–æ–∏—Å–∫: {manager_search.name}",
            notification_type='info',
            icon='fas fa-search',
            action_url='/dashboard'
        )
        
        db.session.add(notification)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –ø–æ–∏—Å–∫–∞
        from models import UserActivity
        UserActivity.log_activity(
            user_id=client_id,
            activity_type='search_received',
            description=f'–ü–æ–ª—É—á–µ–Ω –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}'
        )
        
        db.session.commit()
        
        # Send email notification
        try:
            send_notification(
                client.email,
                f"–ù–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}",
                f"–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏.\n\n"
                f"–ù–∞–∑–≤–∞–Ω–∏–µ: {manager_search.name}\n"
                f"–û–ø–∏—Å–∞–Ω–∏–µ: {manager_search.description or '–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è'}\n\n"
                f"{message}\n\n"
                f"–í–æ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞: https://{request.host}/dashboard",
                user_id=client_id,
                notification_type='search_received'
            )
        except Exception as e:
            print(f"Error sending email notification: {e}")
        
        return jsonify({
            'success': True,
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending search to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-search/<int:search_id>', methods=['DELETE'])
@manager_required
def delete_manager_saved_search(search_id):
    """Delete manager's saved search"""
    from models import ManagerSavedSearch
    
    manager_id = session.get('manager_id')
    
    try:
        search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=manager_id).first()
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        db.session.delete(search)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ü–æ–∏—Å–∫ —É–¥–∞–ª—ë–Ω'})
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# Developer appointment routes
@app.route('/book-appointment', methods=['GET', 'POST'])
@login_required
def book_appointment():
    """Book appointment with developer"""
    if request.method == 'POST':
        from models import DeveloperAppointment
        from datetime import datetime
        
        property_id = request.form.get('property_id')
        developer_name = request.form.get('developer_name')
        complex_name = request.form.get('complex_name')
        appointment_date = request.form.get('appointment_date')
        appointment_time = request.form.get('appointment_time')
        client_name = request.form.get('client_name')
        client_phone = request.form.get('client_phone')
        notes = request.form.get('notes', '')
        
        try:
            appointment = DeveloperAppointment(
                user_id=current_user.id,
                property_id=property_id,
                developer_name=developer_name,
                complex_name=complex_name,
                appointment_date=datetime.strptime(appointment_date, '%Y-%m-%d'),
                appointment_time=appointment_time,
                client_name=client_name,
                client_phone=client_phone,
                notes=notes
            )
            
            db.session.add(appointment)
            db.session.commit()
            
            flash('–ó–∞–ø–∏—Å—å –∫ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫—É —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.', 'success')
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–ø–∏—Å–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', 'error')
    
    # Get property data if property_id provided
    property_data = None
    property_id = request.args.get('property_id')
    if property_id:
        properties = load_properties()
        for prop in properties:
            if str(prop.get('id')) == property_id:
                property_data = prop
                break
    
    return render_template('book_appointment.html', property_data=property_data)

@app.route('/api/manager/add-client-old', methods=['POST'])
@manager_required
def add_client():
    """Add new client (old version - deprecated)"""
    from models import User
    from werkzeug.security import generate_password_hash
    import secrets
    
    data = request.get_json()
    first_name = data.get('first_name')
    last_name = data.get('last_name') 
    email = data.get('email')
    phone = data.get('phone')
    
    if not all([first_name, last_name, email]):
        return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
    
    # Check if user exists
    existing_user = User.query.filter_by(email=email).first()
    if existing_user:
        return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
    
    try:
        # Generate user ID and password
        user_id = secrets.token_hex(4).upper()
        password = 'demo123'  # Default password
        password_hash = generate_password_hash(password)
        
        manager_id = session.get('manager_id')
        
        user = User(
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=phone,
            password_hash=password_hash,
            user_id=user_id,
            assigned_manager_id=manager_id,
            client_status='–ù–æ–≤—ã–π'
        )
        
        db.session.add(user)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'user': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'password': password,
                'client_status': user.client_status
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/request-payout', methods=['POST'])
@login_required
def api_request_payout():
    """Request cashback payout"""
    from models import User, CashbackPayout
    from datetime import datetime
    
    try:
        user_id = current_user.id
        
        # Check if user has available cashback
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'})
        
        # For demo purposes, assume available cashback of 125,000
        available_cashback = 125000
        
        if available_cashback <= 0:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –∫–µ—à–±–µ–∫–∞ –¥–ª—è –≤—ã–ø–ª–∞—Ç—ã'})
        
        # Create payout request
        payout = CashbackPayout(
            user_id=user_id,
            amount=available_cashback,
            status='–ó–∞–ø—Ä–æ—à–µ–Ω–∞',
            requested_at=datetime.utcnow()
        )
        
        db.session.add(payout)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
            'amount': available_cashback
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})



# Error handlers
@app.errorhandler(404)
def not_found_error(error):
    """Handle 404 errors"""
    return render_template('errors/404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    db.session.rollback()
    return render_template('errors/500.html', error_details=str(error) if app.debug else None), 500

@app.errorhandler(Exception)
def handle_exception(e):
    """Handle all other exceptions"""
    db.session.rollback()
    if app.debug:
        return render_template('errors/500.html', error_details=str(e)), 500
    else:
        return render_template('errors/500.html'), 500

# City management API endpoints
@app.route('/api/change-city', methods=['POST'])
def change_city():
    """API endpoint to change current city"""
    try:
        data = request.get_json()
        city_slug = data.get('city_slug')
        city_name = data.get('city_name')
        
        if not city_slug or not city_name:
            return jsonify({'success': False, 'message': 'Missing city data'})
        
        # For now, only Krasnodar is available
        if city_slug != 'krasnodar':
            return jsonify({'success': False, 'message': 'City not available yet'})
        
        # Store in session
        session['current_city'] = city_name
        session['current_city_slug'] = city_slug
        
        return jsonify({'success': True, 'message': f'City changed to {city_name}'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': 'Error changing city'})

@app.route('/api/cities')
def get_cities():
    """Get available cities"""
    try:
        from models import City
        cities = City.query.filter_by(is_active=True).all()
        
        cities_data = []
        for city in cities:
            cities_data.append({
                'id': city.id,
                'name': city.name,
                'slug': city.slug,
                'is_default': city.is_default,
                'address_position_lat': city.address_position_lat,
                'address_position_lon': city.address_position_lon,
                'zoom_level': city.zoom_level
            })
            
        return jsonify({'cities': cities_data})
        
    except Exception as e:
        # Fallback data if database not set up yet
        return jsonify({
            'cities': [
                {
                    'id': 1,
                    'name': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'slug': 'krasnodar',
                    'is_default': True,
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12
                }
            ]
        })

def init_cities():
    """Initialize default cities in database"""
    try:
        from models import City
        
        # Check if cities already exist
        if City.query.count() == 0:
            cities_data = [
                {
                    'name': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'slug': 'krasnodar',
                    'is_active': True,
                    'is_default': True,
                    'phone': '8 (862) 266-62-16',
                    'email': 'krasnodar@inback.ru',
                    'address': '–≥. –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä, —É–ª. –ö—Ä–∞—Å–Ω–∞—è, 32',
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ | InBack.ru',
                    'meta_description': '–ü–æ–ª—É—á–∏—Ç–µ –¥–æ 10% –∫—ç—à–±–µ–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ. –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∏, —é—Ä–∏–¥–∏—á–µ—Å–∫–æ–µ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ.'
                },
                {
                    'name': '–ú–æ—Å–∫–≤–∞',
                    'slug': 'moscow',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'moscow@inback.ru',
                    'address': '–≥. –ú–æ—Å–∫–≤–∞, —É–ª. –¢–≤–µ—Ä—Å–∫–∞—è, 1',
                    'address_position_lat': 55.7558,
                    'address_position_lon': 37.6176,
                    'zoom_level': 11,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ú–æ—Å–∫–≤–µ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ú–æ—Å–∫–≤–µ | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –ú–æ—Å–∫–≤–µ.'
                },
                {
                    'name': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
                    'slug': 'spb',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'spb@inback.ru',
                    'address': '–≥. –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥, –ù–µ–≤—Å–∫–∏–π –ø—Ä., 1',
                    'address_position_lat': 59.9311,
                    'address_position_lon': 30.3609,
                    'zoom_level': 11,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–µ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–ü–± | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–µ.'
                },
                {
                    'name': '–°–æ—á–∏',
                    'slug': 'sochi',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'sochi@inback.ru',
                    'address': '–≥. –°–æ—á–∏, —É–ª. –ö—É—Ä–æ—Ä—Ç–Ω—ã–π –ø—Ä., 1',
                    'address_position_lat': 43.6028,
                    'address_position_lon': 39.7342,
                    'zoom_level': 12,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–æ—á–∏ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–æ—á–∏ | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –°–æ—á–∏.'
                }
            ]
            
            for city_data in cities_data:
                city = City(**city_data)
                db.session.add(city)
            
            db.session.commit()
            print("Cities initialized successfully")
            
    except Exception as e:
        print(f"Error initializing cities: {e}")

# Legacy API route removed - using Blueprint version instead

@api_bp.route('/searches', methods=['POST'])
def save_search():
    """Save user search parameters with manager-to-client sharing functionality"""
    from models import SavedSearch, User
    data = request.get_json()
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user_id = auth_info['user_id']
    user_role = auth_info['type']
    current_logged_user = auth_info['user']
    
    try:
        client_email = data.get('client_email')  # For managers
        
        print(f"DEBUG: Saving search with raw data: {data}")
        
        # Create filter object from submitted data
        filters = {}
        
        # Check if filters are nested in 'filters' object
        filter_data = data.get('filters', {}) if 'filters' in data else data
        
        # Extract filters from the data (new format)
        if 'rooms' in filter_data and filter_data['rooms']:
            if isinstance(filter_data['rooms'], list):
                room_list = [r for r in filter_data['rooms'] if r]  # Remove empty strings
                if room_list:
                    filters['rooms'] = room_list
            elif filter_data['rooms']:
                filters['rooms'] = [filter_data['rooms']]
                
        if 'districts' in filter_data and filter_data['districts']:
            if isinstance(filter_data['districts'], list):
                district_list = [d for d in filter_data['districts'] if d]  # Remove empty strings
                if district_list:
                    filters['districts'] = district_list
            elif filter_data['districts']:
                filters['districts'] = [filter_data['districts']]
                
        if 'developers' in filter_data and filter_data['developers']:
            if isinstance(filter_data['developers'], list):
                developer_list = [d for d in filter_data['developers'] if d]  # Remove empty strings
                if developer_list:
                    filters['developers'] = developer_list
            elif filter_data['developers']:
                filters['developers'] = [filter_data['developers']]
                
        if 'completion' in filter_data and filter_data['completion']:
            if isinstance(filter_data['completion'], list):
                completion_list = [c for c in filter_data['completion'] if c]  # Remove empty strings
                if completion_list:
                    filters['completion'] = completion_list
            elif filter_data['completion']:
                filters['completion'] = [filter_data['completion']]
                
        if 'priceFrom' in filter_data and filter_data['priceFrom'] and str(filter_data['priceFrom']) not in ['0', '']:
            filters['priceFrom'] = str(filter_data['priceFrom'])
        if 'priceTo' in filter_data and filter_data['priceTo'] and str(filter_data['priceTo']) not in ['0', '']:
            filters['priceTo'] = str(filter_data['priceTo'])
        if 'areaFrom' in filter_data and filter_data['areaFrom'] and str(filter_data['areaFrom']) not in ['0', '']:
            filters['areaFrom'] = str(filter_data['areaFrom'])
        if 'areaTo' in filter_data and filter_data['areaTo'] and str(filter_data['areaTo']) not in ['0', '']:
            filters['areaTo'] = str(filter_data['areaTo'])
            
        print(f"DEBUG: Extracted filters from {filter_data}: {filters}")

        # Create search with new format
        search = SavedSearch(
            user_id=user_id,
            name=data['name'],
            description=data.get('description'),
            search_type='properties',
            additional_filters=json.dumps(filters),
            notify_new_matches=data.get('notify_new_matches', True)
        )

        # Also save in legacy format for backwards compatibility
        if 'rooms' in data and data['rooms']:
            if isinstance(data['rooms'], list) and len(data['rooms']) > 0:
                search.property_type = data['rooms'][0]  # Use first room type
            else:
                search.property_type = data['rooms']
        if 'priceTo' in data and data['priceTo']:
            try:
                search.price_max = int(float(data['priceTo']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        if 'priceFrom' in data and data['priceFrom']:
            try:
                search.price_min = int(float(data['priceFrom']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        
        db.session.add(search)
        db.session.commit()
        
        # If manager specified client email, send search to client  
        if user_role == 'manager' and client_email:
            try:
                # Check if client exists
                client = User.query.filter_by(email=client_email).first()
                
                # If client exists, also save search to their account
                if client:
                    client_search = SavedSearch(
                        user_id=client.id,
                        name=data['name'] + ' (–æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞)',
                        description=data.get('description'),
                        search_type='properties',
                        location=data.get('location'),
                        property_type=data.get('property_type'),
                        price_min=data.get('price_min'),
                        price_max=data.get('price_max'),
                        size_min=data.get('size_min'),
                        size_max=data.get('size_max'),
                        developer=data.get('developer'),
                        complex_name=data.get('complex_name'),
                        floor_min=data.get('floor_min'),
                        floor_max=data.get('floor_max'),
                        additional_filters=json.dumps(filters),
                        notify_new_matches=True
                    )
                    db.session.add(client_search)
                    db.session.commit()
                
                # Prepare search URL for client properties page  
                search_params = []
                
                # Convert manager filter format to client filter format
                if data.get('location'):
                    search_params.append(f"district={data['location']}")
                if data.get('developer'):
                    search_params.append(f"developer={data['developer']}")
                if data.get('property_type'):
                    search_params.append(f"rooms={data['property_type']}")
                if data.get('complex_name'):
                    search_params.append(f"complex={data['complex_name']}")
                if data.get('price_min'):
                    search_params.append(f"priceFrom={data['price_min'] / 1000000}")
                if data.get('price_max'):
                    search_params.append(f"priceTo={data['price_max'] / 1000000}")
                if data.get('size_min'):
                    search_params.append(f"areaFrom={data['size_min']}")
                if data.get('size_max'):
                    search_params.append(f"areaTo={data['size_max']}")
                
                search_url = f"{request.url_root}properties"
                if search_params:
                    search_url += "?" + "&".join(search_params)
                
                # Email content for client
                subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {data['name']}"
                
                # Generate filter description for email
                filter_descriptions = []
                if data.get('property_type'):
                    filter_descriptions.append(f"–¢–∏–ø: {data['property_type']}")
                if data.get('location'):
                    filter_descriptions.append(f"–†–∞–π–æ–Ω: {data['location']}")
                if data.get('developer'):
                    filter_descriptions.append(f"–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: {data['developer']}")
                if data.get('price_min') or data.get('price_max'):
                    price_min = f"{(data.get('price_min', 0) / 1000000):.1f}" if data.get('price_min') else "0"
                    price_max = f"{(data.get('price_max', 0) / 1000000):.1f}" if data.get('price_max') else "‚àû"
                    filter_descriptions.append(f"–¶–µ–Ω–∞: {price_min}-{price_max} –º–ª–Ω ‚ÇΩ")
                if data.get('size_min') or data.get('size_max'):
                    area_min = str(data.get('size_min', 0)) if data.get('size_min') else "0"
                    area_max = str(data.get('size_max', 0)) if data.get('size_max') else "‚àû"
                    filter_descriptions.append(f"–ü–ª–æ—â–∞–¥—å: {area_min}-{area_max} –º¬≤")
                
                filter_text = "<br>".join([f"‚Ä¢ {desc}" for desc in filter_descriptions])
                
                html_content = f"""
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #0088CC;">–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack</h2>
                    
                    <p>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!</p>
                    
                    <p>–ú–µ–Ω–µ–¥–∂–µ—Ä <strong>{current_user.full_name or current_user.username}</strong> –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏.</p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3 style="margin: 0 0 15px 0; color: #333;">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞: {data['name']}</h3>
                        <div style="color: #666; line-height: 1.6;">
                            {filter_text}
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="{search_url}" style="display: inline-block; background: #0088CC; color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                            –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥–±–æ—Ä–∫—É
                        </a>
                    </div>
                    
                    <p style="color: #666; font-size: 14px;">
                        –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º:<br>
                        <strong>{current_logged_user.full_name if hasattr(current_logged_user, 'full_name') else current_logged_user.email}</strong><br>
                        Email: {current_logged_user.email}
                    </p>
                    
                    <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                    <p style="color: #999; font-size: 12px; text-align: center;">
                        InBack - –≤–∞—à –Ω–∞–¥–µ–∂–Ω—ã–π –ø–∞—Ä—Ç–Ω–µ—Ä –≤ –ø–æ–∏—Å–∫–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏
                    </p>
                </div>
                """
                
                # Send email using existing email service
                from email_service import send_email
                email_sent = send_email(
                    to_email=client_email,
                    subject=subject,
                    html_content=html_content,
                    template_name='collection'
                )
                
                if email_sent:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': f'–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É –Ω–∞ {client_email}',
                        'email_sent': True
                    })
                else:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å email –∫–ª–∏–µ–Ω—Ç—É',
                        'email_sent': False
                    })
                    
            except Exception as email_error:
                # Still return success for saved search even if email fails
                print(f"Email sending error: {email_error}")
                return jsonify({
                    'success': True, 
                    'search_id': search.id, 
                    'search': search.to_dict(),
                    'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ email',
                    'email_sent': False,
                    'email_error': str(email_error)
                })
        
        return jsonify({'success': True, 'search_id': search.id, 'search': search.to_dict()})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def check_api_authentication():
    """Helper function to check API authentication for both users and managers"""
    # Check if manager is logged in
    if 'manager_id' in session:
        from models import Manager
        manager = Manager.query.get(session['manager_id'])
        if manager:
            return {'type': 'manager', 'user_id': manager.id, 'user': manager}
    
    # Check if regular user is logged in  
    if current_user and hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
        return {'type': 'user', 'user_id': current_user.id, 'user': current_user}
    
    # Also check session for user_id (alternative authentication method)
    if 'user_id' in session:
        from models import User
        user = User.query.get(session['user_id'])
        if user:
            return {'type': 'user', 'user_id': user.id, 'user': user}
    
    return None

@app.route('/api/searches', methods=['GET', 'POST'])
@csrf.exempt
def saved_searches_endpoint():
    """Get or create user's saved searches"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    if request.method == 'GET':
        # Get saved searches for the authenticated user (manager or regular user) 
        searches = SavedSearch.query.filter_by(user_id=auth_info['user_id']).order_by(SavedSearch.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'searches': [search.to_dict() for search in searches]
        })
    
    elif request.method == 'POST':
        # Create new saved search
        data = request.get_json()
        name = data.get('name')
        description = data.get('description', '')
        notify_new_matches = data.get('notify_new_matches', False)
        search_type = data.get('search_type', 'properties')
        
        if not name:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        try:
            # Extract search parameters (exclude metadata fields)
            exclude_fields = {'name', 'description', 'notify_new_matches', 'search_type'}
            search_params = {k: v for k, v in data.items() if k not in exclude_fields and v}
            
            search = SavedSearch()
            search.name = name
            search.description = description
            search.notify_new_matches = notify_new_matches
            search.search_type = search_type
            search.user_id = auth_info['user_id']
            search.created_at = datetime.utcnow()
            
            # Store search parameters as additional_filters JSON
            search.additional_filters = json.dumps(search_params)
            
            # Also set individual fields if they exist in the model
            for key, value in search_params.items():
                if hasattr(search, key):
                    setattr(search, key, value)
            
            db.session.add(search)
            db.session.commit()
            
            return jsonify({'success': True, 'search_id': search.id, 'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω'})
        except Exception as e:
            db.session.rollback()
            print(f"Error saving search: {e}")
            return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches/count')
@login_required
def get_user_saved_searches_count():
    """Get count of user's saved searches"""
    from models import SavedSearch
    
    try:
        count = SavedSearch.query.filter_by(user_id=current_user.id).count()
        return jsonify({
            'success': True,
            'count': count
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/saved-searches/<int:search_id>')
@login_required 
def get_saved_search(search_id):
    """Get saved search by ID - supports both user searches and manager shared searches"""
    try:
        from models import SavedSearch, SentSearch
        
        # First try user's own saved search
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        
        # If not found, try manager shared search via SentSearch table
        if not search:
            sent_search = SentSearch.query.filter_by(
                client_id=current_user.id
            ).join(SavedSearch, SentSearch.manager_search_id == SavedSearch.id).filter(
                SavedSearch.id == search_id
            ).first()
            
            if sent_search:
                search = SavedSearch.query.get(search_id)
                # Use the additional_filters from sent_search if available
                if sent_search.additional_filters:
                    search._temp_filters = sent_search.additional_filters
        
        # If still not found, check if it's a global search available to all users
        if not search:
            search = SavedSearch.query.get(search_id)
            if search and not search.user_id:  # Global searches have no user_id
                pass  # Allow access
            else:
                search = None
        
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'})
        
        # Parse filters - check for temp filters from sent search first
        filters = {}
        if hasattr(search, '_temp_filters') and search._temp_filters:
            try:
                filters = json.loads(search._temp_filters)
            except:
                filters = {}
        elif search.additional_filters:
            try:
                filters = json.loads(search.additional_filters)
            except:
                filters = {}
        
        return jsonify({
            'success': True,
            'id': search.id,
            'name': search.name,
            'description': search.description,
            'search_filters': filters,
            'created_at': search.created_at.isoformat() if search.created_at else None
        })
        
    except Exception as e:
        print(f"Error getting saved search: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'})

@app.route('/api/searches/<int:search_id>', methods=['DELETE'])
@csrf.exempt
def delete_saved_search(search_id):
    """Delete saved search"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user_id = auth_info['user_id']
    
    search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
    
    if not search:
        return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        db.session.delete(search)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/searches/<int:search_id>/apply', methods=['POST'])
@csrf.exempt
def apply_saved_search(search_id):
    """Apply saved search and update last_used"""
    from models import SavedSearch
    from datetime import datetime
    from urllib.parse import urlencode
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user_id = auth_info['user_id']
    
    search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
    
    if not search:
        return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        search.last_used = datetime.utcnow()
        db.session.commit()
        
        # Parse filters from saved search
        filters = {}
        if search.additional_filters:
            try:
                loaded = json.loads(search.additional_filters)
                print(f"DEBUG: Loaded filters from additional_filters: {loaded}")
                
                # Check if filters are nested under 'filters' key
                if isinstance(loaded, dict) and 'filters' in loaded:
                    filters = loaded['filters']
                    print(f"DEBUG: Extracted nested filters: {filters}")
                else:
                    filters = loaded
            except json.JSONDecodeError as e:
                print(f"DEBUG: Error parsing additional_filters: {e}")
                pass
        
        # Include legacy fields as filters if not already in additional_filters
        if search.location and 'districts' not in filters:
            filters['districts'] = [search.location]
        if search.property_type and 'rooms' not in filters:
            # Keep the original property type format for proper filtering
            filters['rooms'] = [search.property_type]
        if search.developer and 'developers' not in filters:
            filters['developers'] = [search.developer]
        if search.price_min and 'priceFrom' not in filters:
            # Convert rubles to millions for client
            filters['priceFrom'] = str(search.price_min / 1000000)
        if search.price_max and 'priceTo' not in filters:
            # Convert rubles to millions for client
            filters['priceTo'] = str(search.price_max / 1000000)
        if search.size_min and 'areaFrom' not in filters:
            filters['areaFrom'] = str(search.size_min)
        if search.size_max and 'areaTo' not in filters:
            filters['areaTo'] = str(search.size_max)
        
        print(f"DEBUG: –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–∏—Å–∫ '{search.name}' —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏: {filters}")
        
        try:
            search_dict = search.to_dict()
        except Exception as e:
            print(f"DEBUG: Error in search.to_dict(): {e}")
            search_dict = {
                'id': search.id,
                'name': search.name,
                'description': search.description,
                'created_at': search.created_at.isoformat() if search.created_at else None
            }
        
        return jsonify({
            'success': True, 
            'search': search_dict,
            'filters': filters
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@login_required
def send_property_to_client_endpoint():
    """Send property search to client"""
    if current_user.role != 'manager':
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        search_id = data.get('search_id')
        message = data.get('message', '')
        
        if not client_id or not search_id:
            return jsonify({'success': False, 'error': 'Client ID and Search ID are required'}), 400
        
        # Verify client exists and is a buyer
        client = User.query.filter_by(id=client_id, role='buyer').first()
        if not client:
            return jsonify({'success': False, 'error': 'Client not found'}), 404
        
        # Verify search exists and belongs to manager
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        if not search:
            return jsonify({'success': False, 'error': 'Search not found'}), 404
        
        # Create recommendation record
        from models import ClientPropertyRecommendation
        recommendation = ClientPropertyRecommendation(
            manager_id=current_user.id,
            client_id=client_id,
            search_id=search_id,
            message=message
        )
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send notification to client (email)
        try:
            subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –∫–≤–∞—Ä—Ç–∏—Ä –æ—Ç {current_user.full_name}"
            text_message = f"""
–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!

–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {current_user.full_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–æ–¥–±–æ—Ä–∫—É –∫–≤–∞—Ä—Ç–∏—Ä: {search.name}

{message if message else ''}

–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Ω–∞ —Å–∞–π—Ç–µ InBack.ru, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥–±–æ—Ä–∫—É.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru
            """
            
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message.strip(),
                template_name='recommendation'
            )
        except Exception as e:
            app.logger.warning(f"Failed to send email notification: {str(e)}")
        
        return jsonify({
            'success': True,
            'message': 'Property recommendation sent successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Property API routes for manager search
@app.route('/api/search/properties')
def search_properties_api():
    """Search properties for manager collection creation"""
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        prop_type = request.args.get('type')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        
        # Load properties from JSON file
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        filtered_properties = []
        for prop in properties_data:
            # Apply filters
            if district and prop.get('district', '').lower() != district.lower():
                continue
            if developer and prop.get('developer', '').lower() != developer.lower():
                continue
            if rooms and str(prop.get('rooms', '')) != str(rooms):
                continue
            if prop_type and prop.get('type', '').lower() != prop_type.lower():
                continue
            
            # Price filters
            prop_price = prop.get('price', 0)
            if price_min and prop_price < int(price_min):
                continue
            if price_max and prop_price > int(price_max):
                continue
            
            # Area filter
            prop_area = prop.get('area', 0)
            if area_min and prop_area < float(area_min):
                continue
            
            # Calculate cashback
            price = prop.get('price', 0)
            cashback = int(price * 0.05)  # 5% cashback
            
            filtered_properties.append({
                'id': prop.get('id'),
                'complex_name': prop.get('complex_name', ''),
                'district': prop.get('district', ''),
                'developer': prop.get('developer', ''),
                'rooms': prop.get('rooms', 0),
                'price': price,
                'cashback': cashback,
                'area': prop.get('area', 0),
                'floor': prop.get('floor', ''),
                'type': prop.get('type', '')
            })
        
        # Limit results to 20
        filtered_properties = filtered_properties[:20]
        
        return jsonify({
            'success': True,
            'properties': filtered_properties
        })
    except Exception as e:
        print(f"Error searching properties: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/search/apartments')
def search_apartments_api():
    """Search apartments with full filtering like main properties page"""
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        complex_id = request.args.get('complex')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        area_max = request.args.get('area_max')
        floor_min = request.args.get('floor_min')
        floor_max = request.args.get('floor_max')
        status = request.args.get('status')
        finishing = request.args.get('finishing')
        
        # Load properties and complexes
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        # Load complexes data for additional info
        complexes_data = {}
        try:
            with open('data/residential_complexes.json', 'r', encoding='utf-8') as f:
                complexes_list = json.load(f)
                for complex_item in complexes_list:
                    complexes_data[complex_item.get('id')] = complex_item
        except:
            pass
        
        filtered_apartments = []
        for prop in properties_data:
            # Apply filters
            if district and prop.get('district', '').lower() != district.lower():
                continue
            if developer and prop.get('developer', '').lower() != developer.lower():
                continue
            
            # Handle rooms filter including '—Å—Ç—É–¥–∏—è'
            prop_rooms = prop.get('rooms', '')
            if rooms:
                if rooms == '—Å—Ç—É–¥–∏—è' and prop.get('type', '') != '—Å—Ç—É–¥–∏—è':
                    continue
                elif rooms != '—Å—Ç—É–¥–∏—è' and str(prop_rooms) != str(rooms):
                    continue
                    
            if complex_id and str(prop.get('complex_id', '')) != str(complex_id):
                continue
            
            # Price filters
            prop_price = prop.get('price', 0)
            if price_min and prop_price < int(price_min):
                continue
            if price_max and prop_price > int(price_max):
                continue
            
            # Area filter
            prop_area = prop.get('area', 0)
            if area_min and prop_area < float(area_min):
                continue
            if area_max and prop_area > float(area_max):
                continue
            
            # Floor filters - use correct field name
            prop_floor = prop.get('floor', 0)
            if isinstance(prop_floor, str):
                try:
                    prop_floor = int(prop_floor.split('/')[0]) if '/' in prop_floor else int(prop_floor)
                except:
                    prop_floor = 0
            
            if floor_min and prop_floor < int(floor_min):
                continue
            if floor_max and prop_floor > int(floor_max):
                continue
            
            # Status and finishing filters
            prop_status = prop.get('completion_date', '').lower()
            if status:
                if status == '–≤ –ø—Ä–æ–¥–∞–∂–µ' and '—Å–¥–∞–Ω' in prop_status:
                    continue
                elif status == '—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ' and '–∫–≤.' not in prop_status:
                    continue
                elif status == '—Å–¥–∞–Ω' and '—Å–¥–∞–Ω' not in prop_status:
                    continue
                    
            prop_finishing = prop.get('finish_type', '').lower()
            if finishing:
                if finishing == '—á–µ—Ä–Ω–æ–≤–∞—è' and '—á–µ—Ä–Ω–æ–≤–∞—è' not in prop_finishing:
                    continue
                elif finishing == '—á–∏—Å—Ç–æ–≤–∞—è' and '—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è' not in prop_finishing:
                    continue
                elif finishing == '–ø–æ–¥ –∫–ª—é—á' and '–ø—Ä–µ–º–∏—É–º' not in prop_finishing:
                    continue
            
            # Calculate cashback
            price = prop.get('price', 0)
            cashback = int(price * 0.05)  # 5% cashback
            
            # Get complex info
            complex_info = complexes_data.get(prop.get('complex_id'), {})
            
            filtered_apartments.append({
                'id': prop.get('id'),
                'complex_name': prop.get('complex_name', ''),
                'complex_id': prop.get('complex_id'),
                'district': prop.get('district', ''),
                'developer': prop.get('developer', ''),
                'rooms': prop.get('type', '') if prop.get('type', '') == '—Å—Ç—É–¥–∏—è' else prop.get('rooms', 0),
                'price': price,
                'cashback': cashback,
                'area': prop.get('area', 0),
                'floor': prop.get('floor', ''),
                'max_floor': prop.get('total_floors', ''),
                'type': prop.get('type', ''),
                'status': '—Å–¥–∞–Ω' if '—Å–¥–∞–Ω' in prop.get('completion_date', '').lower() else '—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ',
                'finishing': prop.get('finish_type', ''),
                'images': prop.get('gallery', []) or [prop.get('image', '')] if prop.get('image') else complex_info.get('images', []),
                'description': prop.get('description', ''),
                'features': prop.get('advantages', [])
            })
        
        # Sort by price (default)
        filtered_apartments.sort(key=lambda x: x['price'])
        
        # Limit results to 50
        filtered_apartments = filtered_apartments[:50]
        
        return jsonify({
            'success': True,
            'apartments': filtered_apartments,
            'complexes': complexes_data
        })
    except Exception as e:
        print(f"Error searching apartments: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/complexes')
def get_complexes_api():
    """Get list of residential complexes for filter"""
    try:
        with open('data/residential_complexes.json', 'r', encoding='utf-8') as f:
            complexes_data = json.load(f)
        
        complexes_list = [
            {'id': complex_item.get('id'), 'name': complex_item.get('name', '')}
            for complex_item in complexes_data
        ]
        
        return jsonify({
            'success': True,
            'complexes': complexes_list
        })
    except Exception as e:
        print(f"Error loading complexes: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/properties/<property_id>')
def get_property_details(property_id):
    """Get detailed property information"""
    try:
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        property_data = None
        for prop in properties_data:
            if str(prop.get('id')) == str(property_id):
                property_data = prop
                break
        
        if not property_data:
            return jsonify({'success': False, 'error': 'Property not found'}), 404
        
        # Calculate cashback
        price = property_data.get('price', 0)
        cashback = int(price * 0.05)
        
        property_info = {
            'id': property_data.get('id'),
            'complex_name': property_data.get('complex_name', ''),
            'district': property_data.get('district', ''),
            'developer': property_data.get('developer', ''),
            'rooms': property_data.get('rooms', 0),
            'price': price,
            'cashback': cashback,
            'area': property_data.get('area', 0),
            'floor': property_data.get('floor', ''),
            'type': property_data.get('type', ''),
            'description': property_data.get('description', ''),
            'features': property_data.get('features', [])
        }
        
        return jsonify({
            'success': True,
            'property': property_info
        })
    except Exception as e:
        print(f"Error getting property details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections', methods=['POST'])  
def create_collection_api():
    """Create a new property collection"""
    try:
        # Check manager authentication via session
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Authentication required'}), 401
            
        from models import Collection, CollectionProperty
        
        data = request.get_json()
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Create collection
        collection = Collection(
            title=name,
            assigned_to_user_id=client_id,
            created_by_manager_id=manager_id,
            status='–°–æ–∑–¥–∞–Ω–∞',
            description=f'–ü–æ–¥–±–æ—Ä–∫–∞ –∏–∑ {len(property_ids)} –æ–±—ä–µ–∫—Ç–æ–≤'
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        for prop_id in property_ids:
            collection_property = CollectionProperty(
                collection_id=collection.id,
                property_id=str(prop_id)
            )
            db.session.add(collection_property)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'collection_id': collection.id,
            'message': '–ü–æ–¥–±–æ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-collection', methods=['POST'])  
def send_collection_to_client():
    """Send property collection to client via email"""
    try:
        # Check manager authentication via session
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Authentication required'}), 401
            
        from models import User, Manager
        
        data = request.get_json()
        
        # TODO: Implement collection sending logic
        return jsonify({'success': True, 'message': '–§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ'})
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# ========== –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ò API ==========

@app.route('/api/manager/presentations', methods=['GET'])
@manager_required
def get_manager_presentations():
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""
    try:
        from models import Collection
        
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
        
        presentations = Collection.query.filter_by(
            created_by_manager_id=manager_id,
            collection_type='presentation'
        ).order_by(Collection.created_at.desc()).all()
        
        presentations_data = []
        for presentation in presentations:
            presentations_data.append(presentation.to_dict())
        
        return jsonify({
            'success': True,
            'presentations': presentations_data
        })
        
    except Exception as e:
        print(f"Error loading presentations: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/create', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def create_presentation():
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é"""
    from models import Collection
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    title = data.get('title')
    description = data.get('description', '')
    client_name = data.get('client_name', '')
    client_phone = data.get('client_phone', '')
    
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
            
        presentation = Collection(
            title=title,
            description=description,
            created_by_manager_id=manager_id,
            collection_type='presentation',
            client_name=client_name,
            client_phone=client_phone,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
        presentation.generate_unique_url()
        
        db.session.add(presentation)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/<int:presentation_id>', methods=['GET'])
@manager_required
def get_presentation_data(presentation_id):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞"""
    from models import Collection, CollectionProperty, Manager
    
    manager_id = session.get('manager_id')
    print(f"DEBUG: Get presentation data - manager_id: {manager_id}, presentation_id: {presentation_id}")
    
    current_manager = Manager.query.get(manager_id)
    if not current_manager:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω'}), 404
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # Load properties data to enrich the collection properties
    properties_data = load_properties()
    
    # Enrich collection properties with full property data
    enriched_properties = []
    for cp in collection_properties:
        # Find the property in the main properties data
        property_data = None
        for prop in properties_data:
            if str(prop.get('id')) == str(cp.property_id):
                property_data = prop
                break
        
        if property_data:
            # Get complex name directly from property_data
            complex_name = property_data.get('residential_complex', property_data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω'))
            
            # Get coordinates from the coordinates object
            coordinates = property_data.get('coordinates', {})
            latitude = coordinates.get('lat') if coordinates else None
            longitude = coordinates.get('lng') if coordinates else None
            
            # Prepare main image
            main_image = property_data.get('main_image', '/static/images/no-photo.jpg')
            images = [main_image] if main_image and main_image != '/static/images/no-photo.jpg' else []
            
            enriched_property = {
                'id': property_data.get('id'),
                'property_id': cp.property_id,
                'manager_note': cp.manager_note,
                'order_index': cp.order_index,
                'rooms': property_data.get('rooms', 0),
                'price': property_data.get('price', 0),
                'area': property_data.get('area', 0),
                'floor': property_data.get('floor', 0),
                'total_floors': property_data.get('total_floors', 0),
                'complex_name': complex_name,
                'property_type': property_data.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
                'images': images,
                'main_image': main_image,
                'layout_image': property_data.get('layout_image'),
                'address': property_data.get('address', ''),
                'latitude': latitude,
                'longitude': longitude,
                'description': property_data.get('description', ''),
                'features': property_data.get('features', []),
                'developer': property_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'district': property_data.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                'cashback': property_data.get('cashback', 0),
                'cashback_available': property_data.get('cashback_available', True),
                'price_per_sqm': property_data.get('price_per_sqm', 0),
                'status': property_data.get('status', 'available'),
                'title': property_data.get('title', f"{property_data.get('rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"),
                'url': property_data.get('url', f"/object/{property_data.get('id')}")
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in main data")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties")
    
    # Format presentation data for JSON response
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at.isoformat() if presentation.created_at else None,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at.isoformat() if presentation.last_viewed_at else None,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url,
        'assigned_to_user_id': presentation.assigned_to_user_id  # Add this for "Send to Client Dashboard" button
    }
    
    return jsonify({
        'success': True,
        'presentation': presentation_data
    })

@app.route('/api/manager/presentation/<int:presentation_id>/add_property', methods=['POST'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_property_to_presentation(presentation_id):
    """–î–æ–±–∞–≤–∏—Ç—å –∫–≤–∞—Ä—Ç–∏—Ä—É –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ª–∏ —É–∂–µ —ç—Ç–∞ –∫–≤–∞—Ä—Ç–∏—Ä–∞
    existing = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=property_id
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–≤–∞—Ä—Ç–∏—Ä–µ –∏–∑ JSON
        properties = load_properties()
        property_info = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=property_id,
            property_name=property_info.get('title', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
            property_price=int(property_info.get('price', 0)) if property_info.get('price') else None,
            complex_name=property_info.get('residential_complex', ''),
            property_type=f"{property_info.get('rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è" if property_info.get('rooms', 0) > 0 else '–°—Ç—É–¥–∏—è',
            property_size=float(property_info.get('area', 0)) if property_info.get('area') else None,
            manager_note=manager_note,
            order_index=len(presentation.properties) + 1
        )
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# –ù–û–í–´–ï API –≠–ù–î–ü–û–ò–ù–¢–´ –î–õ–Ø –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ô

@app.route('/api/manager/presentation/<int:presentation_id>/add-property', methods=['POST'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_property_to_presentation_fixed(presentation_id):
    """–î–æ–±–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    property_id = data.get('property_id')
    if not property_id:
        return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
    
    # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –æ–±—ä–µ–∫—Ç
    existing = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=property_id
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—ä–µ–∫—Ç–µ
        properties = load_properties()
        property_info = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=property_id,
            property_name=property_info.get('title', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
            property_price=int(property_info.get('price', 0)) if property_info.get('price') else None,
            complex_name=property_info.get('residential_complex', ''),
            property_type=f"{property_info.get('rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è" if property_info.get('rooms', 0) > 0 else '–°—Ç—É–¥–∏—è',
            property_size=float(property_info.get('area', 0)) if property_info.get('area') else None,
            order_index=len(presentation.properties) + 1
        )
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/<int:presentation_id>/property/<int:property_id>/comment', methods=['PUT'])
@manager_required
def update_property_comment_in_presentation(presentation_id, property_id):
    """–û–±–Ω–æ–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∫ –æ–±—ä–µ–∫—Ç—É –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    manager_note = data.get('manager_note', '').strip()
    
    # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
    collection_property = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=str(property_id)
    ).first()
    
    if not collection_property:
        return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 404
    
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
        collection_property.manager_note = manager_note
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ–±–Ω–æ–≤–ª–µ–Ω',
            'property': {
                'id': collection_property.property_id,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/<int:presentation_id>/status', methods=['PUT'])
@manager_required
# @require_json_csrf  # CSRF disabled
def update_presentation_status(presentation_id):
    """–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–µ–∂–¥—É –ß–µ—Ä–Ω–æ–≤–∏–∫ –∏ –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ"""
    from models import Collection
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    new_status = data.get('status', '').strip()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–∞
    if new_status not in ['–ß–µ—Ä–Ω–æ–≤–∏–∫', '–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ']:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å—Ç–∞—Ç—É—Å'}), 400
    
    # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ —Ñ–ª–∞–≥ –ø—É–±–ª–∏—á–Ω–æ—Å—Ç–∏
        presentation.status = new_status
        presentation.is_public = (new_status == '–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ')
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ "{new_status}"',
            'status': presentation.status,
            'is_public': presentation.is_public
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# ===== PDF AND PRINT ENDPOINTS =====

def fetch_pdf_context(property_id, presentation_id=None):
    """
    Fetch comprehensive context for PDF generation including:
    - Property details and images from excel_properties
    - Residential complex details and characteristics
    - Manager contact information
    
    FIXED: Uses SQLAlchemy text() with bindparams for SQLite compatibility
    FIXED: Added safe resource handling and division by zero protection
    """
    import json
    from models import Collection, CollectionProperty, ResidentialComplex, Manager
    from sqlalchemy import text
    
    try:
        # Get property data using SQLAlchemy text() with bindparams (SQLite compatible)
        property_query = text("""
        SELECT ep.inner_id, ep.photos, ep.complex_name, ep.complex_id,
               ep.complex_object_class_display_name, ep.complex_building_end_build_year,
               ep.complex_building_end_build_quarter, ep.complex_has_big_check,
               ep.complex_financing_sber, ep.complex_has_green_mortgage,
               ep.object_rooms, ep.object_area, ep.object_min_floor, ep.object_max_floor, 
               ep.price, ep.address_display_name, ep.address_position_lat, ep.address_position_lon,
               ep.developer_name, ep.renovation_display_name
        FROM excel_properties ep
        WHERE ep.inner_id = :property_id
        """)
        
        # Use SQLAlchemy session with proper error handling
        result = db.session.execute(property_query, {'property_id': property_id})
        property_row = result.fetchone()
        
        if not property_row:
            return None
            
        # Convert to dictionary using _mapping for SQLAlchemy compatibility
        property_data = dict(property_row._mapping)
        
        # Parse photos JSON with safe error handling
        property_images = {'photos': [], 'plans': []}
        if property_data.get('photos'):
            try:
                photos_list = json.loads(property_data['photos'])
                if photos_list and isinstance(photos_list, list):
                    # First 6 images as main photos, 6-8 as plans (fixed logic)
                    property_images['photos'] = photos_list[:6]
                    property_images['plans'] = photos_list[6:8] if len(photos_list) > 6 else []
            except (json.JSONDecodeError, TypeError, ValueError):
                property_images['photos'] = []
                property_images['plans'] = []
        
        # Get residential complex data if available
        complex_data = {}
        complex_images = {'facade': [], 'territory': [], 'infrastructure': [], 'construction': []}
        complex_photos = []
        
        if property_data.get('complex_name'):
            try:
                # Load basic complex data from residential_complexes table
                complex_query = text("""
                SELECT name, slug, district_id, developer_id, cashback_rate,
                       object_class_display_name, start_build_year, start_build_quarter,
                       end_build_year, end_build_quarter, has_accreditation,
                       has_green_mortgage, has_big_check, with_renovation, financing_sber
                FROM residential_complexes 
                WHERE name = :complex_name
                """)
                complex_result = db.session.execute(complex_query, {'complex_name': property_data['complex_name']})
                complex_row = complex_result.fetchone()
                
                if complex_row:
                    complex_data = dict(complex_row._mapping)
                
                # Load complex photos from excel_properties table (where photos are actually stored)
                photos_query = text("""
                SELECT photos FROM excel_properties 
                WHERE complex_name = :complex_name AND photos IS NOT NULL
                LIMIT 1
                """)
                photos_result = db.session.execute(photos_query, {'complex_name': property_data['complex_name']})
                photos_row = photos_result.fetchone()
                
                if photos_row and photos_row[0]:
                    try:
                        photos_data = json.loads(photos_row[0])
                        if isinstance(photos_data, list):
                            complex_photos = photos_data[:9]  # Take first 9 photos for 3x3 grid
                        elif isinstance(photos_data, dict):
                            # If photos are organized by categories  
                            all_photos = []
                            for category, photos_list in photos_data.items():
                                if isinstance(photos_list, list):
                                    all_photos.extend(photos_list)
                            complex_photos = all_photos[:9]  # Take first 9 photos for 3x3 grid
                    except (json.JSONDecodeError, TypeError):
                        complex_photos = []
                        
            except Exception as e:
                print(f"Error loading complex data: {e}")
        
        # Get manager information if presentation_id provided
        manager_data = {}
        if presentation_id:
            try:
                presentation = Collection.query.get(presentation_id)
                if presentation and presentation.created_by_manager_id:
                    manager = Manager.query.get(presentation.created_by_manager_id)
                    if manager:
                        manager_data = {
                            'name': manager.full_name or '–ú–µ–Ω–µ–¥–∂–µ—Ä',
                            'email': manager.email or '',
                            'phone': manager.phone or '+7 (XXX) XXX-XX-XX',
                            'photo_url': None  # Add if available
                        }
            except Exception as e:
                print(f"Error loading manager data: {e}")
        
        # Safe type conversion with defaults (using corrected column names)
        area = float(property_data.get('object_area') or 0)
        price = int(property_data.get('price') or 0)  # Fixed column name
        rooms = int(property_data.get('object_rooms') or 0)
        floor = int(property_data.get('object_min_floor') or 0)  # Fixed column name
        total_floors = int(property_data.get('object_max_floor') or 0)
        
        # Calculate price per sqm with division by zero protection
        price_per_sqm = 0
        if area > 0 and price > 0:
            try:
                price_per_sqm = int(price / area)
            except (ZeroDivisionError, ValueError):
                price_per_sqm = 0
        
        # Get cashback from complex data (loaded from residential_complexes table)
        cashback_rate = complex_data.get('cashback_rate', 5.0) if complex_data else 5.0
        cashback_amount = int(price * cashback_rate / 100) if price > 0 else 0
        
        # Construct full context with safe data types
        context = {
            'property': {
                'id': property_data.get('inner_id'),
                'rooms': rooms,
                'area': area,
                'floor': floor,
                'total_floors': total_floors,
                'price': price,
                'price_per_sqm': price_per_sqm,
                'finishing': property_data.get('renovation_display_name') or '–ù–µ —É–∫–∞–∑–∞–Ω',
                'status': '–ê–∫—Ç–∏–≤–µ–Ω',  # Default since column doesn't exist
                'address': property_data.get('address_display_name') or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                'cashback_percent': cashback_rate,
                'cashback_amount': cashback_amount,
                'latitude': property_data.get('address_position_lat'),
                'longitude': property_data.get('address_position_lon'),
                'object_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',  # Default since column doesn't exist
                'developer_name': property_data.get('developer_name') or '',
                'jk_name': property_data.get('complex_name') or '',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',  # Default since column doesn't exist
                'completion_date': None  # Will be set from complex data if available
            },
            'property_images': property_images,
            'complex': {
                'id': property_data.get('complex_id'),
                'name': property_data.get('complex_name') or '',
                'class': property_data.get('complex_object_class_display_name') or '',
                'completion_year': property_data.get('complex_building_end_build_year'),
                'completion_quarter': property_data.get('complex_building_end_build_quarter'),
                'has_big_check': bool(property_data.get('complex_has_big_check')),
                'financing_sber': bool(property_data.get('complex_financing_sber')),
                'has_green_mortgage': bool(property_data.get('complex_has_green_mortgage')),
                'developer': property_data.get('developer_name') or '',
                'photos': complex_photos,  # Added complex photos from database
                'features': []
            },
            'complex_images': complex_images,
            'manager': manager_data,
            'generated_at': property_data  # Full raw data for backwards compatibility
        }
        
        # Add completion date to property if available
        if context['complex']['completion_quarter'] and context['complex']['completion_year']:
            context['property']['completion_date'] = f"{context['complex']['completion_quarter']} –∫–≤. {context['complex']['completion_year']} –≥."
        
        # Add complex features list with safe checks
        features = []
        if complex_data.get('has_accreditation'):
            features.append('–ê–∫–∫—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω –±–∞–Ω–∫–∞–º–∏')
        if complex_data.get('has_green_mortgage') or property_data.get('complex_has_green_mortgage'):
            features.append('–õ—å–≥–æ—Ç–Ω–∞—è –∏–ø–æ—Ç–µ–∫–∞')  
        if complex_data.get('with_renovation'):
            features.append('–° –æ—Ç–¥–µ–ª–∫–æ–π')
        if complex_data.get('financing_sber') or property_data.get('complex_financing_sber'):
            features.append('–§–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –°–±–µ—Ä–±–∞–Ω–∫')
        if complex_data.get('has_big_check') or property_data.get('complex_has_big_check'):
            features.append('–ë–æ–ª—å—à–æ–π —á–µ–∫')
        
        context['complex']['features'] = features
        
        return context
        
    except Exception as e:
        print(f"Error in fetch_pdf_context: {e}")
        import traceback
        traceback.print_exc()
        return None

@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/print')
@manager_required
def print_property(presentation_id, property_id):
    """–û—Ç–∫—Ä—ã—Ç—å –≤–µ—Ä—Å–∏—é –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è –ø–µ—á–∞—Ç–∏ —Å –ø–æ–ª–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ –±–∞–∑—ã"""
    from models import Collection, CollectionProperty
    
    # Find presentation and property
    presentation = Collection.query.get_or_404(presentation_id)
    property_obj = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=property_id
    ).first()
    
    if not property_obj:
        return "Property not found in presentation", 404
    
    # Get comprehensive context using new function
    context = fetch_pdf_context(property_id, presentation_id)
    
    if not context:
        return "Property data not found", 404
    
    # Render print template with full context
    return render_template('print_property.html', 
                         property=context['property'],
                         property_images=context['property_images'],
                         complex=context['complex'],
                         complex_images=context['complex_images'],
                         manager=context['manager'],
                         presentation=presentation,
                         manager_note=getattr(property_obj, 'manager_note', None),
                         context=context)  # Full context for backwards compatibility

@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/download')
@manager_required
def download_presentation_property_pdf(presentation_id, property_id):
    """–°–∫–∞—á–∞—Ç—å –æ–±—ä–µ–∫—Ç –≤ PDF —Ñ–æ—Ä–º–∞—Ç–µ"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    from io import BytesIO
    import tempfile
    import os
    
    try:
        # Find presentation and property
        presentation = Collection.query.get_or_404(presentation_id)
        property_obj = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if not property_obj:
            return "Property not found in presentation", 404
        
        # Get comprehensive context using new function
        context = fetch_pdf_context(property_id, presentation_id)
        
        if not context:
            return "Property data not found", 404
        
        # Render HTML for PDF with full context
        html_content = render_template('print_property.html', 
                                     property=context['property'],
                                     property_images=context['property_images'],
                                     complex=context['complex'],
                                     complex_images=context['complex_images'],
                                     manager=context['manager'],
                                     presentation=presentation,
                                     manager_note=property_obj.manager_note,
                                     context=context,
                                     for_pdf=True)
        
        # Generate PDF
        pdf_buffer = BytesIO()
        HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
        pdf_buffer.seek(0)
        
        return send_file(
            pdf_buffer,
            as_attachment=True,
            download_name=f'property_{property_id}.pdf',
            mimetype='application/pdf'
        )
        
    except Exception as e:
        print(f"Error generating PDF: {e}")
        return f"Error generating PDF: {str(e)}", 500

@app.route('/api/manager/presentation/<int:presentation_id>/download-all')
@manager_required
def download_all_properties(presentation_id):
    """–°–∫–∞—á–∞—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ ZIP –∞—Ä—Ö–∏–≤–µ"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        manager_id = session.get('manager_id')
        if presentation.created_by_manager_id != manager_id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation_id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return jsonify({'success': False, 'error': 'No properties in presentation'}), 400
        
        # Create ZIP archive
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for prop in properties:
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            ep.inner_id AS id,
                            CAST(ep.object_area AS FLOAT) AS area,
                            CAST(ep.price AS INTEGER) AS price,
                            CAST(ep.object_min_floor AS INTEGER) AS floor,
                            CAST(ep.object_max_floor AS INTEGER) AS total_floors,
                            CAST(ep.object_rooms AS INTEGER) AS rooms,
                            '–ö–≤–∞—Ä—Ç–∏—Ä–∞' AS property_type,
                            ep.address_display_name AS address,
                            ep.complex_name AS jk_name,
                            ep.developer_name AS developer_name,
                            NULL AS completion_date
                        FROM excel_properties ep
                        WHERE ep.inner_id = :prop_id
                    """)
                    
                    # Convert property_id to int for inner_id lookup
                    try:
                        prop_id_int = int(prop.property_id)
                    except ValueError:
                        print(f"Invalid property ID format: {prop.property_id}")
                        continue
                        
                    result = db.session.execute(query, {'prop_id': prop_id_int}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation_id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation_id}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/presentation/view/<string:unique_id>/download-all')
def download_all_properties_public(unique_id):
    """–ü—É–±–ª–∏—á–Ω–æ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ ZIP –∞—Ä—Ö–∏–≤–µ"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation by unique_id instead of presentation_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return "–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 404
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation.id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return "–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏", 400
        
        # Initialize progress tracking
        progress_key = f"presentation_{unique_id}"
        total_properties = len(properties)
        
        # Create ZIP archive with real progress tracking
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for current_index, prop in enumerate(properties, 1):
                # Update progress
                progress = int((current_index / total_properties) * 85)  # Leave 15% for ZIP creation
                progress_storage[progress_key] = {
                    'stage': 'processing',
                    'progress': progress,
                    'current': current_index,
                    'total': total_properties,
                    'message': f'–°–æ–∑–¥–∞—é PDF –¥–ª—è –∫–≤–∞—Ä—Ç–∏—Ä—ã {current_index} –∏–∑ {total_properties}...'
                }
                
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            ep.inner_id AS id,
                            CAST(ep.object_area AS FLOAT) AS area,
                            CAST(ep.price AS INTEGER) AS price,
                            CAST(ep.object_min_floor AS INTEGER) AS floor,
                            CAST(ep.object_max_floor AS INTEGER) AS total_floors,
                            CAST(ep.object_rooms AS INTEGER) AS rooms,
                            '–ö–≤–∞—Ä—Ç–∏—Ä–∞' AS property_type,
                            ep.address_display_name AS address,
                            ep.complex_name AS jk_name,
                            ep.developer_name AS developer_name,
                            NULL AS completion_date
                        FROM excel_properties ep
                        WHERE ep.inner_id = :prop_id
                    """)
                    
                    # Convert property_id to int for inner_id lookup
                    try:
                        prop_id_int = int(prop.property_id)
                    except ValueError:
                        print(f"Invalid property ID format: {prop.property_id}")
                        continue
                        
                    result = db.session.execute(query, {'prop_id': prop_id_int}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation.id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
        
        # Final progress - creating archive
        progress_storage[progress_key] = {
            'stage': 'completing',
            'progress': 95,
            'message': '–°–æ–∑–¥–∞—é –∞—Ä—Ö–∏–≤...'
        }
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        # Mark as complete
        progress_storage[progress_key] = {
            'stage': 'complete',
            'progress': 100,
            'message': '–ì–æ—Ç–æ–≤–æ! –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª–æ—Å—å.'
        }
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation.title.replace(" ", "_")}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        
        # Update progress with error
        progress_key = f"presentation_{unique_id}"
        progress_storage[progress_key] = {
            'stage': 'error',
            'progress': 0,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—Ä—Ö–∏–≤–∞: {str(e)}'
        }
        
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—Ä—Ö–∏–≤–∞: {str(e)}", 500

# Global progress storage for tracking real-time PDF generation
progress_storage = {}

@app.route('/presentation/view/<string:unique_id>/progress')
def download_progress_stream(unique_id):
    """SSE endpoint –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å–æ–∑–¥–∞–Ω–∏—è PDF —Ñ–∞–π–ª–æ–≤"""
    from flask import Response
    import json
    import time
    from models import Collection, CollectionProperty
    
    try:
        # Find presentation by unique_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            def error_stream():
                yield f"data: {json.dumps({'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
        
        # Get properties count
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        if not properties:
            def error_stream():
                yield f"data: {json.dumps({'error': '–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
            
        def progress_generator():
            try:
                total = len(properties)
                progress_key = f"presentation_{unique_id}"
                
                # Initialize progress
                progress_storage[progress_key] = {
                    'stage': 'starting',
                    'progress': 0,
                    'current': 0,
                    'total': total,
                    'message': '–ù–∞—á–∏–Ω–∞—é —Å–æ–∑–¥–∞–Ω–∏–µ PDF —Ñ–∞–π–ª–æ–≤...'
                }
                
                # –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                time.sleep(1)
                
                # Wait for real progress updates from download endpoint
                last_progress = 0
                timeout_counter = 0
                
                while True:
                    if progress_key in progress_storage:
                        current_progress = progress_storage[progress_key]
                        
                        # Only send updates when progress changes
                        if current_progress['progress'] != last_progress or current_progress['stage'] != 'processing':
                            yield f"data: {json.dumps(current_progress)}\n\n"
                            last_progress = current_progress['progress']
                        
                        # Check if completed
                        if current_progress['stage'] == 'complete':
                            break
                            
                        # Check if error occurred
                        if current_progress['stage'] == 'error':
                            break
                    
                    time.sleep(0.5)
                    timeout_counter += 1
                    
                    # Timeout after 2 minutes
                    if timeout_counter > 240:
                        progress_storage[progress_key] = {
                            'stage': 'error',
                            'message': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è',
                            'progress': 0
                        }
                        yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                        break
                
                # Cleanup
                if progress_key in progress_storage:
                    del progress_storage[progress_key]
                    
            except Exception as e:
                yield f"data: {json.dumps({'error': f'–û—à–∏–±–∫–∞: {str(e)}'})}\n\n"
        
        return Response(
            progress_generator(),
            content_type='text/event-stream',
            headers={
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0',
                'Connection': 'keep-alive',
                'X-Accel-Buffering': 'no',  # Disable nginx buffering
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Cache-Control',
                'Content-Type': 'text/event-stream; charset=utf-8'
            }
        )
        
    except Exception as e:
        def error_stream():
            yield f"data: {json.dumps({'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'})}\n\n"
        return Response(error_stream(), content_type='text/plain')

@app.route('/api/manager/presentation/<int:presentation_id>/send-email', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def send_presentation_email(presentation_id):
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –Ω–∞ email"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    import smtplib
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.mime.base import MIMEBase
    from email import encoders
    
    try:
        data = request.get_json()
        if not data or not data.get('email'):
            return jsonify({'success': False, 'error': 'Email –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        email = data['email']
        
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        manager_id = session.get('manager_id')
        if presentation.created_by_manager_id != manager_id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get properties count
        properties_count = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).count()
        
        # Create simple email (without attachments for now)
        msg = MIMEMultipart()
        msg['From'] = "noreply@inback.ru"
        msg['To'] = email
        msg['Subject'] = f"–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack - {presentation.name}"
        
        # Email body
        body = f"""
        –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!
        
        –í—ã—Å—ã–ª–∞–µ–º –≤–∞–º –ø–æ–¥–æ–±—Ä–∞–Ω–Ω—É—é –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ "{presentation.name}".
        
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–æ–≤: {properties_count}
        
        –ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:
        {request.host_url}manager/presentation/{presentation_id}
        
        –° —É–≤–∞–∂–µ–Ω–∏–µ–º,
        –ö–æ–º–∞–Ω–¥–∞ InBack
        """
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Send email (simplified version - would need real SMTP config)
        print(f"EMAIL SENT TO: {email}")
        print(f"EMAIL BODY: {body}")
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email'
        })
        
    except Exception as e:
        print(f"Error sending email: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/<int:presentation_id>/add-complex', methods=['POST'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_complex_to_presentation(presentation_id):
    """–î–æ–±–∞–≤–∏—Ç—å –ñ–ö –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    complex_id = data.get('complex_id')
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID –ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
    
    # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=manager_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –∏–∑ –ñ–ö
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –≤ –Ω–µ–º –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # –î–æ–±–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º 5 –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö
            property_id = prop.get('ID')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –æ–±—ä–µ–∫—Ç
            existing = CollectionProperty.query.filter_by(
                collection_id=presentation_id,
                property_id=property_id
            ).first()
            
            if not existing:
                collection_property = CollectionProperty(
                    collection_id=presentation_id,
                    property_id=property_id,
                    property_name=f"{prop.get('Type', '')} –≤ {prop.get('Complex', '')}",
                    property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                    complex_name=prop.get('Complex', ''),
                    property_type=prop.get('Type', ''),
                    property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                    order_index=len(presentation.properties) + added_count + 1
                )
                
                db.session.add(collection_property)
                added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'added_count': added_count
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/create-with-property', methods=['POST'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_property():
    """–°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –∏ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    property_id = data.get('property_id')
    
    # –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    if not property_id:
        return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
            
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection(
            title=title,
            created_by_manager_id=manager_id,
            collection_type='presentation',
            client_name=client_name,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        
        presentation.generate_unique_url()
        db.session.add(presentation)
        db.session.flush()  # –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç
        properties = load_properties()
        property_info = None
        
        for prop in properties:
            if str(prop.get('ID')) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        collection_property = CollectionProperty(
            collection_id=presentation.id,
            property_id=property_id,
            property_name=f"{property_info.get('Type', '')} –≤ {property_info.get('Complex', '')}",
            property_price=int(property_info.get('Price', 0)) if property_info.get('Price') else None,
            complex_name=property_info.get('Complex', ''),
            property_type=property_info.get('Type', ''),
            property_size=float(property_info.get('Size', 0)) if property_info.get('Size') else None,
            order_index=1
        )
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/create-with-complex', methods=['POST'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_complex():
    """–°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –∏ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –ñ–ö (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    complex_id = data.get('complex_id')
    
    # –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID –ñ–ö –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º manager_id –∏–∑ —Å–µ—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ current_user.id
        manager_id = session.get('manager_id')
        if not manager_id:
            return jsonify({'success': False, 'error': 'Manager ID not found'}), 401
            
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection(
            title=title,
            created_by_manager_id=manager_id,
            collection_type='presentation', 
            client_name=client_name,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        
        presentation.generate_unique_url()
        db.session.add(presentation)
        db.session.flush()  # –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã –∏–∑ –ñ–ö
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –≤ –Ω–µ–º –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # –î–æ–±–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º 5 –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö
            property_id = prop.get('ID')
            
            collection_property = CollectionProperty(
                collection_id=presentation.id,
                property_id=property_id,
                property_name=f"{prop.get('Type', '')} –≤ {prop.get('Complex', '')}",
                property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                complex_name=prop.get('Complex', ''),
                property_type=prop.get('Type', ''),
                property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                order_index=added_count + 1
            )
            
            db.session.add(collection_property)
            added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': f'–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ —Å {added_count} –æ–±—ä–µ–∫—Ç–∞–º–∏ –∏–∑ –ñ–ö'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


# ===== –ù–û–í–´–ï API ENDPOINT'–´ –î–õ–Ø –î–ï–ô–°–¢–í–ò–ô –° –û–ë–™–ï–ö–¢–ê–ú–ò –í –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ò =====

# REMOVED DUPLICATE PRINT ENDPOINT - security fix
    from models import Collection, CollectionProperty
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–∞
        properties = load_properties()
        property_data = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id) or str(prop.get('ID')) == str(property_id) or str(prop.get('inner_id')) == str(property_id):
                property_data = prop
                break
        
        if not property_data:
            abort(404)
        
        # –†–µ–Ω–¥–µ—Ä–∏—Ç—å print-friendly –≤–µ—Ä—Å–∏—é
        return render_template('property_print.html', 
                             property=property_data,
                             presentation=presentation,
                             collection_property=collection_property)
        
    except Exception as e:
        print(f"Error in property_print_view: {e}")
        abort(500)


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/download')
def property_download_pdf(presentation_id, property_id):
    """–°–∫–∞—á–∞—Ç—å PDF –æ–±—ä–µ–∫—Ç–∞ –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    from models import Collection, CollectionProperty
    from flask import make_response
    import io
    
    # Try to import weasyprint with fallback
    try:
        import weasyprint
        pdf_available = True
    except ImportError:
        pdf_available = False
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É—è fetch_pdf_context –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–æ—Ç–æ –∏ –∫—ç—à–±–µ–∫–∞
        context = fetch_pdf_context(property_id, presentation_id)
        
        if not context:
            abort(404)
        
        # Check if PDF generation is available
        if not pdf_available:
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # –†–µ–Ω–¥–µ—Ä–∏—Ç—å HTML –¥–ª—è PDF —Å –ø–æ–ª–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
        html_content = render_template('property_pdf.html', 
                                     property=context['property'],
                                     property_images=context['property_images'],
                                     complex=context['complex'],
                                     complex_images=context['complex_images'],
                                     manager=context['manager'],
                                     presentation=presentation,
                                     collection_property=collection_property)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å PDF
        try:
            pdf_buffer = io.BytesIO()
            weasyprint.HTML(string=html_content, base_url=request.url_root).write_pdf(pdf_buffer)
            pdf_buffer.seek(0)
            
            # –°–æ–∑–¥–∞—Ç—å ASCII-safe –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è headers
            property_name = property_data.get('name', f"–û–±—ä–µ–∫—Ç_{property_id}")
            original_filename = f"{property_name}_{presentation.title}.pdf"
            
            # Create ASCII-safe filename for HTTP headers
            ascii_filename = f"property_{property_id}_{presentation_id}.pdf"
            
            # Clean original filename for RFC 5987 encoding if needed
            clean_filename = "".join(c for c in original_filename if c.isalnum() or c in (' ', '.', '_', '-')).rstrip()
        except Exception as pdf_error:
            print(f"PDF generation failed: {pdf_error}")
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # –í–µ—Ä–Ω—É—Ç—å PDF –∫–∞–∫ —Ñ–∞–π–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
        from urllib.parse import quote
        
        response = make_response(pdf_buffer.read())
        response.headers['Content-Type'] = 'application/pdf'
        
        # Use ASCII-safe filename in Content-Disposition with RFC 5987 fallback for Unicode
        try:
            # Try to encode original filename for browsers that support RFC 5987
            encoded_filename = quote(clean_filename.encode('utf-8'))
            response.headers['Content-Disposition'] = (
                f'attachment; '
                f'filename="{ascii_filename}"; '
                f'filename*=UTF-8\'\'{encoded_filename}'
            )
        except:
            # Fallback to ASCII-only filename
            response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        return response
        
    except Exception as e:
        print(f"Error in property_download_pdf: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/view')
def property_view_redirect(presentation_id, property_id):
    """–ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ø–æ–ª–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–±—ä–µ–∫—Ç–∞ –Ω–∞ —Å–∞–π—Ç–µ"""
    from models import Collection, CollectionProperty
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–±—ä–µ–∫—Ç–∞
        return redirect(url_for('property_detail', property_id=property_id))
        
    except Exception as e:
        print(f"Error in property_view_redirect: {e}")
        abort(500)


@app.route('/api/manager/presentation/<int:presentation_id>/property/<string:property_id>/delete', methods=['DELETE'])
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def delete_property_from_presentation(presentation_id, property_id):
    """–£–¥–∞–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞-–≤–ª–∞–¥–µ–ª—å—Ü–∞)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ - —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –æ–±—ä–µ–∫—Ç—ã
        if presentation.created_by_manager_id != current_user.id:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ —ç—Ç–æ–π –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 403
        
        # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if not collection_property:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 404
        
        # –£–¥–∞–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        db.session.delete(collection_property)
        db.session.commit()
        
        # –û–±–Ω–æ–≤–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        remaining_properties = CollectionProperty.query.filter_by(collection_id=presentation_id).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏',
            'remaining_properties': remaining_properties
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in delete_property_from_presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def send_collection_to_user():
    """Send collection to user - legacy function"""
    if request.method != 'POST':
        return jsonify({'success': False, 'error': 'Only POST method allowed'}), 405
    
    data = request.get_json()
    manager_id = session.get('manager_id')
    
    if not manager_id:
        return jsonify({'success': False, 'error': 'Manager authentication required'}), 401
    
    try:
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Get client and manager info
        client = User.query.get(client_id)
        manager = Manager.query.get(manager_id)
        
        if not client or not manager:
            return jsonify({'success': False, 'error': 'Client or manager not found'}), 404
        
        # Load property details
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        selected_properties = []
        total_cashback = 0
        
        for prop_id in property_ids:
            for prop in properties_data:
                if str(prop.get('id')) == str(prop_id):
                    price = prop.get('price', 0)
                    cashback = int(price * 0.05)
                    total_cashback += cashback
                    
                    selected_properties.append({
                        'complex_name': prop.get('complex_name', ''),
                        'district': prop.get('district', ''),
                        'developer': prop.get('developer', ''),
                        'rooms': prop.get('rooms', 0),
                        'area': prop.get('area', 0),
                        'price': price,
                        'cashback': cashback,
                        'type': prop.get('type', ''),
                        'description': prop.get('description', '')
                    })
                    break
        
        # Create email content
        properties_list = '\n'.join([
            f"‚Ä¢ {prop['complex_name']} ({prop['district']})\n"
            f"  {prop['rooms']}-–∫–æ–º–Ω., {prop['area']} –º¬≤\n"
            f"  –¶–µ–Ω–∞: {prop['price']:,} ‚ÇΩ\n"
            f"  –ö–µ—à–±–µ–∫: {prop['cashback']:,} ‚ÇΩ\n"
            for prop in selected_properties
        ])
        
        subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {name}"
        text_message = f"""
–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!

–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {manager.full_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ "{name}".

–ü–û–î–û–ë–†–ê–ù–ù–´–ï –û–ë–™–ï–ö–¢–´ ({len(selected_properties)} —à—Ç.):

{properties_list}

–û–ë–©–ò–ô –ö–ï–®–ë–ï–ö: {total_cashback:,} ‚ÇΩ

–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º:
{manager.full_name}
Email: {manager.email}
–¢–µ–ª–µ—Ñ–æ–Ω: {manager.phone or '–Ω–µ —É–∫–∞–∑–∞–Ω'}

–ò–ª–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Ω–∞ —Å–∞–π—Ç–µ InBack.ru

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru
        """.strip()
        
        # Send email
        try:
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message,
                template_name='collection'
            )
            
            return jsonify({
                'success': True,
                'message': f'–ü–æ–¥–±–æ—Ä–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email {client.email}'
            })
            
        except Exception as e:
            print(f"Error sending email: {e}")
            return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ email'}), 500
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/data/properties_expanded.json')
def properties_json():
    """Serve properties JSON data"""
    try:
        properties = load_properties()
        return jsonify(properties)
    except Exception as e:
        print(f"Error serving properties JSON: {e}")
        return jsonify([]), 500

# Database initialization will be done after all imports

# Client Recommendations API endpoints
@app.route('/api/user/collections', methods=['GET'])
@login_required
def api_user_get_collections():
    """Get collections assigned to current user"""
    from models import Collection, ExcelProperty
    import json
    
    try:
        collections = Collection.query.filter_by(
            assigned_to_user_id=current_user.id
        ).order_by(Collection.created_at.desc()).all()
        
        collections_data = []
        for collection in collections:
            # Get manager info
            manager = collection.created_by
            manager_name = manager.full_name if manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            # Use manager's profile image if available, otherwise use first letter
            # Use manager's profile image if available and not randomuser.me, otherwise use first letter
            if manager and manager.profile_image and 'randomuser.me' not in manager.profile_image:
                # Convert relative path to absolute URL
                if manager.profile_image.startswith('http'):
                    manager_avatar = manager.profile_image
                else:
                    base_url = request.host_url.rstrip('/')
                    manager_avatar = f"{base_url}{manager.profile_image}"
            else:
                manager_avatar = manager_name[0].upper() if manager_name else '–ú'
            
            # Get properties with images from excel_properties table
            properties_data = []
            for prop in collection.properties[:4]:
                # Load property from database
                excel_prop = ExcelProperty.query.filter_by(inner_id=prop.property_id).first()
                if excel_prop:
                    # Get first photo from photos array
                    image_url = ''
                    if excel_prop.photos:
                        try:
                            photos_list = json.loads(excel_prop.photos) if isinstance(excel_prop.photos, str) else excel_prop.photos
                            image_url = photos_list[0] if photos_list and len(photos_list) > 0 else ''
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # Build title from property data
                    rooms_text = f"{excel_prop.object_rooms}-–∫–æ–º–Ω" if excel_prop.object_rooms and excel_prop.object_rooms > 0 else "–°—Ç—É–¥–∏—è"
                    area_text = f"{excel_prop.object_area} –º¬≤" if excel_prop.object_area else ""
                    title = f"{rooms_text}, {area_text}".strip(', ')
                    
                    properties_data.append({
                        'id': prop.property_id,
                        'image': image_url,
                        'title': title
                    })
            
            collections_data.append({
                'id': collection.id,
                'title': collection.title,
                'description': collection.description,
                'status': collection.status,
                'created_at': collection.created_at.strftime('%d.%m.%Y'),
                'manager_name': manager_name,
                'manager_avatar': manager_avatar,
                'properties_count': len(collection.properties),
                'properties': properties_data,
                'unique_url': collection.unique_url
            })
        
        print(f"üéØ Collections API: returning {len(collections_data)} collections")
        
        return jsonify({
            'success': True,
            'collections': collections_data
        })
        
    except Exception as e:
        print(f"‚ùå Error loading collections: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400

@login_required
def api_user_get_saved_searches():
    """Get saved searches for current user"""
    from models import SavedSearch
    
    try:
        # Get regular saved searches
        saved_searches = SavedSearch.query.filter_by(
            user_id=current_user.id
        ).order_by(SavedSearch.created_at.desc()).all()
        
        # Get sent searches from managers
        from models import SentSearch
        sent_searches = SentSearch.query.filter_by(
            client_id=current_user.id
        ).order_by(SentSearch.sent_at.desc()).all()
        
        searches_data = []
        
        # Add regular saved searches
        for search in saved_searches:
            filters = {}
            if search.filters:
                import json
                filters = json.loads(search.filters) if isinstance(search.filters, str) else search.filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.created_at.strftime('%d.%m.%Y'),
                'last_used': search.last_used.strftime('%d.%m.%Y') if search.last_used else None,
                'type': 'saved'
            })
        
        # Add sent searches from managers
        for search in sent_searches:
            filters = {}
            if search.additional_filters:
                import json
                filters = json.loads(search.additional_filters) if isinstance(search.additional_filters, str) else search.additional_filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.sent_at.strftime('%d.%m.%Y') if search.sent_at else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'last_used': search.applied_at.strftime('%d.%m.%Y') if search.applied_at else None,
                'type': 'sent',
                'from_manager': True
            })
        
        return jsonify({
            'success': True,
            'searches': searches_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendations', methods=['GET'])
@login_required
def api_user_get_recommendations():
    """Get recommendations for current user"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        print(f"DEBUG: Loading recommendations for user ID: {current_user.id}")
        
        # Get traditional recommendations
        recommendations = Recommendation.query.filter_by(
            client_id=current_user.id
        ).order_by(Recommendation.sent_at.desc()).all()
        
        print(f"DEBUG: Found {len(recommendations)} recommendations for user {current_user.id}")
        
        recommendations_data = []
        for rec in recommendations:
            rec_data = rec.to_dict()
            rec_data['manager_name'] = f"{rec.manager.first_name} {rec.manager.last_name}" if rec.manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            recommendations_data.append(rec_data)
        
        # Get sent searches from managers as recommendations  
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Convert sent searches to recommendation format
        for search in sent_searches:
            search_rec = {
                'id': f'search_{search.id}',
                'title': f'–ü–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {search.name}',
                'description': search.description or '–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –æ—Ç –≤–∞—à–µ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'recommendation_type': 'search',
                'item_id': str(search.id),
                'item_name': search.name,
                'manager_notes': f'–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {search.manager.name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'priority_level': 'high',
                'status': search.status,
                'viewed_at': search.viewed_at.isoformat() if search.viewed_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'manager_name': search.manager.name,
                'search_filters': search.additional_filters,
                'search_id': search.id
            }
            recommendations_data.append(search_rec)
        
        # Sort by creation date 
        recommendations_data.sort(key=lambda x: x.get('created_at', ''), reverse=True)
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/saved-searches/<int:search_id>')
@login_required
def get_saved_search_details(search_id):
    """Get saved search details for applying filters"""
    from models import SavedSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get the saved search
        saved_search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
        if not saved_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        return jsonify({
            'success': True,
            'id': saved_search.id,
            'name': saved_search.name,
            'description': saved_search.description,
            'search_filters': saved_search.additional_filters,
            'created_at': saved_search.created_at.isoformat() if saved_search.created_at else None
        })
        
    except Exception as e:
        print(f"Error getting saved search details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/sent-searches')
@login_required
def get_sent_searches():
    """Get sent searches from managers as recommendations"""
    from models import SentSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get sent searches
        sent_searches = SentSearch.query.filter_by(client_id=user_id).order_by(SentSearch.sent_at.desc()).all()
        
        # Format as recommendation-like objects
        search_list = []
        
        for search in sent_searches:
            search_list.append({
                'id': search.id,
                'name': search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'title': search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'description': search.description,
                'status': search.status or 'sent',
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'search_filters': search.additional_filters,
                'manager_id': search.manager_id,
                'recommendation_type': 'search'
            })
        
        return jsonify({
            'success': True,
            'sent_searches': search_list
        })
        
    except Exception as e:
        print(f"Error getting sent searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/sent-search/<int:search_id>')
@login_required
def get_sent_search_detail(search_id):
    """Get details of a specific sent search from manager"""
    from models import SentSearch
    import json
    
    try:
        # Get the specific sent search for this client using current_user from Flask-Login
        sent_search = SentSearch.query.filter_by(id=search_id, client_id=current_user.id).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Parse additional_filters if it's a JSON string
        filters = sent_search.additional_filters
        if isinstance(filters, str):
            try:
                filters = json.loads(filters)
            except json.JSONDecodeError:
                filters = {}
        elif filters is None:
            filters = {}
        
        return jsonify({
            'success': True,
            'search': {
                'id': sent_search.id,
                'name': sent_search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'description': sent_search.description,
                'additional_filters': filters,
                'status': sent_search.status or 'sent',
                'sent_at': sent_search.sent_at.isoformat() if sent_search.sent_at else None,
                'manager_id': sent_search.manager_id
            }
        })
        
    except Exception as e:
        print(f"Error getting sent search detail: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/viewed', methods=['POST'])
@login_required  
def api_mark_recommendation_viewed(rec_id):
    """Mark recommendation as viewed"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        # Handle search recommendations
        if str(rec_id).startswith('search_'):
            search_id = int(rec_id.replace('search_', ''))
            sent_search = SentSearch.query.filter_by(
                id=search_id, 
                client_id=current_user.id
            ).first()
            
            if not sent_search:
                return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
                
            if sent_search.status == 'sent':
                sent_search.status = 'viewed'
                sent_search.viewed_at = datetime.utcnow()
                db.session.commit()
            
            return jsonify({'success': True})
        
        # Handle traditional recommendations
        recommendation = Recommendation.query.filter_by(
            id=int(rec_id), 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        if recommendation.status == 'sent':
            recommendation.status = 'viewed'
            recommendation.viewed_at = datetime.utcnow()
            db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<int:rec_id>/dismiss', methods=['POST'])
@login_required
def api_dismiss_recommendation(rec_id):
    """Dismiss/hide recommendation"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        recommendation = Recommendation.query.filter_by(
            id=rec_id, 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        # Mark as dismissed
        recommendation.status = 'dismissed'
        recommendation.viewed_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/apply', methods=['POST'])
@login_required  
def api_apply_search_recommendation(rec_id):
    """Apply search recommendation - redirect to properties with filters"""
    from models import SentSearch
    from datetime import datetime
    import json
    
    try:
        # Handle search recommendations only
        if not str(rec_id).startswith('search_'):
            return jsonify({'success': False, 'error': '–¢–æ–ª—å–∫–æ –ø–æ–∏—Å–∫–∏ –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å'}), 400
            
        search_id = int(rec_id.replace('search_', ''))
        sent_search = SentSearch.query.filter_by(
            id=search_id, 
            client_id=current_user.id
        ).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Update search status
        sent_search.applied_at = datetime.utcnow()
        if sent_search.status == 'sent':
            sent_search.status = 'applied'
        db.session.commit()
        
        # Parse filters from the search
        filters = {}
        if sent_search.additional_filters:
            try:
                filters = json.loads(sent_search.additional_filters)
            except json.JSONDecodeError:
                pass
        
        return jsonify({
            'success': True, 
            'filters': filters
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendation-categories', methods=['GET'])
@login_required
def api_user_get_categories():
    """Get all categories that have recommendations for current user"""
    from models import RecommendationCategory
    
    try:
        categories = RecommendationCategory.query.filter_by(
            client_id=current_user.id
        ).filter(RecommendationCategory.recommendations_count > 0).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# User Comparison Count API Endpoints
@app.route('/api/user/comparison/properties/count')
@login_required
def api_user_comparison_properties_count():
    """Get count of properties in comparison for current user"""
    from models import ComparisonProperty, UserComparison
    
    try:
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'count': 0
            })
        
        # Count properties in this comparison
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'count': count
        })
        
    except Exception as e:
        print(f"Error getting user comparison properties count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

@app.route('/api/user/comparison/complexes/count')
@login_required
def api_user_comparison_complexes_count():
    """Get count of complexes in comparison for current user"""
    from models import ComparisonComplex, UserComparison
    
    try:
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'count': 0
            })
        
        # Count complexes in this comparison
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'count': count
        })
        
    except Exception as e:
        print(f"Error getting user comparison complexes count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

# ========================================
# USER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/user/comparison/property/add', methods=['POST'])
@login_required
def api_user_comparison_property_add():
    """Add property to user's comparison"""
    from models import UserComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='–ú–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–û–±—ä–µ–∫—Ç —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –æ–±—ä–µ–∫—Ç–∞ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add property to comparison
        comparison_property = ComparisonProperty(
            user_comparison_id=user_comparison.id,
            property_id=property_id,
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/property/remove', methods=['POST'])
@login_required
def api_user_comparison_property_remove():
    """Remove property from user's comparison"""
    from models import UserComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete property
        comparison_property = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if comparison_property:
            db.session.delete(comparison_property)
            db.session.commit()
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/complex/add', methods=['POST'])
@login_required
def api_user_comparison_complex_add():
    """Add residential complex to user's comparison"""
    from models import UserComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='–ú–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–ñ–ö —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –ñ–ö –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding complex to user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/complex/remove', methods=['POST'])
@login_required
def api_user_comparison_complex_remove():
    """Remove residential complex from user's comparison"""
    from models import UserComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete complex
        comparison_complex = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if comparison_complex:
            db.session.delete(comparison_complex)
            db.session.commit()
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/load')
def api_user_comparison_load():
    """Load all comparisons for current user from database"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex
    
    try:
        # Handle unauthenticated users - return empty arrays instead of redirecting
        if not current_user.is_authenticated:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Get all property IDs
        properties = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        property_ids = [prop.property_id for prop in properties]
        
        # Get all complex IDs
        complexes = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        complex_ids = [comp.complex_id for comp in complexes]
        
        return jsonify({
            'success': True,
            'properties': property_ids,
            'complexes': complex_ids,
            'properties_count': len(property_ids),
            'complexes_count': len(complex_ids)
        })
        
    except Exception as e:
        print(f"Error loading user comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/comparison/clear', methods=['POST'])
def api_comparison_clear():
    """Clear all comparisons for current user"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex
    
    try:
        # Handle unauthenticated users
        if not current_user.is_authenticated:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏—è –æ—á–∏—â–µ–Ω—ã (–ª–æ–∫–∞–ª—å–Ω–æ)'
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if user_comparison:
            # Delete all properties
            ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            # Delete all complexes
            ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–í—Å–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –æ—á–∏—â–µ–Ω—ã'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing comparisons: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# PUBLIC COMPARISON DELETE ENDPOINTS (No Auth Required)
# ========================================

@app.route('/api/comparison/remove-property', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_property():
    """Remove property from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonProperty
    
    try:
        # Get property_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'error': 'Property ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        manager_id = session.get('manager_id')
        if manager_id and not deleted:
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=manager_id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error removing property from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/comparison/remove-complex', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_complex():
    """Remove complex from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonComplex
    
    try:
        # Get complex_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'error': 'Complex ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        manager_id = session.get('manager_id')
        if manager_id and not deleted:
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=manager_id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error removing complex from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# MANAGER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/manager/comparison/property/add', methods=['POST'])
@manager_required
def api_manager_comparison_property_add():
    """Add property to manager's comparison"""
    from models import ManagerComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        manager_id = session.get('manager_id')
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=manager_id,
                name='–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–û–±—ä–µ–∫—Ç —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –æ–±—ä–µ–∫—Ç–∞ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add property to comparison
        comparison_property = ComparisonProperty(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id,
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/property/remove', methods=['POST'])
@manager_required
def api_manager_comparison_property_remove():
    """Remove property from manager's comparison"""
    from models import ManagerComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        manager_id = session.get('manager_id')
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete property
        comparison_property = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id
        ).first()
        
        if comparison_property:
            db.session.delete(comparison_property)
            db.session.commit()
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/add', methods=['POST'])
@manager_required
def api_manager_comparison_complex_add():
    """Add residential complex to manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        manager_id = session.get('manager_id')
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=manager_id,
                name='–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–ñ–ö —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –ñ–ö –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding complex to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/remove', methods=['POST'])
@manager_required
def api_manager_comparison_complex_remove():
    """Remove residential complex from manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        manager_id = session.get('manager_id')
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete complex
        comparison_complex = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        if comparison_complex:
            db.session.delete(comparison_complex)
            db.session.commit()
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/load')
def api_manager_comparison_load():
    """Load all comparisons for current manager from database (no auth required to prevent redirects)"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        manager_id = session.get('manager_id')
        
        # If not a manager, return empty data instead of redirecting
        if not manager_id:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Get all property IDs
        properties = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).all()
        property_ids = [prop.property_id for prop in properties]
        
        # Get all complex IDs
        complexes = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).all()
        complex_ids = [comp.complex_id for comp in complexes]
        
        return jsonify({
            'success': True,
            'properties': property_ids,
            'complexes': complex_ids,
            'properties_count': len(property_ids),
            'complexes_count': len(complex_ids)
        })
        
    except Exception as e:
        print(f"Error loading manager comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# PHONE VERIFICATION
# ========================================

@app.route('/api/user/phone/send-verification', methods=['POST'])
@login_required
def send_phone_verification():
    """Send verification code to user's phone"""
    from models import User
    import random
    from datetime import datetime, timedelta
    from scripts.sms_service import send_verification_code_sms
    
    try:
        data = request.get_json()
        phone = data.get('phone')
        
        if not phone:
            return jsonify({'success': False, 'message': '–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
        
        # Generate 6-digit verification code
        code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
        
        # Save code and expiration to user
        current_user.phone = phone
        current_user.phone_verification_code = code
        current_user.phone_verification_expires = datetime.utcnow() + timedelta(minutes=10)
        db.session.commit()
        
        # Send SMS
        sms_sent = send_verification_code_sms(phone, code)
        
        if sms_sent:
            return jsonify({
                'success': True,
                'message': '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à –Ω–æ–º–µ—Ä'
            })
        else:
            return jsonify({
                'success': False,
                'message': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
            }), 500
            
    except Exception as e:
        db.session.rollback()
        print(f"Error sending verification code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/phone/verify-code', methods=['POST'])
@login_required
def verify_phone_code():
    """Verify phone number with code"""
    from models import User
    from datetime import datetime
    
    try:
        data = request.get_json()
        code = data.get('code')
        
        if not code:
            return jsonify({'success': False, 'message': '–ö–æ–¥ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
        
        # Check if code matches and not expired
        if not current_user.phone_verification_code:
            return jsonify({'success': False, 'message': '–ö–æ–¥ –Ω–µ –±—ã–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω'}), 400
        
        if current_user.phone_verification_expires < datetime.utcnow():
            return jsonify({'success': False, 'message': '–ö–æ–¥ –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π.'}), 400
        
        if current_user.phone_verification_code != code:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥'}), 400
        
        # Mark phone as verified
        current_user.phone_verified = True
        current_user.phone_verification_code = None
        current_user.phone_verification_expires = None
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–¢–µ–ª–µ—Ñ–æ–Ω —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error verifying phone code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

# ========================================
# PRESENTATION SHARING (Manager to Client)
# ========================================

@app.route('/api/manager/collection/<int:collection_id>/assign-client', methods=['POST'])
@manager_required
def assign_client_to_presentation(collection_id):
    """Assign client to presentation"""
    from models import Collection, User
    
    try:
        manager_id = session.get('manager_id')
        data = request.get_json()
        
        if not data or 'client_id' not in data:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        client_id = data['client_id']
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=manager_id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Verify client exists and is assigned to this manager
        client = User.query.filter_by(id=client_id, assigned_manager_id=manager_id).first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω –∑–∞ –≤–∞–º–∏'}), 404
        
        # Assign client to presentation
        collection.assigned_to_user_id = client_id
        collection.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–ö–ª–∏–µ–Ω—Ç {client.full_name} –Ω–∞–∑–Ω–∞—á–µ–Ω –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error assigning client to presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/collection/<int:collection_id>/send-to-client', methods=['POST'])
@manager_required
def send_presentation_to_client(collection_id):
    """Send presentation from manager to client's personal dashboard"""
    from models import Collection, User, UserNotification
    
    try:
        manager_id = session.get('manager_id')
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=manager_id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        if not collection.assigned_to_user_id:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
        
        if len(collection.properties) == 0:
            return jsonify({'success': False, 'error': '–í –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 400
        
        # Update collection status
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=collection.assigned_to_user_id,
            title='üì¶ –ù–æ–≤–∞—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
            message=f'–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é "{collection.title}" —Å {len(collection.properties)} –æ–±—ä–µ–∫—Ç–∞–º–∏',
            notification_type='success',
            icon='fas fa-gift',
            action_url=f'/dashboard#presentations'
        )
        db.session.add(notification)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        from models import UserActivity
        UserActivity.log_activity(
            user_id=collection.assigned_to_user_id,
            activity_type='presentation_received',
            description=f'–ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–∞—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {collection.title} ({len(collection.properties)} –æ–±—ä–µ–∫—Ç–æ–≤)'
        )
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç—É'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending presentation to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/presentation/<int:presentation_id>/delete', methods=['DELETE'])
@login_required
def delete_user_presentation(presentation_id):
    """Delete presentation from user's dashboard"""
    from models import Collection
    
    try:
        # Get collection
        collection = Collection.query.filter_by(
            id=presentation_id,
            assigned_to_user_id=current_user.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Delete the collection
        db.session.delete(collection)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/deals')
def api_manager_deals_count():
    """Get deals data for manager with count - used for preloading deals tab counter"""
    from models import Deal
    
    try:
        manager_id = session.get('manager_id')
        
        # If not a manager, return empty data
        if not manager_id:
            return jsonify({
                'success': True,
                'deals': [],
                'total': 0,
                'is_manager': False
            })
        
        # Get all deals for this manager
        deals = Deal.query.filter_by(manager_id=manager_id).all()
        
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'client_name': deal.client.full_name if deal.client else 'Unknown',
                'property_description': deal.property_description,
                'property_price': deal.property_price,
                'cashback_amount': deal.cashback_amount,
                'status': deal.status,
                'created_at': deal.created_at.isoformat() if deal.created_at else None
            })
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': True
        })
        
    except Exception as e:
        print(f"Error getting deals count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/comparison/count')
def api_manager_comparison_count():
    """Get count of items in manager comparison for navigation counter"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        manager_id = session.get('manager_id')
        
        # If not a manager, return zero count
        if not manager_id:
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=manager_id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        # Count properties and complexes
        properties_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        complexes_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        total_count = properties_count + complexes_count
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': total_count
        })
        
    except Exception as e:
        print(f"Error getting manager comparison count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/generate-comparison-pdf', methods=['POST'])
@csrf.exempt
def api_manager_generate_comparison_pdf():
    """Generate HTML comparison document for manager to send to client"""
    try:
        from models import Manager
        from datetime import datetime
        
        data = request.get_json()
        
        recipient_name = data.get('recipient_name', '–ö–ª–∏–µ–Ω—Ç')
        message_notes = data.get('message_notes', '')
        hide_complex_names = data.get('hide_complex_names', False)
        hide_developer_names = data.get('hide_developer_names', False)
        hide_addresses = data.get('hide_addresses', False)
        properties = data.get('properties', [])
        complexes = data.get('complexes', [])
        
        # Get current manager info
        manager_id = session.get('manager_id')
        manager = Manager.query.get(manager_id) if manager_id else None
        manager_name = manager.full_name if manager else "InBack –ú–µ–Ω–µ–¥–∂–µ—Ä"
        manager_phone = manager.phone if manager else "8 (862) 266-62-16"
        manager_email = manager.email if manager else "info@inback.ru"
        
        # Get manager avatar with full URL for downloadable HTML
        if manager and manager.profile_image:
            # If it's already a full URL (http/https), use it
            if manager.profile_image.startswith('http'):
                manager_avatar = manager.profile_image
            else:
                # Convert relative path to absolute URL
                base_url = request.host_url.rstrip('/')
                manager_avatar = f"{base_url}{manager.profile_image}"
        else:
            manager_avatar = "https://randomuser.me/api/portraits/men/45.jpg"
        
        # Get current date and time
        now = datetime.now()
        date_str = now.strftime('%d.%m.%Y')
        time_str = now.strftime('%H:%M')
        
        print(f"üìÑ Generating comparison PDF: {len(properties)} properties, {len(complexes)} complexes")
        
        # Build HTML document for comparison
        html_content = f"""<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ - {recipient_name}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.6;
            color: #000;
            background: #fff;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }}
        
        /* Print styles */
        @media print {{
            body {{
                padding: 20px;
            }}
            .no-print {{
                display: none !important;
            }}
            .page-break {{
                page-break-after: always;
            }}
        }}
        
        /* Header */
        .header {{
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }}
        
        .header h1 {{
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }}
        
        .header .subtitle {{
            font-size: 18px;
            color: #555;
            margin-bottom: 20px;
        }}
        
        /* Manager info */
        .manager-info {{
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 8px;
        }}
        
        .manager-avatar {{
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #333;
        }}
        
        .manager-details {{
            text-align: left;
        }}
        
        .manager-details p {{
            margin: 5px 0;
            font-size: 14px;
        }}
        
        .manager-details strong {{
            font-weight: bold;
        }}
        
        /* Recipient info */
        .recipient-info {{
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            font-size: 16px;
        }}
        
        .recipient-info strong {{
            font-weight: bold;
        }}
        
        /* Notes */
        .notes {{
            margin: 20px 0;
            padding: 15px;
            background: #f0f0f0;
            border-left: 4px solid #333;
        }}
        
        .notes strong {{
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }}
        
        /* Section title */
        .section-title {{
            font-size: 20px;
            font-weight: bold;
            margin: 30px 0 15px 0;
            padding: 10px 0;
            border-bottom: 2px solid #000;
        }}
        
        /* Table */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 12px;
        }}
        
        table th {{
            background: #f0f0f0;
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-weight: bold;
        }}
        
        table td {{
            border: 1px solid #ddd;
            padding: 10px;
            vertical-align: top;
        }}
        
        table tr:nth-child(even) {{
            background: #f9f9f9;
        }}
        
        table .label-col {{
            font-weight: bold;
            background: #f5f5f5;
            width: 180px;
        }}
        
        /* Footer */
        .footer {{
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #000;
            font-size: 14px;
        }}
        
        .footer p {{
            margin: 5px 0;
        }}
        
        /* Print button */
        .print-btn {{
            position: fixed;
            top: 20px;
            right: 20px;
            background: #000;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1000;
        }}
        
        .print-btn:hover {{
            background: #333;
        }}
    </style>
</head>
<body>
    <button onclick="window.print()" class="print-btn no-print">üñ®Ô∏è –ü–µ—á–∞—Ç—å</button>
    
    <div class="header">
        <h1>InBack –ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å</h1>
        <div class="subtitle">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏</div>
    </div>
    
    <div class="manager-info">
        <img src="{manager_avatar}" alt="–§–æ—Ç–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞" class="manager-avatar">
        <div class="manager-details">
            <p><strong>–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}</strong></p>
            <p>–¢–µ–ª–µ—Ñ–æ–Ω: {manager_phone}</p>
            <p>Email: {manager_email}</p>
        </div>
    </div>
    
    <div class="recipient-info">
        <p><strong>–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –¥–ª—è: {recipient_name}</strong></p>
        <p>–î–∞—Ç–∞: {date_str} –≤ {time_str}</p>
    </div>
"""
        
        # Add notes if provided
        if message_notes:
            html_content += f"""
    <div class="notes">
        <strong>–ó–∞–º–µ—Ç–∫–∏:</strong>
        <p>{message_notes}</p>
    </div>
"""
        
        # Add properties comparison table (vertical layout)
        if properties and len(properties) > 0:
            html_content += """
    <h2 class="section-title">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞</th>"""
            
            # Add column headers for each property
            for i, prop in enumerate(properties, 1):
                html_content += f"\n                <th>–û–±—ä–µ–∫—Ç {i}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            
            # Row: –ù–∞–∑–≤–∞–Ω–∏–µ
            html_content += """
            <tr>
                <td class="label-col">–ù–∞–∑–≤–∞–Ω–∏–µ</td>"""
            for prop in properties:
                html_content += f"\n                <td>{prop.get('property_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ñ–ö (if not hidden)
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">–ñ–ö</td>"""
                for prop in properties:
                    html_content += f"\n                <td>{prop.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</td>"
                html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞</td>"""
            for prop in properties:
                price = prop.get('property_price', 0)
                html_content += f"\n                <td>{price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"
            
            # Row: –ü–ª–æ—â–∞–¥—å
            html_content += """
            <tr>
                <td class="label-col">–ü–ª–æ—â–∞–¥—å</td>"""
            for prop in properties:
                size = prop.get('property_size', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{size} –º¬≤</td>"
            html_content += "\n            </tr>"
            
            # Row: –ö–æ–º–Ω–∞—Ç—ã
            html_content += """
            <tr>
                <td class="label-col">–ö–æ–º–Ω–∞—Ç—ã</td>"""
            for prop in properties:
                rooms = prop.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                # Show "–°—Ç—É–¥–∏—è" instead of "0"
                if rooms == 0 or rooms == '0':
                    rooms_display = '–°—Ç—É–¥–∏—è'
                else:
                    rooms_display = rooms
                html_content += f"\n                <td>{rooms_display}</td>"
            html_content += "\n            </tr>"
            
            # Row: –≠—Ç–∞–∂
            html_content += """
            <tr>
                <td class="label-col">–≠—Ç–∞–∂</td>"""
            for prop in properties:
                floor = prop.get('floor', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{floor}</td>"
            html_content += "\n            </tr>"
            
            # Row: –í—Å–µ–≥–æ —ç—Ç–∞–∂–µ–π
            html_content += """
            <tr>
                <td class="label-col">–í—Å–µ–≥–æ —ç—Ç–∞–∂–µ–π</td>"""
            for prop in properties:
                total_floors = prop.get('total_floors', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{total_floors}</td>"
            html_content += "\n            </tr>"
            
            # Row: –†–∞–π–æ–Ω
            html_content += """
            <tr>
                <td class="label-col">–†–∞–π–æ–Ω</td>"""
            for prop in properties:
                district = prop.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{district}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫</td>"""
                for prop in properties:
                    developer = prop.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: –ê–¥—Ä–µ—Å (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">–ê–¥—Ä–µ—Å</td>"""
                for prop in properties:
                    address = prop.get('address', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add complexes comparison table (vertical layout)
        if complexes and len(complexes) > 0:
            html_content += """
    <div class="page-break"></div>
    <h2 class="section-title">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∂–∏–ª—ã—Ö –∫–æ–º–ø–ª–µ–∫—Å–æ–≤</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞</th>"""
            
            # Add column headers for each complex
            for i, complex_data in enumerate(complexes, 1):
                html_content += f"\n                <th>–ñ–ö {i}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            
            # Row: –ù–∞–∑–≤–∞–Ω–∏–µ –ñ–ö
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">–ù–∞–∑–≤–∞–Ω–∏–µ –ñ–ö</td>"""
                for complex_data in complexes:
                    name = complex_data.get('name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td><strong>{name}</strong></td>"
                html_content += "\n            </tr>"
            
            # Row: –ö–ª–∞—Å—Å –∂–∏–ª—å—è
            html_content += """
            <tr>
                <td class="label-col">–ö–ª–∞—Å—Å –∂–∏–ª—å—è</td>"""
            for complex_data in complexes:
                obj_class = complex_data.get('object_class', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{obj_class}</td>"
            html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞ –æ—Ç
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞ –æ—Ç</td>"""
            for complex_data in complexes:
                min_price = complex_data.get('min_price', 0)
                html_content += f"\n                <td>{min_price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞ –¥–æ
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞ –¥–æ</td>"""
            for complex_data in complexes:
                max_price = complex_data.get('max_price', 0)
                html_content += f"\n                <td>{max_price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"
            
            # Row: –°—Ä–æ–∫ —Å–¥–∞—á–∏
            html_content += """
            <tr>
                <td class="label-col">–°—Ä–æ–∫ —Å–¥–∞—á–∏</td>"""
            for complex_data in complexes:
                completion = complex_data.get('completion_date', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{completion}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ö–µ—à–±–µ–∫
            html_content += """
            <tr>
                <td class="label-col">–ö–µ—à–±–µ–∫</td>"""
            for complex_data in complexes:
                cashback_rate = complex_data.get('cashback_rate', 0)
                html_content += f"\n                <td>{cashback_rate}%</td>"
            html_content += "\n            </tr>"
            
            # Row: –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫</td>"""
                for complex_data in complexes:
                    developer = complex_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: –ê–¥—Ä–µ—Å (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">–ê–¥—Ä–µ—Å</td>"""
                for complex_data in complexes:
                    address = complex_data.get('address', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add footer
        html_content += f"""
    <div class="footer">
        <p><strong>InBack.ru</strong> - –≤–∞—à –∫–µ—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏</p>
        <p>–î–æ–∫—É–º–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω {date_str} –≤ {time_str}</p>
    </div>
</body>
</html>
"""
        
        # Return HTML for download
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html; charset=utf-8'
        )
        
        # Set download filename with safe ASCII characters
        from datetime import datetime
        from unidecode import unidecode
        timestamp = datetime.now().strftime('%Y-%m-%d')
        # Convert recipient name to ASCII to avoid encoding issues
        safe_name = unidecode(recipient_name).replace(' ', '_')
        ascii_filename = f'Sravnenie_{safe_name}_{timestamp}.html'
        
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        print(f"‚úÖ Comparison HTML generated successfully")
        return response
        
    except Exception as e:
        print(f"‚ùå Error generating comparison PDF: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Failed to generate comparison document', 'details': str(e)}), 500

@app.route('/api/recommendations/<int:rec_id>/respond', methods=['POST'])
@login_required
def api_respond_to_recommendation(rec_id):
    """Client responds to recommendation with interest/not interested"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        data = request.get_json()
        response_type = data.get('response')  # 'interested' or 'not_interested'
        
        if response_type not in ['interested', 'not_interested']:
            return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –æ—Ç–≤–µ—Ç–∞'}), 400
            
        recommendation = Recommendation.query.filter_by(
            id=rec_id,
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        recommendation.status = response_type
        recommendation.client_response = response_type
        recommendation.responded_at = datetime.utcnow()
        
        db.session.commit()
        
        # Notify manager about client response
        if recommendation.manager:
            try:
                from email_service import send_notification
                subject = f"–û—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é: {recommendation.title}"
                message = f"""
–ö–ª–∏–µ–Ω—Ç {current_user.full_name} –æ—Ç–≤–µ—Ç–∏–ª –Ω–∞ –≤–∞—à—É —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é:

–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: {recommendation.title}
–û–±—ä–µ–∫—Ç: {recommendation.item_name}
–û—Ç–≤–µ—Ç: {'–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ' if response_type == 'interested' else '–ù–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ'}

–í—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
                send_notification(
                    recommendation.manager.email,
                    subject,
                    message,
                    notification_type="client_response"
                )
            except Exception as e:
                print(f"Error sending notification to manager: {e}")
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/manager/recommendation-categories/<int:client_id>', methods=['GET'])
def api_get_recommendation_categories(client_id):
    """Get recommendation categories for a specific client"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        categories = RecommendationCategory.query.filter_by(
            manager_id=manager_id,
            client_id=client_id,
            is_active=True
        ).order_by(RecommendationCategory.last_used.desc()).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count,
                'last_used': category.last_used.strftime('%d.%m.%Y') if category.last_used else '',
                'created_at': category.created_at.strftime('%d.%m.%Y') if category.created_at else ''
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendation-categories', methods=['POST'])
def api_create_recommendation_category():
    """Create new recommendation category"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        data = request.get_json()
        category_name = data.get('name', '').strip()
        client_id = data.get('client_id')
        description = data.get('description', '').strip()
        color = data.get('color', 'blue')
        
        if not category_name or not client_id:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –∫–ª–∏–µ–Ω—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}), 400
        
        # Check if category with this name already exists for this client
        existing = RecommendationCategory.query.filter_by(
            manager_id=manager_id,
            client_id=client_id,
            name=category_name,
            is_active=True
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Create new category
        category = RecommendationCategory(
            name=category_name,
            description=description,
            manager_id=manager_id,
            client_id=client_id,
            color=color
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': 0,
                'created_at': category.created_at.strftime('%d.%m.%Y')
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/all-categories', methods=['GET'])
def api_manager_all_categories():
    """Get all categories created by this manager"""
    from models import RecommendationCategory, User
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        categories = db.session.query(
            RecommendationCategory, 
            User.email.label('client_email')
        ).outerjoin(
            User, RecommendationCategory.client_id == User.id
        ).filter(
            RecommendationCategory.manager_id == manager_id
        ).order_by(
            RecommendationCategory.last_used.desc().nulls_last(),
            RecommendationCategory.created_at.desc()
        ).all()
        
        category_data = []
        for category, client_email in categories:
            category_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'client_email': client_email or '–û–±—â–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è',
                'recommendations_count': category.recommendations_count,
                'is_active': category.is_active,
                'last_used': category.last_used.isoformat() if category.last_used else None,
                'created_at': category.created_at.isoformat()
            })
        
        return jsonify({
            'success': True,
            'categories': category_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/global', methods=['POST'])
def api_manager_create_global_category():
    """Create a new global category template"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    data = request.get_json()
    name = data.get('name', '').strip()
    description = data.get('description', '').strip()
    
    if not name:
        return jsonify({'success': False, 'error': '–£–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏'}), 400
    
    try:
        # Create a template category without specific client
        category = RecommendationCategory(
            name=name,
            description=description,
            manager_id=manager_id,
            client_id=None,  # Global template
            is_template=True,
            recommendations_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description
            }
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/<int:category_id>/toggle', methods=['POST'])
def api_manager_toggle_category(category_id):
    """Toggle category active status"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    data = request.get_json()
    is_active = data.get('is_active', True)
    
    try:
        category = RecommendationCategory.query.filter_by(
            id=category_id,
            manager_id=manager_id
        ).first()
        
        if not category:
            return jsonify({'success': False, 'error': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        category.is_active = is_active
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Dashboard API endpoints
@app.route('/api/manager/welcome-message', methods=['GET'])
@manager_required
def api_manager_welcome_message():
    """Get adaptive welcome message based on recent activity"""
    from models import User, Recommendation, Collection, SavedSearch, Manager
    from sqlalchemy import func, desc
    from datetime import datetime, timedelta
    
    manager_id = session.get('manager_id')
    current_manager = Manager.query.get(manager_id)
    
    if not current_manager:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        now = datetime.now()
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        week_start = today_start - timedelta(days=7)
        
        # Get recent activity counts
        recent_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == manager_id,
            Recommendation.created_at >= week_start
        ).count()
        
        today_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == manager_id,
            Recommendation.created_at >= today_start
        ).count()
        
        recent_collections = Collection.query.filter(
            Collection.created_by_manager_id == manager_id,
            Collection.created_at >= week_start
        ).count()
        
        total_clients = User.query.filter_by(assigned_manager_id=manager_id).count()
        
        new_clients_today = User.query.filter(
            User.assigned_manager_id == manager_id,
            User.created_at >= today_start
        ).count()
        
        # Get last activity time (use created_at if last_login_at doesn't exist)
        last_activity = getattr(current_manager, 'last_login_at', None) or current_manager.created_at
        hours_since_last_login = (now - last_activity).total_seconds() / 3600 if last_activity else 0
        
        # Get most recent activity
        latest_recommendation = Recommendation.query.filter_by(manager_id=manager_id).order_by(desc(Recommendation.created_at)).first()
        latest_collection = Collection.query.filter_by(created_by_manager_id=manager_id).order_by(desc(Collection.created_at)).first()
        
        # Generate adaptive message based on activity patterns
        messages = []
        
        # Time-based greeting
        hour = now.hour
        if 5 <= hour < 12:
            time_greeting = "–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ"
        elif 12 <= hour < 18:
            time_greeting = "–î–æ–±—Ä—ã–π –¥–µ–Ω—å"
        elif 18 <= hour < 23:
            time_greeting = "–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä"
        else:
            time_greeting = "–î–æ–±—Ä–æ–π –Ω–æ—á–∏"
        
        first_name = current_manager.full_name.split()[0] if current_manager.full_name else '–ö–æ–ª–ª–µ–≥–∞'
        
        # Activity-based messages
        if hours_since_last_login >= 24:
            messages.append(f"{time_greeting}, {first_name}! –†–∞–¥—ã –≤–∏–¥–µ—Ç—å –≤–∞—Å —Å–Ω–æ–≤–∞.")
            if recent_recommendations > 0:
                messages.append(f"–ó–∞ –≤—Ä–µ–º—è –≤–∞—à–µ–≥–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {recent_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.")
        elif hours_since_last_login >= 8:
            messages.append(f"{time_greeting}, {first_name}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ.")
        else:
            messages.append(f"{time_greeting}, {first_name}!")
        
        # Recent activity highlights
        if today_recommendations > 0:
            messages.append(f"–°–µ–≥–æ–¥–Ω—è –≤—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ {today_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π - –æ—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!")
        elif recent_recommendations > 0:
            messages.append(f"–ù–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ –≤—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ {recent_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –∫–ª–∏–µ–Ω—Ç–∞–º.")
        
        if new_clients_today > 0:
            messages.append(f"–£ –≤–∞—Å {new_clients_today} –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —Å–µ–≥–æ–¥–Ω—è.")
        
        if recent_collections > 0:
            messages.append(f"–°–æ–∑–¥–∞–Ω–æ {recent_collections} –Ω–æ–≤—ã—Ö –ø–æ–¥–±–æ—Ä–æ–∫ –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ.")
        
        # Motivational suggestions based on activity
        if recent_recommendations == 0 and recent_collections == 0:
            messages.append("–ì–æ—Ç–æ–≤—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–±–æ—Ä–∫—É –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤?")
        elif total_clients > 0 and recent_recommendations < 3:
            messages.append("–í–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∞–∫—Ç–∏–≤–Ω—ã–º –∫–ª–∏–µ–Ω—Ç–∞–º?")
        
        # Default fallback
        if len(messages) == 1:  # Only greeting
            messages.append("–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ.")
        
        # Activity context for additional UI hints
        activity_context = {
            'has_recent_activity': recent_recommendations > 0 or recent_collections > 0,
            'needs_attention': total_clients > 0 and recent_recommendations == 0,
            'high_activity': recent_recommendations >= 5 or recent_collections >= 3,
            'new_day': hours_since_last_login >= 8,
            'latest_recommendation_date': latest_recommendation.created_at.strftime('%d.%m.%Y') if latest_recommendation else None,
            'latest_collection_date': latest_collection.created_at.strftime('%d.%m.%Y') if latest_collection else None
        }
        
        return jsonify({
            'success': True,
            'messages': messages,
            'context': activity_context,
            'stats': {
                'recent_recommendations': recent_recommendations,
                'today_recommendations': today_recommendations,
                'recent_collections': recent_collections,
                'total_clients': total_clients,
                'new_clients_today': new_clients_today
            }
        })
        
    except Exception as e:
        print(f"Error generating welcome message: {e}")
        return jsonify({
            'success': True,
            'messages': [f"{time_greeting}, {first_name}!", "–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏"],
            'context': {'has_recent_activity': False},
            'stats': {}
        })

@app.route('/api/manager/dashboard-stats', methods=['GET'])
@login_required
@manager_required
def api_manager_dashboard_stats():
    """Get manager dashboard statistics"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        # Count clients assigned to this manager
        clients_count = User.query.filter_by(assigned_manager_id=manager_id).count()
        
        # Count recommendations sent by this manager
        recommendations_count = Recommendation.query.filter_by(manager_id=manager_id).count()
        
        # Count recommendations sent this month
        from datetime import datetime
        month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == manager_id,
            Recommendation.sent_at >= month_start
        ).count()
        
        # Collections count (placeholder for now)
        collections_count = 5
        
        return jsonify({
            'success': True,
            'clients_count': clients_count,
            'recommendations_count': monthly_recommendations,
            'total_recommendations': recommendations_count,
            'collections_count': collections_count
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/activity-feed', methods=['GET'])
@manager_required
def api_manager_activity_feed():
    """Get manager activity feed"""
    from models import Recommendation, User, ManagerNotification
    from datetime import datetime, timedelta
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        # Get recent activities (recommendations sent)
        from sqlalchemy.orm import joinedload
        recent_recommendations = Recommendation.query.filter_by(
            manager_id=manager_id
        ).options(joinedload(Recommendation.client)).order_by(Recommendation.sent_at.desc()).limit(10).all()
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        recent_notifications = ManagerNotification.query.filter_by(
            manager_id=manager_id
        ).order_by(ManagerNotification.created_at.desc()).limit(15).all()
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
        def format_time_ago(timestamp):
            time_diff = datetime.utcnow() - timestamp
            if time_diff.days > 0:
                return f"{time_diff.days} –¥–Ω. –Ω–∞–∑–∞–¥"
            elif time_diff.seconds > 3600:
                return f"{time_diff.seconds // 3600} —á. –Ω–∞–∑–∞–¥"
            else:
                return f"{time_diff.seconds // 60} –º–∏–Ω. –Ω–∞–∑–∞–¥"
        
        # –°–æ–∑–¥–∞–µ–º –æ–±—â–∏–π —Å–ø–∏—Å–æ–∫ —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
        all_activities = []
        
        # –î–æ–±–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        for notification in recent_notifications:
            all_activities.append({
                'timestamp': notification.created_at,
                'activity': {
                    'title': notification.title,
                    'description': notification.message,
                    'time_ago': format_time_ago(notification.created_at),
                    'icon': 'eye' if notification.notification_type == 'presentation_view' else 'bell',
                    'color': 'purple' if notification.notification_type == 'presentation_view' else 'gray',
                    'is_read': notification.is_read,
                    'notification_id': notification.id,
                    'type': 'notification'
                }
            })
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        for rec in recent_recommendations:
            client_name = rec.client.full_name if rec.client and hasattr(rec.client, 'full_name') else '–ö–ª–∏–µ–Ω—Ç'
            all_activities.append({
                'timestamp': rec.sent_at,
                'activity': {
                    'title': f'–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è',
                    'description': f'{rec.title} –¥–ª—è {client_name}',
                    'time_ago': format_time_ago(rec.sent_at),
                    'icon': 'paper-plane',
                    'color': 'blue',
                    'type': 'recommendation'
                }
            })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        all_activities.sort(key=lambda x: x['timestamp'], reverse=True)
        activities = [item['activity'] for item in all_activities[:10]]  # –ë–µ—Ä–µ–º —Ç–æ–ø 10
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ–º–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π –º–∞–ª–æ
        if len(activities) < 2:
            activities.extend([
                {
                    'title': '–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω',
                    'description': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –≤ —Å–∏—Å—Ç–µ–º–µ',
                    'time_ago': '2 —á. –Ω–∞–∑–∞–¥',
                    'icon': 'user-plus',
                    'color': 'green'
                },
                {
                    'title': '–ö–ª–∏–µ–Ω—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é',
                    'description': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤ –æ—Ç–∫—Ä—ã–ª —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é –ø–æ –ñ–ö "–°–æ–ª–Ω–µ—á–Ω—ã–π"',
                    'time_ago': '4 —á. –Ω–∞–∑–∞–¥',
                    'icon': 'eye',
                    'color': 'purple'
                }
            ])
        
        return jsonify({
            'success': True,
            'activities': activities
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/top-clients', methods=['GET'])
@login_required
@manager_required
def api_manager_top_clients():
    """Get top clients by interactions"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    # Check if user is authenticated as manager
    manager_id = session.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    try:
        # Get clients with most interactions (recommendations received)
        top_clients = db.session.query(
            User,
            func.count(Recommendation.id).label('interactions_count')
        ).join(
            Recommendation, User.id == Recommendation.client_id
        ).filter(
            Recommendation.manager_id == manager_id
        ).group_by(User.id).order_by(
            func.count(Recommendation.id).desc()
        ).limit(5).all()
        
        clients_data = []
        for user, count in top_clients:
            clients_data.append({
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'interactions_count': count
            })
        
        # Add demo clients if not enough data
        if len(clients_data) < 3:
            demo_clients = [
                {'id': 999, 'full_name': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤', 'email': 'demo@inback.ru', 'interactions_count': 8},
                {'id': 998, 'full_name': '–ê–Ω–Ω–∞ –ü–æ–∫—É–ø–∞—Ç–µ–ª–µ–≤–∞', 'email': 'buyer@test.ru', 'interactions_count': 5},
                {'id': 997, 'full_name': '–ü–µ—Ç—Ä –ò–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤', 'email': 'investor@test.ru', 'interactions_count': 3}
            ]
            clients_data.extend(demo_clients[:3-len(clients_data)])
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# Blog Management Routes for Managers
@app.route('/admin/blog-manager')
@manager_required
def admin_blog_manager():
    """Manager blog management page"""
    from models import BlogArticle, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_id = request.args.get('category_id', '')
        
        # Build query
        query = BlogArticle.query
        
        if search:
            query = query.filter(BlogArticle.title.contains(search) | 
                               BlogArticle.content.contains(search))
        
        if status:
            query = query.filter(BlogArticle.status == status)
            
        if category_id:
            query = query.filter(BlogArticle.category_id == int(category_id))
        
        # Order by creation date
        articles = query.order_by(BlogArticle.created_at.desc()).all()
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        return render_template('admin/blog_manager.html',
                             articles=articles,
                             categories=categories,
                             search=search,
                             status=status,
                             category_id=category_id)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–ª–æ–≥–∞: {str(e)}', 'error')
        return redirect(url_for('manager_dashboard'))


@app.route('/admin/blog/create-new', methods=['GET', 'POST'])
@manager_required
def admin_create_new_article():
    """Create new blog article"""
    from models import Category, BlogArticle
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_create_new.html', categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogArticle.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Create article
        article = BlogArticle(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category_id=int(category_id),
            author_id=session.get('manager_id'),
            status=status,
            is_featured=is_featured
        )
        
        # Set publish date if status is published
        if status == 'published':
            article.published_at = datetime.utcnow()
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.add(article)
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_new_article'))


@app.route('/admin/blog/<int:article_id>/edit-article', methods=['GET', 'POST'])
@manager_required 
def admin_edit_new_article(article_id):
    """Edit existing blog article"""
    from models import BlogArticle, Category
    import re
    from datetime import datetime
    
    article = BlogArticle.query.get_or_404(article_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_edit_new.html', article=article, categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt') 
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        
        # Update slug if title changed
        if title != article.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (exclude current article)
            original_slug = slug
            counter = 1
            while BlogArticle.query.filter_by(slug=slug).filter(BlogArticle.id != article_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            article.slug = slug
        
        # Update article
        article.title = title
        article.excerpt = excerpt
        article.content = content
        article.category_id = int(category_id)
        article.status = status
        article.is_featured = is_featured
        article.updated_at = datetime.utcnow()
        
        # Set/update publish date if status changed to published
        if status == 'published' and not article.published_at:
            article.published_at = datetime.utcnow()
        
        # Recalculate reading time
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_new_article', article_id=article_id))


@app.route('/admin/blog/<int:article_id>/delete-article', methods=['POST'])
@manager_required
def admin_delete_new_article(article_id):
    """Delete blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.get_or_404(article_id)
        db.session.delete(article)
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_manager'))


@app.route('/admin/blog/categories')
@admin_required
def admin_blog_categories():
    """Manage blog categories"""
    from models import Admin, Category, BlogPost, BlogArticle
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    categories = Category.query.order_by(Category.sort_order, Category.name).all()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å—á–µ—Ç —Å—Ç–∞—Ç–µ–π –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for category in categories:
        # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç—å–∏ –∏–∑ BlogPost (–ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)
        blog_post_count = BlogPost.query.filter_by(
            category=category.name, 
            status='published'
        ).count()
        
        # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç—å–∏ –∏–∑ BlogArticle (–ø–æ category_id)
        blog_article_count = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).count()
        
        # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∞—Ç–µ–π
        category.articles_count = blog_post_count + blog_article_count
    
    return render_template('admin/blog_categories.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/categories/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # –û—Ç–∫–ª—é—á–∞–µ–º CSRF –¥–ª—è –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏
def admin_create_category():
    """Create new blog category - both form and JSON API"""
    from models import Admin, Category
    import re
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    # Handle JSON requests (from inline category creation)
    if request.is_json:
        try:
            data = request.get_json()
            name = data.get('name')
            description = data.get('description', '')
            
            if not name:
                return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'})
            
            # Generate slug from Russian name
            def transliterate(text):
                rus_to_eng = {
                    '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z',
                    '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r',
                    '—Å': 's', '—Ç': 't', '—É': 'u', '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                    '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
                }
                return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
            
            slug = transliterate(name.lower())
            slug = re.sub(r'[^\w\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category = Category(
                name=name,
                slug=slug,
                description=description,
                is_active=True
            )
            
            db.session.add(category)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'category': {
                    'id': category.id,
                    'name': category.name,
                    'slug': category.slug
                }
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)})
    
    # Handle form requests (standard category creation page)
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html', admin=current_admin)
    
    try:
        name = request.form.get('name')
        if not name:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return render_template('admin/blog_category_create.html', admin=current_admin)
            
        description = request.form.get('description', '')
        
        # Generate slug
        slug = re.sub(r'[^\w\s-]', '', name.lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure unique slug
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash(f'–ö–∞—Ç–µ–≥–æ—Ä–∏—è "{name}" —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return render_template('admin/blog_category_create.html', admin=current_admin)


# Blog Public Routes  
@app.route('/blog-new')
def blog_new():
    """Public blog page"""
    from models import BlogArticle, Category
    
    try:
        # Get published articles
        articles = BlogArticle.query.filter_by(status='published').order_by(BlogArticle.published_at.desc()).all()
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Add pagination variables that template expects
        return render_template('blog.html', 
                             articles=articles, 
                             categories=categories,
                             total_pages=1,
                             current_page=1,
                             has_prev=False,
                             has_next=False,
                             prev_num=None,
                             next_num=None,
                             search_query='',
                             category_filter=None)
        
    except Exception as e:
        print(f"Blog error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Fallback for when there's an error
        try:
            return render_template('blog.html', articles=[], categories=[])
        except:
            return "–í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –±–ª–æ–≥–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", 500


@app.route('/blog-new/<slug>')
def blog_article_new(slug):
    """View single blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.filter_by(slug=slug, status='published').first_or_404()
        
        # Increment view count
        article.views_count += 1
        db.session.commit()
        
        # Get related articles from same category
        related_articles = BlogArticle.query.filter_by(
            category_id=article.category_id,
            status='published'
        ).filter(
            BlogArticle.id != article.id
        ).order_by(
            BlogArticle.published_at.desc()
        ).limit(3).all()
        
        return render_template('blog_article.html', 
                             article=article,
                             related_articles=related_articles)
        
    except Exception as e:
        flash('–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog-new/category/<slug>')
def blog_category_new(slug):
    """View articles by category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.filter_by(slug=slug, is_active=True).first_or_404()
        
        articles = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).order_by(
            BlogArticle.published_at.desc()
        ).all()
        
        return render_template('blog_category.html', 
                             category=category,
                             articles=articles)
        
    except Exception as e:
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog/<slug>')
def blog_post(slug):
    """Display single blog post by slug"""
    try:
        # Find post by slug - using direct SQL query
        from sqlalchemy import text
        result = db.session.execute(text("""
            SELECT id, title, slug, content, excerpt, category, featured_image, 
                   views_count, created_at, '' as author_name
            FROM blog_posts 
            WHERE slug = :slug AND status = 'published'
        """), {'slug': slug}).fetchone()
        
        if not result:
            flash('–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('blog'))
        
        # Convert to dict for template
        post = {
            'id': result[0],
            'title': result[1],
            'slug': result[2],
            'content': result[3],
            'excerpt': result[4],
            'category': result[5],
            'featured_image': result[6],
            'views_count': result[7] or 0,
            'created_at': result[8],
            'author_name': result[9] or 'InBack'
        }
        
        # Increment view count
        try:
            db.session.execute(text("""
                UPDATE blog_posts 
                SET views_count = COALESCE(views_count, 0) + 1 
                WHERE id = :id
            """), {'id': post['id']})
            db.session.commit()
            post['views_count'] += 1
        except Exception as e:
            db.session.rollback()
        
        # Get related posts from same category
        related_results = db.session.execute(text("""
            SELECT id, title, slug, excerpt, featured_image, created_at
            FROM blog_posts 
            WHERE category = :category AND status = 'published' AND id != :id
            ORDER BY created_at DESC
            LIMIT 3
        """), {'category': post['category'], 'id': post['id']}).fetchall()
        
        related_posts = []
        for r in related_results:
            related_posts.append({
                'id': r[0],
                'title': r[1], 
                'slug': r[2],
                'excerpt': r[3],
                'featured_image': r[4],
                'created_at': r[5]
            })
        
        return render_template('blog_post.html', 
                             post=post,
                             related_posts=related_posts)
        
    except Exception as e:
        flash('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç—å–∏', 'error')
        return redirect(url_for('blog'))


# Admin Blog Management Routes
@app.route('/admin/blog-management')
@admin_required
def admin_blog_management():
    """Admin blog management page"""
    from models import BlogPost, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_name = request.args.get('category', '')
        page = request.args.get('page', 1, type=int)
        
        # Build query
        query = BlogPost.query
        
        if search:
            query = query.filter(BlogPost.title.contains(search) | 
                               BlogPost.content.contains(search))
        
        if status:
            query = query.filter(BlogPost.status == status)
            
        if category_name:
            query = query.filter(BlogPost.category == category_name)
        
        # Order by creation date and paginate
        posts = query.order_by(BlogPost.created_at.desc()).paginate(
            page=page, per_page=10, error_out=False
        )
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Get admin user for template
        from flask_login import current_user
        admin = current_user if current_user.is_authenticated else None
        
        return render_template('admin/blog_management.html',
                             posts=posts,
                             categories=categories,
                             search=search,
                             status=status,
                             category_name=category_name,
                             admin=admin)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–ª–æ–≥–∞: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_post():
    """Create new blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        # Get current admin
        admin_id = session.get('admin_id')
        current_admin = Admin.query.get(admin_id)
        
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('admin_create_blog_post'))
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogPost.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Create blog post using BlogPost model
        post = BlogPost(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category=category.name,  # Use category name, not ID
            author_id=1,  # Default author
            status=status,
            featured_image=featured_image,
            tags=keywords
        )
        
        if status == 'published':
            post.published_at = datetime.utcnow()
        
        db.session.add(post)
        db.session.commit()
        
        # –û–±–Ω–æ–≤–∏–º —Å—á–µ—Ç—á–∏–∫ —Å—Ç–∞—Ç–µ–π –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
        db.session.commit()
        
        print(f'DEBUG: Created article "{title}" in category "{category.name}" with status "{status}"')
        print(f'DEBUG: Updated category "{category.name}" article count to {category.articles_count}')
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        print(f'ERROR creating blog post: {str(e)}')
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_post'))

@app.route('/admin/upload-image', methods=['POST'])
@admin_required
@csrf.exempt
def admin_upload_image():
    """Upload image for TinyMCE editor and blog posts"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check if file is an image
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    if not (file.filename and '.' in file.filename and file.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        return jsonify({'success': False, 'error': '–†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (PNG, JPG, JPEG, GIF, WebP)'}), 400
    
    try:
        # Generate secure filename
        from werkzeug.utils import secure_filename
        import os, uuid
        
        filename = secure_filename(file.filename) if file.filename else 'unnamed_file'
        
        # Create upload directory if it doesn't exist
        upload_dir = 'static/uploads/blog/content'
        os.makedirs(upload_dir, exist_ok=True)
        
        # Save file with unique name to avoid conflicts
        unique_filename = f"{uuid.uuid4()}_{filename}"
        file_path = os.path.join(upload_dir, unique_filename)
        file.save(file_path)
        
        # Return URL - TinyMCE expects 'location' field
        file_url = f"/{file_path}"
        
        return jsonify({
            'success': True,
            'location': file_url,  # TinyMCE expects 'location' field
            'url': file_url,       # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –¥—Ä—É–≥–∏–º–∏ —á–∞—Å—Ç—è–º–∏ –∫–æ–¥–∞
            'filename': unique_filename
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}'}), 500

# Duplicate route removed - already defined earlier


@app.route('/admin/blog-management/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_blog_post(post_id):
    """Edit blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    # Get current admin
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    post = BlogPost.query.get_or_404(post_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', post=post, categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Validation
        if not title or title.strip() == '':
            flash('–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç–∞—Ç—å–∏ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not content or content.strip() == '':
            flash('–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —Å—Ç–∞—Ç—å–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not category_id or category_id == '':
            flash('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å—Ç–∞—Ç—å–∏', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))

        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        # Update slug if title changed
        if title != post.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).filter(BlogPost.id != post_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post.slug = slug
        
        # Calculate reading time
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Update post
        old_category = post.category
        post.title = title
        post.excerpt = excerpt
        post.content = content
        post.category = category.name  # BlogPost uses category name as string
        post.status = status
        post.is_featured = is_featured
        post.featured_image = featured_image
        post.meta_title = meta_title or title
        post.meta_description = meta_description or excerpt  
        post.tags = keywords  # BlogPost uses tags field
        post.reading_time = reading_time
        post.updated_at = datetime.utcnow()
        
        if status == 'published' and not post.published_at:
            post.published_at = datetime.utcnow()
        
        db.session.commit()
        
        # Update category article counts for both old and new categories
        for cat_name in [old_category, category.name]:
            if cat_name:
                cat = Category.query.filter_by(name=cat_name).first()
                if cat:
                    cat.articles_count = BlogPost.query.filter_by(category=cat_name, status='published').count()
        
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_post', post_id=post_id))


@app.route('/admin/blog-management/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_post(post_id):
    """Delete blog post"""
    from models import BlogPost, Category
    
    try:
        post = BlogPost.query.get_or_404(post_id)
        category_name = post.category
        
        db.session.delete(post)
        db.session.commit()
        
        # Update category article count
        if category_name:
            category = Category.query.filter_by(name=category_name).first()
            if category:
                category.articles_count = BlogPost.query.filter_by(category=category_name, status='published').count()
                db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_management'))


@app.route('/admin/blog-categories-management')
@admin_required
def admin_blog_categories_management():
    """Admin blog categories management"""
    from models import Category
    
    try:
        categories = Category.query.order_by(Category.sort_order).all()
        return render_template('admin/blog_categories.html', categories=categories)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-categories-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_category_new():
    """Create blog category"""
    from models import Category
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html')
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug with proper Russian transliteration
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True,
            articles_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_category_new'))


@app.route('/admin/blog-categories-management/<int:category_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_blog_category_new(category_id):
    """Edit blog category"""
    from models import Category
    import re
    
    category = Category.query.get_or_404(category_id)
    
    if request.method == 'GET':
        return render_template('admin/blog_category_edit.html', category=category)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        is_active = 'is_active' in request.form
        
        # Update slug if name changed
        if name != category.name:
            def transliterate_russian_to_latin(text):
                """Convert Russian text to Latin characters for URL slugs"""
                translit_map = {
                    '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
                    '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
                    '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
                    '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                    '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
                    ' ': '-', '_': '-'
                }
                
                result = ''
                for char in text.lower():
                    result += translit_map.get(char, char)
                
                return result
                
            slug = transliterate_russian_to_latin(name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).filter(Category.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        category.name = name
        category.description = description
        category.color = color
        category.icon = icon
        category.sort_order = sort_order
        category.is_active = is_active
        
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_category_new', category_id=category_id))


@app.route('/admin/blog-categories-management/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_category_new(category_id):
    """Delete blog category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.get_or_404(category_id)
        
        # Check if category has posts
        posts_count = BlogArticle.query.filter_by(category_id=category_id).count()
        if posts_count > 0:
            flash(f'–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å {posts_count} —Å—Ç–∞—Ç—å—è–º–∏. –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ —Å—Ç–∞—Ç—å–∏ –≤ –¥—Ä—É–≥–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.', 'error')
            return redirect(url_for('admin_blog_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_categories_management'))


# === JOB MANAGEMENT ADMIN ROUTES ===

@app.route('/admin/jobs')
@admin_required
def admin_jobs_management():
    """Admin jobs management"""
    from models import Job, JobCategory, Admin
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    try:
        jobs = Job.query.order_by(Job.created_at.desc()).all()
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Calculate statistics
        stats = {
            'total': len(jobs),
            'active': len([job for job in jobs if job.status == 'active']),
            'paused': len([job for job in jobs if job.status == 'paused']),
            'closed': len([job for job in jobs if job.status == 'closed']),
            'featured': len([job for job in jobs if job.is_featured])
        }
        
        return render_template('admin/careers_panel.html', vacancies=jobs, categories=categories, admin=current_admin, stats=stats)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/jobs/create', methods=['GET', 'POST'])
@admin_required
def admin_create_job():
    """Create new job"""
    from models import Job, JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    admin_id = session.get('admin_id')  
    current_admin = Admin.query.get(admin_id)
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        category_id = request.form.get('category_id', type=int)
        description = request.form.get('description')
        
        # Validate required fields
        if not title or not category_id or not description:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
            categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
            return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
        requirements = request.form.get('requirements', '')
        benefits = request.form.get('benefits', '')
        responsibilities = request.form.get('responsibilities', '')
        location = request.form.get('location')
        salary_min = request.form.get('salary_min', type=int)
        salary_max = request.form.get('salary_max', type=int)
        employment_type = request.form.get('employment_type', 'full_time')
        experience_level = request.form.get('experience_level', '')
        is_remote = 'is_remote' in request.form
        is_featured = 'is_featured' in request.form
        
        # Additional fields
        department = request.form.get('department', '')
        is_urgent = 'is_urgent' in request.form
        status = request.form.get('status', 'active')
        contact_email = request.form.get('contact_email', '')
        contact_phone = request.form.get('contact_phone', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        
        # Generate slug
        slug = transliterate_russian_to_latin(title)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Job.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        job = Job(
            title=title,
            slug=slug,
            category_id=category_id,
            description=description,
            requirements=requirements,
            benefits=benefits,
            responsibilities=responsibilities,
            location=location,
            salary_min=salary_min,
            salary_max=salary_max,
            salary_currency='RUB',
            salary_period='month',
            employment_type=employment_type,
            experience_level=experience_level,
            is_remote=is_remote,
            is_featured=is_featured,
            is_urgent=is_urgent,
            status=status,
            department=department,
            is_active=True,
            contact_email=contact_email,
            contact_phone=contact_phone,
            meta_title=meta_title,
            meta_description=meta_description,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(job)
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_job'))


@app.route('/admin/jobs/<int:job_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_job(job_id):
    """Edit job"""
    from models import Job, JobCategory, Admin
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    job = Job.query.get_or_404(job_id)
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/edit_vacancy.html', job=job, categories=categories, admin=current_admin)
    
    try:
        # Update job data
        job.title = request.form.get('title')
        job.category_id = request.form.get('category_id', type=int)
        job.description = request.form.get('description')
        job.requirements = request.form.get('requirements', '')
        job.benefits = request.form.get('benefits', '')
        job.responsibilities = request.form.get('responsibilities', '')
        job.location = request.form.get('location')
        job.salary_min = request.form.get('salary_min', type=int)
        job.salary_max = request.form.get('salary_max', type=int)
        job.employment_type = request.form.get('employment_type', 'full_time')
        job.experience_level = request.form.get('experience_level', '')
        job.is_remote = 'is_remote' in request.form
        job.is_featured = 'is_featured' in request.form
        job.is_urgent = 'is_urgent' in request.form
        job.status = request.form.get('status', 'active')
        job.department = request.form.get('department', '')
        job.contact_email = request.form.get('contact_email', '')
        job.contact_phone = request.form.get('contact_phone', '')
        job.meta_title = request.form.get('meta_title', '')
        job.meta_description = request.form.get('meta_description', '')
        job.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job', job_id=job_id))


@app.route('/admin/jobs/<int:job_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job(job_id):
    """Delete job"""
    from models import Job
    
    try:
        job = Job.query.get_or_404(job_id)
        db.session.delete(job)
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/job/<job_slug>')
def job_detail(job_slug):
    """Job detail page"""
    from models import Job
    
    try:
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Increment views count
        job.views_count = (job.views_count or 0) + 1
        db.session.commit()
        
        return render_template('vacancy_details.html', vacancy=job)
        
    except Exception as e:
        print(f"Job detail error: {e}")
        flash('–í–∞–∫–∞–Ω—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('careers'))


@app.route('/job/<job_slug>/apply', methods=['POST'])
# @csrf.exempt  # –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–∫–ª—é—á–∞–µ–º –∏–∑ CSRF –∑–∞—â–∏—Ç—ã - TODO: –¥–æ–±–∞–≤–∏—Ç—å CSRF –≤ —Ñ–æ—Ä–º—É
def submit_job_application(job_slug):
    """Submit job application with resume"""
    from models import Job
    import os
    import uuid
    from datetime import datetime
    
    try:
        # Find the job
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Get form data
        candidate_name = request.form.get('candidate_name', '').strip()
        candidate_phone = request.form.get('candidate_phone', '').strip()
        candidate_email = request.form.get('candidate_email', '').strip()
        cover_letter = request.form.get('cover_letter', '').strip()
        
        # Validate required fields
        if not candidate_name or not candidate_phone:
            flash('–ò–º—è –∏ —Ç–µ–ª–µ—Ñ–æ–Ω –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Validate phone format
        import re
        phone_pattern = r'^[\+]?[0-9\s\-\(\)]{10,18}$'
        if not re.match(phone_pattern, candidate_phone):
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Handle file upload
        resume_file = request.files.get('resume_file')
        resume_filename = None
        
        if resume_file and resume_file.filename:
            # Validate file
            allowed_extensions = {'pdf', 'doc', 'docx', 'txt', 'rtf'}
            filename = resume_file.filename.lower()
            
            if not any(filename.endswith('.' + ext) for ext in allowed_extensions):
                flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PDF, DOC, DOCX, TXT –∏–ª–∏ RTF', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Check file size (5MB max)
            resume_file.seek(0, 2)  # Seek to end
            file_size = resume_file.tell()
            resume_file.seek(0)  # Reset to beginning
            
            if file_size > 5 * 1024 * 1024:  # 5MB
                flash('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5 –ú–ë', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Save file with unique name
            file_extension = filename.split('.')[-1]
            unique_filename = f"{uuid.uuid4()}_{candidate_name.replace(' ', '_')}_{job.slug}.{file_extension}"
            resume_filename = secure_filename(unique_filename)
            
            # Ensure upload directory exists
            upload_dir = os.path.join(app.root_path, 'static', 'uploads', 'resumes')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Save file
            resume_path = os.path.join(upload_dir, resume_filename)
            resume_file.save(resume_path)
        else:
            flash('–†–µ–∑—é–º–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Prepare email notification
        try:
            # Email to HR/Admin
            admin_subject = f"–ù–æ–≤—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é: {job.title}"
            admin_message = f"""–ü–æ—Å—Ç—É–ø–∏–ª –Ω–æ–≤—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é "{job.title}":

–ö–∞–Ω–¥–∏–¥–∞—Ç: {candidate_name}
–¢–µ–ª–µ—Ñ–æ–Ω: {candidate_phone}
Email: {candidate_email if candidate_email else '–ù–µ —É–∫–∞–∑–∞–Ω'}

–°–æ–ø—Ä–æ–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø–∏—Å—å–º–æ:
{cover_letter if cover_letter else '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}

–†–µ–∑—é–º–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {resume_filename}

–í–∞–∫–∞–Ω—Å–∏—è: {job.title}
–û—Ç–¥–µ–ª: {job.department}
–î–∞—Ç–∞ –ø–æ–¥–∞—á–∏: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
            
            # Send notification using existing email service
            send_notification(
                subject=admin_subject,
                message=admin_message,
                to_email="hr@inback.ru",  # You can configure this
                notification_type="job_application"
            )
            
            # Optional: Send confirmation to candidate if email provided
            if candidate_email:
                candidate_subject = f"–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é: {job.title}"
                candidate_message = f"""–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {candidate_name}!

–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é "{job.title}" –≤ –∫–æ–º–ø–∞–Ω–∏–∏ InBack.

–ú—ã –ø–æ–ª—É—á–∏–ª–∏ –≤–∞—à–µ —Ä–µ–∑—é–º–µ –∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ–≥–æ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è. 
–ï—Å–ª–∏ –≤–∞—à–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç—É—Ä–∞ –ø–æ–¥–æ–π–¥–µ—Ç, –º—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É {candidate_phone}.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack
"""
                
                send_notification(
                    subject=candidate_subject,
                    message=candidate_message,
                    to_email=candidate_email,
                    notification_type="application_confirmation"
                )
            
        except Exception as e:
            print(f"Email sending error: {e}")
            # Don't fail the whole process if email fails
            pass
        
        flash('–°–ø–∞—Å–∏–±–æ! –í–∞—à–µ —Ä–µ–∑—é–º–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ. –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.', 'success')
        return redirect(url_for('job_detail', job_slug=job_slug))
        
    except Exception as e:
        print(f"Job application error: {e}")
        flash('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–µ–∑—é–º–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', 'error')
        return redirect(url_for('job_detail', job_slug=job_slug))


@app.route('/admin/jobs/<int:vacancy_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_vacancy_status(vacancy_id):
    """Toggle vacancy status between active and paused"""
    from models import Job
    
    job = Job.query.get_or_404(vacancy_id)
    
    # Toggle between 'active' and 'paused' status
    if job.status == 'active':
        job.status = 'paused'
        status_text = '–ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞'
    else:
        job.status = 'active'
        status_text = '–∞–∫—Ç–∏–≤–Ω–∞'
    
    try:
        db.session.commit()
        flash(f'–í–∞–∫–∞–Ω—Å–∏—è "{job.title}" {status_text}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –≤–∞–∫–∞–Ω—Å–∏–∏', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/admin/job-categories')
@admin_required
def admin_job_categories_management():
    """Admin job categories management"""
    from models import JobCategory, Admin
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    try:
        categories = JobCategory.query.order_by(JobCategory.sort_order).all()
        return render_template('admin/job_categories_management.html', categories=categories, admin=current_admin)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/job-categories/create', methods=['GET', 'POST'])
@admin_required
@csrf.exempt
def admin_create_job_category():
    """Create new job category"""
    from models import JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    if request.method == 'GET':
        return render_template('admin/create_job_category.html', admin=current_admin)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-briefcase')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while JobCategory.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = JobCategory(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_create_job_category'))


@app.route('/admin/job-categories/<int:category_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_job_category(category_id):
    """Edit job category"""
    from models import JobCategory, Admin
    import re
    
    admin_id = session.get('admin_id')
    current_admin = Admin.query.get(admin_id)
    
    category = JobCategory.query.get_or_404(category_id)
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/edit_job_category.html', category=category, admin=current_admin)
    
    try:
        # Update category data
        category.name = request.form.get('name')
        category.description = request.form.get('description', '')
        category.color = request.form.get('color', 'blue')
        category.icon = request.form.get('icon', 'fas fa-briefcase')
        category.sort_order = request.form.get('sort_order', 0, type=int)
        category.is_active = 'is_active' in request.form
        
        # Update slug only if name changed
        old_slug = category.slug
        name = request.form.get('name')
        if name and category.name != name:
            slug = transliterate_russian_to_latin(name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (excluding current category)
            original_slug = slug
            counter = 1
            while JobCategory.query.filter(JobCategory.slug == slug, JobCategory.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job_category', category_id=category_id))


@app.route('/admin/job-categories/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job_category(category_id):
    """Delete job category"""
    from models import JobCategory, Job
    
    try:
        category = JobCategory.query.get_or_404(category_id)
        
        # Check if category has jobs
        jobs_count = Job.query.filter_by(category_id=category_id).count()
        if jobs_count > 0:
            flash(f'–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å {jobs_count} –≤–∞–∫–∞–Ω—Å–∏—è–º–∏. –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –≤–∞–∫–∞–Ω—Å–∏–∏ –≤ –¥—Ä—É–≥–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.', 'error')
            return redirect(url_for('admin_job_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
    
    return redirect(url_for('admin_job_categories_management'))


# Register API blueprint
app.register_blueprint(api_bp)

# Register notification settings blueprint
try:
    from notification_settings import notification_settings_bp
    app.register_blueprint(notification_settings_bp)
except Exception as e:
    print(f"Warning: Could not register notification settings blueprint: {e}")

# Smart Search API Endpoints
@app.route('/api/smart-search')
def smart_search_api():
    """–£–º–Ω—ã–π –ø–æ–∏—Å–∫ —Å OpenAI –∞–Ω–∞–ª–∏–∑–æ–º"""
    query = request.args.get('q', '').strip()
    
    if not query:
        return jsonify({'results': [], 'criteria': {}, 'suggestions': []})
    
    try:
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å —Å –ø–æ–º–æ—â—å—é OpenAI
        criteria = smart_search.analyze_search_query(query)
        # Search criteria processed
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        properties = load_properties()
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤
        filtered_properties = apply_smart_filters(properties, criteria)
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if criteria.get('semantic_search') or criteria.get('features'):
            filtered_properties = smart_search.semantic_property_search(
                filtered_properties, query, criteria
            )
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        results = []
        for prop in filtered_properties[:20]:
            results.append({
                'type': 'property',
                'id': prop['id'],
                'title': f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤",
                'subtitle': f"{prop.get('complex_name', '')} ‚Ä¢ {prop['district']}",
                'price': prop['price'],
                'rooms': prop.get('rooms', 1),
                'area': prop.get('area', 0),
                'url': f"/object/{prop['id']}"
            })
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥—Å–∫–∞–∑–∫–∏
        suggestions = smart_search.generate_search_suggestions(query)
        
        return jsonify({
            'results': results,
            'criteria': criteria,
            'suggestions': suggestions[:5],
            'total': len(filtered_properties)
        })
        
    except Exception as e:
        print(f"ERROR: Smart search failed: {e}")
        # Fallback –∫ –æ–±—ã—á–Ω–æ–º—É –ø–æ–∏—Å–∫—É
        return jsonify({'results': [], 'error': str(e)})

@app.route('/api/search-suggestions')
# ‚ùå –ö–≠–® –û–¢–ö–õ–Æ–ß–Å–ù –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ —Ç–∏–ø–æ–≤ –∫–≤–∞—Ä—Ç–∏—Ä
# @cache.memoize(timeout=300)
def search_suggestions_api():
    """–°—É–ø–µ—Ä-–±—ã—Å—Ç—Ä—ã–π API –¥–ª—è –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ —Å —Ç–∏–ø–∞–º–∏ –∫–≤–∞—Ä—Ç–∏—Ä"""
    query = request.args.get('q', '').strip()
    if not query or len(query) < 1:  # ‚úÖ –£–º–µ–Ω—å—à–∏–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å 2 –¥–æ 1
        return jsonify([])
    
    try:
        # ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô super_search —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ç–∏–ø–æ–≤ –∫–≤–∞—Ä—Ç–∏—Ä
        from smart_search import smart_search
        suggestions = smart_search.search_suggestions(query, limit=50)
        # ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä—è–º–æ —Å–ø–∏—Å–æ–∫, –∫–∞–∫ –æ–∂–∏–¥–∞–µ—Ç —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
        return jsonify(suggestions)
        
    except Exception as e:
        # Fallback –∫ —Å—Ç–∞—Ä–æ–º—É –ø–æ–∏—Å–∫—É –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        print(f"‚ùå Super search failed, using fallback: {e}")
        import traceback
        traceback.print_exc()
        return search_suggestions_fallback(query)

def search_suggestions_fallback(query):
    """–†–µ–∑–µ—Ä–≤–Ω—ã–π –ø–æ–∏—Å–∫ –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–æ–∫ –≤ —Å—É–ø–µ—Ä-–ø–æ–∏—Å–∫–µ"""
    suggestions = []
    query_lower = f'%{query.lower()}%'
    
    try:
        # –ü—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ –ø–æ –ñ–ö
        complexes = db.session.execute(text("""
            SELECT DISTINCT complex_name, COUNT(*) as count
            FROM excel_properties 
            WHERE LOWER(complex_name) LIKE :query
            AND complex_name IS NOT NULL 
            GROUP BY complex_name
            ORDER BY count DESC
            LIMIT 4
        """), {'query': query_lower}).fetchall()
        
        for row in complexes:
            suggestions.append({
                'type': 'complex',
                'title': row[0],
                'subtitle': f'{row[1]} –∫–≤–∞—Ä—Ç–∏—Ä',
                'icon': 'building',
                'url': f'/properties?residential_complex={row[0]}'
            })
        
        return jsonify({'suggestions': suggestions[:6]})
    except Exception as e:
        return jsonify({'suggestions': [], 'error': str(e)})

@app.route('/api/super-search')
@cache.memoize(timeout=180)  # –ö—ç—à –Ω–∞ 3 –º–∏–Ω—É—Ç—ã
def super_search_api():
    """–ù–æ–≤—ã–π —Å—É–ø–µ—Ä-–±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify({'results': [], 'total': 0})
    
    try:
        from smart_search import smart_search
        results = smart_search.search_properties(query, limit=50)
        return jsonify(results)
        
    except Exception as e:
        print(f"Super search error: {e}")
        return jsonify({'results': [], 'total': 0, 'error': str(e)})

@app.route('/api/metrics', methods=['POST'])
def collect_metrics():
    """–°–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'status': 'error', 'message': 'No data provided'}), 400
        
        # –õ–æ–≥–∏—Ä—É–µ–º –≤–∞–∂–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        metric_type = data.get('type', 'unknown')
        
        if metric_type == 'page_load':
            duration = data.get('duration', 0)
            url = data.get('url', 'unknown')
            print(f"‚ö° Page Load: {url} in {round(duration)}ms")
        
        elif metric_type == 'search_performance':
            query = data.get('query', '')
            response_time = data.get('response_time', 0)
            results_count = data.get('results_count', 0)
            print(f"üîç Search: '{query}' - {round(response_time)}ms, {results_count} results")
        
        # –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã –±—ã–ª–∞ –∑–∞–ø–∏—Å—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        # –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        
        return jsonify({'status': 'success'})
        
    except Exception as e:
        print(f"Metrics collection error: {e}")
        return jsonify({'status': 'error'}), 500

@app.route('/api/smart-suggestions')
def smart_suggestions_api():
    """API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–º–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫ –ø–æ–∏—Å–∫–∞"""
    query = request.args.get('q', '').strip()
    
    if len(query) < 2:
        return jsonify({'suggestions': []})
    
    try:
        suggestions = smart_search.generate_search_suggestions(query)
        return jsonify({'suggestions': suggestions})
    except Exception as e:
        print(f"ERROR: Smart suggestions failed: {e}")
        return jsonify({'suggestions': []})

def apply_smart_filters(properties, criteria):
    """–ü—Ä–∏–º–µ–Ω—è–µ—Ç —É–º–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ OpenAI"""
    filtered = properties.copy()
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º
    if criteria.get('rooms'):
        rooms_list = criteria['rooms']
        filtered = [p for p in filtered if str(p.get('rooms', '')) in rooms_list]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Ä–∞–π–æ–Ω—É
    if criteria.get('district'):
        district = criteria['district']
        filtered = [p for p in filtered if p.get('district', '') == district]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º (—Ç–∏–ø—ã –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏, –∫–ª–∞—Å—Å—ã, –º–∞—Ç–µ—Ä–∏–∞–ª—ã)
    if criteria.get('keywords'):
        keywords_filtered = []
        for prop in filtered:
            prop_matches = False
            for keyword in criteria['keywords']:
                keyword_lower = keyword.lower()
                
                # –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏
                prop_type_lower = prop.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞').lower()
                if keyword_lower == prop_type_lower:
                    prop_matches = True
                    break
                
                # –ö–ª–∞—Å—Å –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ (—Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
                prop_class_lower = prop.get('property_class', '').lower()
                if keyword_lower == prop_class_lower:
                    prop_matches = True
                    break
                
                # –ú–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–µ–Ω
                wall_material_lower = prop.get('wall_material', '').lower()
                if keyword_lower in wall_material_lower:
                    prop_matches = True
                    break
                
                # –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏
                features = prop.get('features', [])
                if any(keyword_lower in feature.lower() for feature in features):
                    prop_matches = True
                    break
                
                # –û—Å–æ–±–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Ü–µ–Ω–æ–≤—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                if keyword_lower == '–¥–æ—Ä–æ–≥–æ' or keyword_lower == '–Ω–µ–¥–æ—Ä–æ–≥–æ':
                    # –≠—Ç–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                    continue
                
                # –ü–æ–∏—Å–∫ –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ –∫–∞–∫ fallback
                property_title = f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤"
                title_lower = property_title.lower()
                if keyword_lower in title_lower:
                    prop_matches = True
                    break
            
            if prop_matches:
                keywords_filtered.append(prop)
        
        filtered = keywords_filtered
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–µ–Ω–æ–≤—ã—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        if '–¥–æ—Ä–æ–≥–æ' in criteria.get('keywords', []):
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –∏ –±–µ—Ä–µ–º –≤–µ—Ä—Ö–Ω–∏–µ 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0), reverse=True)
            filtered = filtered[:max(1, len(filtered)//2)]
        elif '–Ω–µ–¥–æ—Ä–æ–≥–æ' in criteria.get('keywords', []):
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –∏ –±–µ—Ä–µ–º –Ω–∏–∂–Ω–∏–µ 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0))
            filtered = filtered[:max(1, len(filtered)//2)]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—è–º
    if criteria.get('features'):
        features_list = criteria['features']
        features_filtered = []
        for prop in filtered:
            prop_features = [f.lower() for f in prop.get('features', [])]
            if any(feature.lower() in prop_features for feature in features_list):
                features_filtered.append(prop)
        filtered = features_filtered
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
    if criteria.get('price_range'):
        price_range = criteria['price_range']
        if len(price_range) >= 1 and price_range[0]:
            min_price = price_range[0]
            filtered = [p for p in filtered if p.get('price', 0) >= min_price]
        if len(price_range) >= 2 and price_range[1]:
            max_price = price_range[1]
            filtered = [p for p in filtered if p.get('price', 0) <= max_price]
    
    return filtered

# Manager Client Management Routes
@app.route('/manager/clients')
@manager_required
def manager_clients():
    """Manager clients page"""
    from models import User, Manager
    
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    if not manager:
        return redirect(url_for('manager_login'))
    
    # Get clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=manager_id).order_by(User.created_at.desc()).all()
    
    return render_template('manager/clients.html', 
                         manager=manager,
                         clients=clients)

# Manager Deals Management Routes  
@app.route('/manager/deals')
@manager_required
def manager_deals():
    """Manager deals page"""
    from models import User, Manager, Deal, ResidentialComplex
    from sqlalchemy import func
    
    manager_id = session.get('manager_id')
    manager = Manager.query.get(manager_id)
    
    if not manager:
        return redirect(url_for('manager_login'))
    
    # Get deals for this manager
    deals = Deal.query.filter_by(manager_id=manager_id).order_by(Deal.created_at.desc()).all()
    
    # Get clients available for this manager (assigned OR unassigned)
    # –ú–µ–Ω–µ–¥–∂–µ—Ä –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–¥–µ–ª–∫–∏ –¥–ª—è —Å–≤–æ–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –∏ –¥–ª—è –Ω–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    assigned_clients = User.query.filter(
        db.or_(
            User.assigned_manager_id == manager_id,
            User.assigned_manager_id == None
        )
    ).filter_by(role='buyer').order_by(User.full_name).all()
    
    residential_complexes = ResidentialComplex.query.order_by(ResidentialComplex.name).all()
    
    # Calculate stats
    active_deals_count = Deal.query.filter(
        Deal.manager_id == manager_id,
        Deal.status.in_(['new', 'reserved', 'mortgage'])
    ).count()
    
    completed_deals_count = Deal.query.filter(
        Deal.manager_id == manager_id,
        Deal.status == 'completed'
    ).count()
    
    in_progress_deals_count = Deal.query.filter(
        Deal.manager_id == manager_id,
        Deal.status.in_(['reserved', 'mortgage'])
    ).count()
    
    # Calculate total cashback
    total_cashback = db.session.query(func.sum(Deal.cashback_amount)).filter(
        Deal.manager_id == manager_id,
        Deal.status == 'completed'
    ).scalar() or 0
    
    return render_template('manager/deals.html',
                         manager=manager,
                         deals=deals,
                         assigned_clients=assigned_clients,
                         residential_complexes=residential_complexes,
                         active_deals_count=active_deals_count,
                         completed_deals_count=completed_deals_count,
                         in_progress_deals_count=in_progress_deals_count,
                         total_cashback=int(total_cashback))


@app.route('/api/manager/add-client', methods=['POST'])
@manager_required
def manager_add_client():
    """Add new client"""
    from models import User, Manager
    import re
    
    manager_id = session.get('manager_id')
    print(f"DEBUG: Add client endpoint called by manager {manager_id}")
    print(f"DEBUG: Request method: {request.method}, Content-Type: {request.content_type}")
    print(f"DEBUG: Request is_json: {request.is_json}")
    
    try:
        # Accept both JSON and form data
        if request.is_json:
            data = request.get_json()
            print(f"DEBUG: Received JSON data: {data}")
            full_name = data.get('full_name', '').strip()
            email = data.get('email', '').strip().lower()
            phone = data.get('phone', '').strip() if data.get('phone') else None
            is_active = data.get('is_active', True)
        else:
            print(f"DEBUG: Received form data: {dict(request.form)}")
            full_name = request.form.get('full_name', '').strip()
            email = request.form.get('email', '').strip().lower()
            phone = request.form.get('phone', '').strip() if request.form.get('phone') else None
            is_active = 'is_active' in request.form
        
        print(f"DEBUG: Parsed data - name: {full_name}, email: {email}, phone: {phone}, active: {is_active}")
        
        # Validation
        if not full_name or len(full_name) < 2:
            return jsonify({'success': False, 'error': '–ü–æ–ª–Ω–æ–µ –∏–º—è –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞'}), 400
        
        # Email validation
        email_regex = r'^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$'
        if not email or not re.match(email_regex, email):
            return jsonify({'success': False, 'error': '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email –∞–¥—Ä–µ—Å'}), 400
        
        # Phone validation (optional but must be correct format if provided)
        if phone:
            phone_regex = r'^\+7-\d{3}-\d{3}-\d{2}-\d{2}$'
            if not re.match(phone_regex, phone):
                return jsonify({'success': False, 'error': '–¢–µ–ª–µ—Ñ–æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ +7-918-123-45-67'}), 400
        
        # Check if email already exists
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Generate temporary password
        import secrets
        import string
        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
        
        # Create new user with temporary password
        user = User(
            full_name=full_name,
            email=email,
            phone=phone,
            is_active=is_active,
            role='buyer',
            assigned_manager_id=manager_id,
            registration_source='Manager',
            client_status='–ù–æ–≤—ã–π'
        )
        user.set_password(temp_password)  # Set temporary password
        
        db.session.add(user)
        db.session.commit()
        
        print(f"DEBUG: Successfully created client {user.id}: {user.full_name}")
        
        # Send welcome email and SMS with credentials
        try:
            from email_service import send_email
            manager = Manager.query.get(manager_id)
            manager_name = manager.full_name if manager else '–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä'
            
            # Email with login credentials
            subject = "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω –≤ InBack.ru - –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞"
            email_content = f"""–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {full_name}!

–î–ª—è –≤–∞—Å —Å–æ–∑–¥–∞–Ω –∞–∫–∫–∞—É–Ω—Ç –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ InBack.ru

üìß Email –¥–ª—è –≤—Ö–æ–¥–∞: {email}
üîë –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å: {temp_password}

üåê –°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞: {request.url_root.rstrip('/')}/login

–í–ê–ñ–ù–û: –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ —Ä–∞–∑–¥–µ–ª–µ "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è"

–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}

–ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ —Å–≤–æ–µ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru"""
            
            send_email(
                to_email=email,
                subject=subject,
                content=email_content,
                template_name='notification'
            )
            print(f"DEBUG: Welcome email with credentials sent to {email}")
            
            # Send SMS if phone number provided
            if phone:
                try:
                    from sms_service import send_login_credentials_sms
                    
                    sms_sent = send_login_credentials_sms(
                        phone=phone,
                        email=email,
                        password=temp_password,
                        manager_name=manager_name,
                        login_url=f"{request.url_root.rstrip('/')}/login"
                    )
                    
                    if sms_sent:
                        print(f"DEBUG: SMS sent successfully to {phone}")
                    else:
                        print(f"DEBUG: SMS sending failed for {phone}")
                    
                except Exception as sms_e:
                    print(f"DEBUG: Failed to send SMS: {sms_e}")
                    
        except Exception as e:
            print(f"DEBUG: Failed to send welcome email: {e}")
        
        return jsonify({
            'success': True, 
            'client_id': user.id,
            'message': f'–ö–ª–∏–µ–Ω—Ç {full_name} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω. –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ email {email}' + (f' –∏ SMS –Ω–∞ {phone}' if phone else '') + '.',
            'client_data': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'login_url': f"{request.url_root.rstrip('/')}/login",
                'temp_password': temp_password  # Include for manager reference
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding client: {str(e)}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'}), 500

@app.route('/manager/get-client/<int:client_id>')
@manager_required
def manager_get_client(client_id):
    """Get client data for editing"""
    from models import User

# ================================
# DEAL MANAGEMENT API ENDPOINTS
# ================================

@app.route('/api/deals', methods=['POST'])
@manager_required
@require_json_csrf
def api_create_deal():
    """Create new deal (managers only)"""
    from models import Deal, Manager, User, ResidentialComplex
    from decimal import Decimal
    
    try:
        manager_id = session.get('manager_id')
        data = request.get_json()
        
        if not data:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏'}), 400
        
        # Validation - client_id and price are required
        if 'client_id' not in data or not data['client_id']:
            return jsonify({'success': False, 'error': '–ü–æ–ª–µ client_id –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        if 'property_price' not in data or not data['property_price']:
            return jsonify({'success': False, 'error': '–ü–æ–ª–µ property_price –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Get complex name from request
        complex_name = data.get('residential_complex_name', '').strip()
        if not complex_name:
            return jsonify({'success': False, 'error': '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –ñ–ö'}), 400
        
        # Validate client exists and belongs to this manager
        client_id = int(data['client_id'])
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # –ú–µ–Ω–µ–¥–∂–µ—Ä –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–¥–µ–ª–∫–∏ –¥–ª—è:
        # 1. –°–≤–æ–∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ (assigned_manager_id == manager_id)
        # 2. –ù–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ (assigned_manager_id is None)
        if client.assigned_manager_id is not None and client.assigned_manager_id != manager_id:
            return jsonify({'success': False, 'error': '–≠—Ç–æ—Ç –∫–ª–∏–µ–Ω—Ç —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –¥—Ä—É–≥–æ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É'}), 403
        
        # Validate price and cashback amounts
        try:
            property_price = Decimal(str(data['property_price']))
            cashback_amount = Decimal(str(data['cashback_amount']))
            
            if property_price <= 0:
                return jsonify({'success': False, 'error': '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0'}), 400
            
            if cashback_amount < 0:
                return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π'}), 400
                
            # Get complex cashback rate for validation
            max_rate = Decimal('0.15')  # Default max 15% cashback
            if cashback_amount > property_price * max_rate:  # Max cashback validation
                return jsonify({'success': False, 'error': f'–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å {max_rate * 100}% –æ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –æ–±—ä–µ–∫—Ç–∞'}), 400
                
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ü–µ–Ω—ã –∏–ª–∏ –∫–µ—à–±–µ–∫–∞'}), 400
        
        # Create new deal
        deal = Deal(
            manager_id=manager_id,
            client_id=data['client_id'],
            residential_complex_name=complex_name,  # Save complex name as text
            property_price=property_price,
            cashback_amount=cashback_amount,
            property_description=data.get('property_description', ''),
            property_floor=data.get('property_floor'),
            property_area=data.get('property_area'),
            property_rooms=data.get('property_rooms', ''),
            status=data.get('status', 'new'),
            notes=data.get('notes', ''),
            client_notes=data.get('client_notes', '')
        )
        
        db.session.add(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞',
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'client_name': client.full_name,
                'complex_name': complex_name,
                'created_at': deal.created_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating deal: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals', methods=['GET'])
def api_get_deals():
    """Get list of deals with filtering"""
    from models import Deal, Manager, User, ResidentialComplex
    from flask_login import current_user
    
    try:
        # Check if user is manager or client
        manager_id = session.get('manager_id')
        is_manager = session.get('is_manager', False)
        
        if is_manager and manager_id:
            # Manager can see all their deals
            deals_query = Deal.query.filter_by(manager_id=manager_id)
        elif current_user.is_authenticated:
            # Client can only see their own deals
            user_id = current_user.id
            deals_query = Deal.query.filter_by(client_id=user_id)
        else:
            # No authentication
            return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
        
        # Apply status filtering if provided
        status_filter = request.args.get('status')
        if status_filter:
            status_list = [s.strip() for s in status_filter.split(',') if s.strip()]
            if status_list:
                deals_query = deals_query.filter(Deal.status.in_(status_list))
        
        # Order by creation date (newest first)
        deals = deals_query.order_by(Deal.created_at.desc()).all()
        
        # Format response
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'manager_name': deal.manager.full_name,
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'created_at': deal.created_at.isoformat(),
                'updated_at': deal.updated_at.isoformat(),
                'can_edit': deal.can_edit(manager_id if is_manager else current_user.id, is_manager)
            })
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': is_manager
        })
        
    except Exception as e:
        print(f"Error getting deals: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–¥–µ–ª–æ–∫'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['GET'])
@login_required
def api_get_deal(deal_id):
    """Get specific deal with access control"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Check access rights
        manager_id = session.get('manager_id')
        is_manager = session.get('is_manager', False)
        
        if is_manager:
            # Manager can only see their own deals
            if deal.manager_id != manager_id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        else:
            # Client can only see their own deals
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        
        # Return deal data
        deal_data = {
            'id': deal.id,
            'deal_number': deal.deal_number,
            'status': deal.status,
            'status_display': deal.status_display,
            'status_color': deal.status_color,
            'property_price': float(deal.property_price),
            'cashback_amount': float(deal.cashback_amount),
            'cashback_percentage': deal.get_cashback_percentage(),
            'property_description': deal.property_description,
            'property_floor': deal.property_floor,
            'property_area': deal.property_area,
            'property_rooms': deal.property_rooms,
            'notes': deal.notes,
            'client_notes': deal.client_notes,
            'client_name': deal.client.full_name,
            'client_email': deal.client.email,
            'client_phone': deal.client.phone,
            'manager_name': deal.manager.full_name,
            'manager_email': deal.manager.email,
            'manager_phone': deal.manager.phone,
            'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
            'complex_id': deal.residential_complex.id if deal.residential_complex else None,
            'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
            'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
            'created_at': deal.created_at.isoformat(),
            'updated_at': deal.updated_at.isoformat(),
            'can_edit': deal.can_edit(manager_id if is_manager else current_user.id, is_manager)
        }
        
        return jsonify({
            'success': True,
            'deal': deal_data
        })
        
    except Exception as e:
        print(f"Error getting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['PUT'])
@require_json_csrf
def api_update_deal(deal_id):
    """Update deal (status, notes)"""
    from models import Deal
    from datetime import datetime, date
    from flask_login import current_user
    
    try:
        # Check authentication
        manager_id = session.get('manager_id')
        is_manager = session.get('is_manager', False)
        
        if not is_manager and not current_user.is_authenticated:
            return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
        
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è'}), 400
        
        if is_manager:
            # Manager can only update their own deals
            if deal.manager_id != manager_id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
            
            # Manager can update all fields
            allowed_fields = ['status', 'notes', 'client_notes', 'property_description', 
                            'property_floor', 'property_area', 'property_rooms', 
                            'contract_date', 'completion_date']
        else:
            # Client can only update their own deals and limited fields
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
            
            # Client can only update notes and only if deal is in editable status
            if deal.status not in ['new', 'object_reserved']:
                return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –±–æ–ª—å—à–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞'}), 403
            
            allowed_fields = ['client_notes']
        
        # Update allowed fields
        updated_fields = []
        old_status = deal.status  # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Å—Ç–∞—Ä—ã–π —Å—Ç–∞—Ç—É—Å
        
        for field in allowed_fields:
            if field in data:
                if field == 'status':
                    # Validate status
                    valid_statuses = ['new', 'object_reserved', 'mortgage', 'successful', 'rejected']
                    if data[field] not in valid_statuses:
                        return jsonify({'success': False, 'error': f'–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å—Ç–∞—Ç—É—Å: {data[field]}'}), 400
                    # Save validated status
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
                
                elif field in ['contract_date', 'completion_date']:
                    # Handle date fields
                    if data[field]:
                        try:
                            date_value = datetime.strptime(data[field], '%Y-%m-%d').date()
                            setattr(deal, field, date_value)
                            updated_fields.append(field)
                        except ValueError:
                            return jsonify({'success': False, 'error': f'–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –¥–ª—è {field}. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ YYYY-MM-DD'}), 400
                    else:
                        setattr(deal, field, None)
                        updated_fields.append(field)
                else:
                    # Handle text fields
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
        
        if not updated_fields:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –ø–æ–ª–µ–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è'}), 400
        
        # Update timestamp
        deal.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        if 'status' in updated_fields and old_status != deal.status:
            from models import UserActivity
            status_display_map = {
                'new': '–ù–æ–≤–∞—è',
                'object_reserved': '–û–±—ä–µ–∫—Ç –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω',
                'mortgage': '–ò–ø–æ—Ç–µ–∫–∞',
                'successful': '–£—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞',
                'rejected': '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
            }
            old_status_display = status_display_map.get(old_status, old_status)
            new_status_display = status_display_map.get(deal.status, deal.status)
            
            UserActivity.log_activity(
                user_id=deal.client_id,
                activity_type='deal_status_update',
                description=f'–°—Ç–∞—Ç—É—Å —Å–¥–µ–ª–∫–∏ {deal.deal_number} –∏–∑–º–µ–Ω–µ–Ω —Å "{old_status_display}" –Ω–∞ "{new_status_display}"'
            )
        
        return jsonify({
            'success': True,
            'message': '–°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞',
            'updated_fields': updated_fields,
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'updated_at': deal.updated_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['DELETE'])
@manager_required
@require_json_csrf
def api_delete_deal(deal_id):
    """Delete deal (managers only)"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        manager_id = session.get('manager_id')
        
        # Check if manager owns this deal
        if deal.manager_id != manager_id:
            return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        
        # Check if deal can be deleted (only new or rejected deals)
        if deal.status not in ['new', 'rejected']:
            return jsonify({'success': False, 'error': '–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–¥–µ–ª–∫—É —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º "' + deal.status_display + '"'}), 400
        
        deal_number = deal.deal_number
        db.session.delete(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–°–¥–µ–ª–∫–∞ {deal_number} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500
    
    try:
        manager_id = session.get('manager_id')
        print(f"DEBUG: Get client {client_id}, manager_id: {manager_id}")
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=manager_id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        print(f"DEBUG: Found client: {client}")
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        response_data = {
            'success': True,
            'id': client.id,
            'full_name': client.full_name or '',
            'email': client.email or '',
            'phone': client.phone or '',
            'is_active': client.is_active if hasattr(client, 'is_active') else True
        }
        print(f"DEBUG: Returning client data: {response_data}")
        return jsonify(response_data)
        
    except Exception as e:
        print(f"DEBUG: Exception in get_client: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/manager/edit-client', methods=['POST'])
@manager_required
def manager_edit_client():
    """Edit existing client"""
    from models import User
    
    manager_id = session.get('manager_id')
    
    try:
        client_id = request.form.get('client_id')
        full_name = request.form.get('full_name')
        email = request.form.get('email')
        phone = request.form.get('phone')
        is_active = 'is_active' in request.form
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=manager_id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        if not all([full_name, email]):
            return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Check if email already exists (excluding current client)
        existing_user = User.query.filter(User.email == email, User.id != client_id).first()
        if existing_user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Update client data
        client.full_name = full_name
        client.email = email
        client.phone = phone
        client.is_active = is_active
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/manager/delete-client', methods=['POST'])
@manager_required
def manager_delete_client():
    """Delete client"""
    from models import User
    
    manager_id = session.get('manager_id')
    
    try:
        # Handle both JSON and form data
        if request.content_type == 'application/json':
            data = request.get_json()
            client_id = data.get('client_id')
        else:
            client_id = request.form.get('client_id')
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=manager_id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Instead of deleting, mark as inactive
        client.is_active = False
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

def send_callback_notification_email(callback_req, manager):
    """Send email notification about callback request"""
    try:
        from email_service import send_email
        
        # Email content
        subject = f"–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–±—Ä–∞—Ç–Ω—ã–π –∑–≤–æ–Ω–æ–∫ - {callback_req.name}"
        
        # Build message content
        content = f"""
        –ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–±—Ä–∞—Ç–Ω—ã–π –∑–≤–æ–Ω–æ–∫:
        
        –ö–ª–∏–µ–Ω—Ç: {callback_req.name}
        –¢–µ–ª–µ—Ñ–æ–Ω: {callback_req.phone}
        Email: {callback_req.email or '–ù–µ —É–∫–∞–∑–∞–Ω'}
        –£–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è: {callback_req.preferred_time}
        
        –ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç: {callback_req.interest}
        –ë—é–¥–∂–µ—Ç: {callback_req.budget}
        –ü–ª–∞–Ω–∏—Ä—É–µ—Ç –ø–æ–∫—É–ø–∫—É: {callback_req.timing}
        
        –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: {callback_req.notes or '–ù–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}
        
        –ù–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager.full_name if manager else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}
        –î–∞—Ç–∞ –∑–∞—è–≤–∫–∏: {callback_req.created_at.strftime('%d.%m.%Y %H:%M')}
        """
        
        # Try to send to manager first, then to admin email
        recipient_email = manager.email if manager else 'admin@inback.ru'
        
        success = send_email(
            to_email=recipient_email,
            subject=subject,
            content=content,
            template_name='notification'
        )
        
        if success:
            print(f"‚úì Callback notification email sent to {recipient_email}")
        else:
            print(f"‚úó Failed to send callback notification email to {recipient_email}")
            
    except Exception as e:
        print(f"Error sending callback notification email: {e}")


def send_callback_notification_telegram(callback_req, manager):
    """Send Telegram notification about callback request"""
    try:
        # Check if telegram_bot module can be imported
        try:
            from telegram_bot import send_telegram_message
        except ImportError as e:
            print(f"Telegram bot not available: {e}")
            return False
        
        # Calculate potential cashback
        potential_cashback = ""
        if callback_req.budget:
            if "–º–ª–Ω" in callback_req.budget:
                # Extract average from range like "3-5 –º–ª–Ω"
                numbers = [float(x) for x in callback_req.budget.replace(" –º–ª–Ω", "").replace("—Ä—É–±", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                if numbers:
                    avg_price = sum(numbers) / len(numbers) * 1000000
                    cashback = int(avg_price * 0.02)
                    potential_cashback = f"üí∞ *–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫:* {cashback:,} —Ä—É–±. (2%)\n"
        
        # Enhanced Telegram message
        message = f"""üìû *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –û–ë–†–ê–¢–ù–´–ô –ó–í–û–ù–û–ö*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {callback_req.name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {callback_req.phone}
‚Ä¢ Email: {callback_req.email or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –£–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è –∑–≤–æ–Ω–∫–∞: {callback_req.preferred_time}

üîç *–ö–†–ò–¢–ï–†–ò–ò –ü–û–ò–°–ö–ê:*
‚Ä¢ –ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç: {callback_req.interest or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {callback_req.budget or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ü–ª–∞–Ω—ã –Ω–∞ –ø–æ–∫—É–ø–∫—É: {callback_req.timing or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}

{potential_cashback}üìù *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
{callback_req.notes or '–ù–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}

üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {callback_req.created_at.strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –§–æ—Ä–º–∞ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –∑–≤–æ–Ω–∫–∞ –Ω–∞ —Å–∞–π—Ç–µ InBack.ru
üë®‚Äçüíº *–ù–ê–ó–ù–ê–ß–ï–ù–ù–´–ô –ú–ï–ù–ï–î–ñ–ï–†:* {manager.full_name if manager else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –ü–µ—Ä–µ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
2Ô∏è‚É£ –ü—Ä–æ–≤–µ—Å—Ç–∏ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º
3Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É
4Ô∏è‚É£ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–∫–∞–∑—ã –æ–±—ä–µ–∫—Ç–æ–≤

‚ö° *–í–ê–ñ–ù–û:* –°–æ–±–ª—é–¥–∞–π—Ç–µ –≤—Ä–µ–º—è, —É–¥–æ–±–Ω–æ–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞!"""
        
        # Always send to admin chat for now
        chat_id = "730764738"  # Admin chat
        
        success = send_telegram_message(chat_id, message)
        
        if success:
            print(f"‚úì Callback notification sent to Telegram chat {chat_id}")
        else:
            print(f"‚úó Failed to send callback notification to Telegram")
            
    except Exception as e:
        print(f"Error sending callback notification to Telegram: {e}")


# Database initialization happens in the app context below

@app.route('/api/blog/search')
def blog_search_api():
    """API endpoint for instant blog search and suggestions"""
    from models import BlogPost, Category
    from sqlalchemy import or_, func
    
    try:
        query = request.args.get('q', '').strip()
        category = request.args.get('category', '').strip()
        suggestions_only = request.args.get('suggestions', '').lower() == 'true'
        
        # Start with base query - use BlogPost (where data actually is)
        search_query = BlogPost.query.filter(BlogPost.status == 'published')
        
        # Apply search filter
        if query:
            search_query = search_query.filter(
                or_(
                    BlogPost.title.ilike(f'%{query}%'),
                    BlogPost.content.ilike(f'%{query}%'),
                    BlogPost.excerpt.ilike(f'%{query}%')
                )
            )
        
        # Apply category filter
        if category:
            search_query = search_query.filter(BlogPost.category == category)
        
        # For suggestions, limit to title matches only
        if suggestions_only:
            if query:
                suggestions = search_query.filter(
                    BlogPost.title.ilike(f'%{query}%')
                ).limit(5).all()
                
                return jsonify({
                    'suggestions': [{
                        'title': post.title,
                        'slug': post.slug,
                        'category': post.category or '–û–±—â–µ–µ'
                    } for post in suggestions]
                })
            else:
                return jsonify({'suggestions': []})
        
        # For full search, return formatted articles
        articles = search_query.order_by(BlogPost.created_at.desc()).limit(20).all()
        
        formatted_articles = []
        for article in articles:
            formatted_articles.append({
                'title': article.title,
                'slug': article.slug,
                'excerpt': article.excerpt or '',
                'featured_image': article.featured_image or '',
                'category': article.category or '–û–±—â–µ–µ',
                'date': article.created_at.strftime('%d.%m.%Y'),
                'reading_time': getattr(article, 'reading_time', 5),
                'views': getattr(article, 'views', 0)
            })
        return jsonify({
            'articles': formatted_articles,
            'total': len(formatted_articles)
        })
        
    except Exception as e:
        print(f"ERROR in blog search API: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Search failed', 'articles': [], 'suggestions': []}), 500

# Developer Scraper Management Endpoints
@app.route('/admin/scraper')
@admin_required
def admin_scraper():
    """Admin panel for developer scraper management"""
    from models import Admin
    
    admin_id = session.get('admin_id')
    admin = Admin.query.get(admin_id)
    
    return render_template('admin/scraper.html', admin=admin)

@app.route('/admin/scraper/run', methods=['POST'])
@admin_required
def run_scraper():
    """Run the AI-powered developer scraper"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –ª–∏–º–∏—Ç–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)
        limit = 10
        try:
            data = request.get_json(force=True) if request.data else {}
        except:
            data = {}
        
        if data:
            limit = data.get('limit', 10)
        
        service = DeveloperParserService()
        result = service.parse_and_save_developers(limit=limit)
        
        return jsonify({
            'success': True,
            'stats': {
                'developers_created': result.get('created', 0),
                'developers_updated': result.get('updated', 0),
                'total_processed': result.get('total_processed', 0),
                'errors': result.get('errors', 0)
            },
            'message': f'–ò–ò-–ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω! –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {result["total_processed"]} –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤. –°–æ–∑–¥–∞–Ω–æ: {result["created"]}, –æ–±–Ω–æ–≤–ª–µ–Ω–æ: {result["updated"]}',
            'errors_list': result.get('errors_list', [])
        })
        
    except Exception as e:
        print(f"AI Scraper error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ò–ò-–ø–∞—Ä—Å–∏–Ω–≥–µ: {str(e)}'
        }), 500

@app.route('/admin/scraper/test', methods=['POST'])
@admin_required
def test_scraper():
    """Test AI scraper with sample data"""
    try:
        # –ü—Ä–æ—Å—Ç—ã–µ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        test_data = {
            'name': '–¢–µ—Å—Ç–æ–≤—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫',
            'description': '–û–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞',
            'website': 'https://example.com',
            'phone': '+7-918-000-00-00',
            'email': 'test@example.com'
        }
        
        return jsonify({
            'success': True,
            'data': test_data,
            'stats': {
                'developers_tested': 1,
                'complexes_found': 0,
                'ai_extraction': True,
                'mock_data': True
            },
            'message': '–ò–ò-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω! –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫'
        })
        
    except Exception as e:
        print(f"AI Scraper test error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –ò–ò-–ø–∞—Ä—Å–µ—Ä–∞: {str(e)}'
        }), 500

@app.route('/admin/scraper/statistics')
@admin_required
def scraper_statistics():
    """Get AI parser statistics"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        service = DeveloperParserService()
        stats = service.get_parsing_statistics()
        
        return jsonify({
            'success': True,
            'data': stats
        })
        
    except Exception as e:
        print(f"Statistics error: {e}")
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}'
        }), 500

@app.route('/admin/scraper/files')
@admin_required
def scraper_files():
    """List scraped data files"""
    try:
        import glob
        import os
        from datetime import datetime
        
        files = glob.glob('scraped_developers_*.json')
        file_info = []
        
        for file in files:
            stat = os.stat(file)
            file_info.append({
                'name': file,
                'size': stat.st_size,
                'created': datetime.fromtimestamp(stat.st_ctime).strftime('%d.%m.%Y %H:%M'),
                'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%d.%m.%Y %H:%M')
            })
        
        # Sort by creation time, newest first
        file_info.sort(key=lambda x: x['modified'], reverse=True)
        
        return jsonify({
            'success': True,
            'files': file_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤: {str(e)}'
        }), 500

@app.route('/admin/scraper/view-file/<filename>')
@admin_required
def view_scraped_file(filename):
    """View scraped data file content"""
    try:
        import json
        import os
        
        # Security check - only allow scraped files
        if not filename.startswith('scraped_developers_') or not filename.endswith('.json'):
            return jsonify({'success': False, 'message': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∏–º—è —Ñ–∞–π–ª–∞'}), 400
        
        if not os.path.exists(filename):
            return jsonify({'success': False, 'message': '–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        return jsonify({
            'success': True,
            'data': data,
            'filename': filename
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {str(e)}'
        }), 500

@app.route('/admin/upload-excel', methods=['POST'])
def admin_upload_excel():
    """Handle Excel file upload from admin panel"""
    try:
        if 'excel_file' not in request.files:
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'})
        
        file = request.files['excel_file']
        if file.filename == '':
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'})
        
        if not file.filename.endswith(('.xlsx', '.xls')):
            return jsonify({'success': False, 'error': '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã Excel (.xlsx, .xls)'})
        
        # Save file to attached_assets directory
        import os
        import uuid
        
        # Ensure attached_assets directory exists
        os.makedirs('attached_assets', exist_ok=True)
        
        # Generate unique filename
        file_extension = os.path.splitext(file.filename)[1]
        unique_filename = f"upload_{uuid.uuid4().hex[:8]}{file_extension}"
        file_path = os.path.join('attached_assets', unique_filename)
        
        # Save the file
        file.save(file_path)
        
        # –ó–∞–ø—É—Å–∫ –∏–º–ø–æ—Ä—Ç–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
        try:
            import threading
            import time
            
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –∑–∞–¥–∞—á–∏
            task_id = unique_filename.replace('.', '_')
            
            # –°—Ç–∞—Ç—É—Å –∏–º–ø–æ—Ä—Ç–∞ (–±—É–¥–µ–º —Ö—Ä–∞–Ω–∏—Ç—å –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π)
            global import_status
            if 'import_status' not in globals():
                import_status = {}
            
            import_status[task_id] = {
                'status': 'processing',
                'progress': 0,
                'message': '–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...',
                'started_at': time.time()
            }
            
            def background_import():
                try:
                    with app.app_context():
                        result = import_excel_to_database(file_path)
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
                    import_status[task_id] = {
                        'status': 'completed',
                        'progress': 100,
                        'message': f'‚úÖ {result["message"]} –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {result["imported"]} –∑–∞–ø–∏—Å–µ–π.',
                        'result': result,
                        'completed_at': time.time()
                    }
                    
                    # –û—á–∏—â–∞–µ–º –∫–µ—à
                    global _properties_cache, _cache_timestamp
                    _properties_cache = None
                    _cache_timestamp = None
                    
                except Exception as import_error:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ –æ—à–∏–±–∫–µ
                    import_status[task_id] = {
                        'status': 'error',
                        'progress': 0,
                        'message': f'‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {str(import_error)}',
                        'error': str(import_error),
                        'failed_at': time.time()
                    }
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∏–º–ø–æ—Ä—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            thread = threading.Thread(target=background_import, daemon=True)
            thread.start()
            
            # –°—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
            return jsonify({
                'success': True,
                'message': f'üì§ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω! –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ñ–æ–Ω–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç.',
                'task_id': task_id,
                'background': True
            })
            
        except Exception as import_error:
            return jsonify({
                'success': False, 
                'error': f'–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {str(import_error)}'
            })
            
    except Exception as e:
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}'})

@app.route('/admin/check-import-status/<task_id>')
def admin_check_import_status(task_id):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞"""
    try:
        global import_status
        if 'import_status' not in globals():
            import_status = {}
        
        if task_id not in import_status:
            return jsonify({
                'success': False,
                'error': '–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
            })
        
        status_info = import_status[task_id]
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        import time
        if 'started_at' in status_info:
            elapsed = time.time() - status_info['started_at']
            status_info['elapsed_time'] = f"{elapsed:.1f} —Å–µ–∫"
        
        return jsonify({
            'success': True,
            'status': status_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞: {str(e)}'
        })

# ================== REGIONAL FUNCTIONS ==================

def parse_address_components(address_display_name):
    """
    –ü–∞—Ä—Å–∏—Ç –ø–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ä–µ–≥–∏–æ–Ω, –≥–æ—Ä–æ–¥ –∏ —Ä–∞–π–æ–Ω
    –ü—Ä–∏–º–µ—Ä: "–†–æ—Å—Å–∏—è, –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, –°–æ—á–∏, –ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω, –ò—Å–∫—Ä—ã, 88 –ª–∏—Ç7"
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: {'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π', 'city': '–°–æ—á–∏', 'district': '–ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω'}
    """
    if not address_display_name:
        return {'region': None, 'city': None, 'district': None}
    
    # –†–∞–∑–¥–µ–ª—è–µ–º –∞–¥—Ä–µ—Å –ø–æ –∑–∞–ø—è—Ç—ã–º
    parts = [part.strip() for part in address_display_name.split(',')]
    
    result = {'region': None, 'city': None, 'district': None}
    
    # –ò—â–µ–º —Ä–µ–≥–∏–æ–Ω (–æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç "–∫—Ä–∞–π", "–æ–±–ª–∞—Å—Ç—å", "—Ä–µ—Å–ø—É–±–ª–∏–∫–∞")
    for part in parts:
        if any(keyword in part.lower() for keyword in ['–∫—Ä–∞–π', '–æ–±–ª–∞—Å—Ç—å', '—Ä–µ—Å–ø—É–±–ª–∏–∫–∞', '—Ñ–µ–¥–µ—Ä–∞—Ü–∏—è']):
            result['region'] = part
            break
    
    # –ò—â–µ–º –≥–æ—Ä–æ–¥ (–ø–æ—Å–ª–µ —Ä–µ–≥–∏–æ–Ω–∞, –æ–±—ã—á–Ω–æ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤)
    region_found = False
    for part in parts:
        if result['region'] and part == result['region']:
            region_found = True
            continue
        
        if region_found and part != '–†–æ—Å—Å–∏—è':
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ —É–ª–∏—Ü–∞ –∏–ª–∏ –¥–æ–º
            if not any(keyword in part.lower() for keyword in ['—É–ª', '—É–ª–∏—Ü–∞', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä-—Ç', '–ø–µ—Ä–µ—É–ª–æ–∫', '–ø–µ—Ä', '–º-–Ω', '–ª–∏—Ç', '—Å—Ç—Ä', '–∫–æ—Ä–ø', '–¥.']):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ –Ω–æ–º–µ—Ä –∏ –Ω–µ –ø—Å–µ–≤–¥–æ-–≥–æ—Ä–æ–¥ —Ç–∏–ø–∞ "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä 6"
                if not part.replace(' ', '').replace('–∞', '').replace('–±', '').replace('–≤', '').replace('–≥', '').isdigit():
                    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Å–µ–≤–¥–æ-–≥–æ—Ä–æ–¥–∞ (–Ω–∞–∑–≤–∞–Ω–∏–µ + –ø—Ä–æ–±–µ–ª + —á–∏—Å–ª–æ)
                    import re
                    if not re.match(r'^[–∞-—è—ë]+\s+\d+$', part.lower()):
                        result['city'] = part
                        break
    
    # –ò—â–µ–º —Ä–∞–π–æ–Ω/–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω (–æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç "–º-–Ω", "—Ä-–Ω" –∏–ª–∏ –∏–¥–µ—Ç –ø–æ—Å–ª–µ –≥–æ—Ä–æ–¥–∞)
    city_found = False
    for part in parts:
        if result['city'] and part == result['city']:
            city_found = True
            continue
            
        if city_found:
            # –ï—Å–ª–∏ —ç—Ç–æ —Ä–∞–π–æ–Ω/–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω
            if any(keyword in part.lower() for keyword in ['–º-–Ω', '—Ä-–Ω', '—Ä–∞–π–æ–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω', '–º–∫—Ä']):
                result['district'] = part
                break
            # –ò–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞–π–æ–Ω–∞ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤ (–ø–µ—Ä–≤–æ–µ –ø–æ—Å–ª–µ –≥–æ—Ä–æ–¥–∞)
            elif not any(keyword in part.lower() for keyword in ['—É–ª', '—É–ª–∏—Ü–∞', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä-—Ç', '–ª–∏—Ç', '—Å—Ç—Ä', '–∫–æ—Ä–ø', '–¥–æ–º', '–¥.']):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ –Ω–æ–º–µ—Ä –¥–æ–º–∞ (—Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã –∏ –±—É–∫–≤—ã —Ç–∏–ø–∞ 2–ê, 10, 36 –∏ —Ç.–¥.)
                if not (part.replace('/', '').replace('–∫', '').replace('—Å—Ç—Ä', '').replace('–∞', '').replace('–±', '').replace('–≤', '').replace('–≥', '').replace(' ', '').isdigit() or len(part) <= 5):
                    result['district'] = part
                    break
    
    return result

def get_or_create_region(region_name):
    """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ä–µ–≥–∏–æ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    if not region_name:
        return None
        
    from models import Region
    
    # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ä–µ–≥–∏–æ–Ω
    region = Region.query.filter_by(name=region_name).first()
    
    if not region:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ä–µ–≥–∏–æ–Ω
        slug = region_name.lower().replace(' ', '-').replace('—Å–∫–∏–π', '').replace('–∫—Ä–∞–π', 'krai')
        region = Region(
            name=region_name,
            slug=slug,
            is_active=True,
            is_default=(region_name == '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π')  # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        )
        db.session.add(region)
        try:
            db.session.commit()
            print(f"Created new region: {region_name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating region {region_name}: {e}")
            return None
    
    return region

def get_or_create_city(city_name, region):
    """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –≥–æ—Ä–æ–¥ –≤ —Ä–µ–≥–∏–æ–Ω–µ"""
    if not city_name or not region:
        return None
        
    from models import City
    
    # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –≥–æ—Ä–æ–¥ –≤ —ç—Ç–æ–º —Ä–µ–≥–∏–æ–Ω–µ
    city = City.query.filter_by(name=city_name, region_id=region.id).first()
    
    if not city:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≥–æ—Ä–æ–¥
        slug = city_name.lower().replace(' ', '-')
        city = City(
            name=city_name,
            slug=slug,
            region_id=region.id,
            is_active=True,
            is_default=(city_name == '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')  # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        )
        db.session.add(city)
        try:
            db.session.commit()
            print(f"Created new city: {city_name} in {region.name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating city {city_name}: {e}")
            return None
    
    return city

def update_properties_with_regions():
    """–û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ —Å —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π"""
    from models import ExcelProperty
    
    properties = ExcelProperty.query.all()
    updated_count = 0
    
    print(f"Updating {len(properties)} properties with regional data...")
    
    for prop in properties:
        if prop.address_display_name:
            # –ü–∞—Ä—Å–∏–º –∞–¥—Ä–µ—Å
            address_parts = parse_address_components(prop.address_display_name)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä—Å–µ–Ω—ã–µ –ø–æ–ª—è
            prop.parsed_region = address_parts['region']
            prop.parsed_city = address_parts['city'] 
            prop.parsed_district = address_parts['district']
            
            # –°–æ–∑–¥–∞–µ–º/–Ω–∞—Ö–æ–¥–∏–º —Ä–µ–≥–∏–æ–Ω –∏ –≥–æ—Ä–æ–¥
            if address_parts['region']:
                region = get_or_create_region(address_parts['region'])
                if region:
                    prop.region_id = region.id
                    
                    if address_parts['city']:
                        city = get_or_create_city(address_parts['city'], region)
                        if city:
                            prop.city_id = city.id
            
            updated_count += 1
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ —á–∞—Å—Ç—è–º –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–æ–≤
            if updated_count % 50 == 0:
                try:
                    db.session.commit()
                    print(f"Updated {updated_count} properties...")
                except Exception as e:
                    print(f"Error committing batch: {str(e)}")
                    db.session.rollback()
    
    # –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–º–∏—Ç
    try:
        db.session.commit()
        print(f"‚úÖ Successfully updated {updated_count} properties with regional data")
    except Exception as e:
        print(f"Error in final commit: {str(e)}")
        db.session.rollback()
    
    return updated_count
